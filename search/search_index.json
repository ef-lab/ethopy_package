{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ethopy","text":"<p>Ethopy is a state control system for automated, high-throughput behavioral training based on Python. It provides a flexible framework for designing and running behavioral experiments with:</p> <ul> <li>Tight integration with database storage &amp; control using Datajoint</li> <li>Cross-platform support (Linux, macOS, Windows)</li> <li>Optimized for Raspberry Pi boards</li> <li>Modular architecture with overridable components</li> <li>Built-in support for various experiment types, stimuli, and behavioral interfaces</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Modular Design: Comprised of several overridable modules that define the structure of experiments, stimuli, and behavioral control</li> <li>Database Integration: Automatic storage and management of experimental data using Datajoint</li> <li>Multiple Experiment Types: Support for various experiment paradigms (MatchToSample, Navigation, Passive Viewing, etc.)</li> <li>Hardware Integration: Interfaces with multiple hardware setups (MultiPort, VRBall, Touchscreen)</li> <li>Stimulus Control: Various stimulus types supported (Gratings, Movies, Olfactory, 3D Objects)</li> <li>Real-time Control: State-based experiment control with precise timing</li> <li>Extensible: Easy to add new experiment types, stimuli, or behavioral interfaces</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<p>The following diagram illustrates the relationship between the core modules:</p> <p></p>"},{"location":"#core-modules","title":"Core modules:","text":""},{"location":"#experiment","title":"Experiment","text":"<p>Main state experiment Empty class that is overriden by other classes depending on the type of experiment.</p> <p>This class can have various State classes. An Entry and Exit State are necessary, all the rest can be customized.</p> <p>A typical experiment state diagram:</p> <p></p> <p>Each of the states is discribed by 4 overridable funcions:</p> <p></p> <p>Tables that are needed for the experiment that discribe the setup:</p> <p>SetupConfiguration SetupConfiguration.Port SetupConfiguration.Screen</p> <p>The experiment parameters are specified in *.py script configuration files that are entered in the Task table within the lab_experriment schema.  Some examples are in the conf folder but any folder that is accessible to the system can be used. Each protocol has a unique task_idx identifier that is used uppon running. </p> <p>Implemented experiment types: * MatchToSample: Experiment with Cue/Delay/Response periods  * MatchPort: Stimulus matched to ports * Navigate: Navigation experiment * Passive: Passive stimulus presentation experiment * FreeWater: Free water delivery experiment * Calibrate: Port Calibration of water amount * PortTest: Testing port for water delivery</p>"},{"location":"#behavior","title":"Behavior","text":"<p>Empty class that handles the animal behavior in the experiment.  </p> <p>IMPORTANT: Liquid calibration protocol needs to be run frequently for accurate liquid delivery</p> <p>Implemented Behavior types: * MultiPort:  Default RP setup with lick, liquid delivery and proximity port * VRBall (beta): Ball for 2D environments with single lick/liquid delivery port * Touch (beta): Touchscreen interface</p>"},{"location":"#stimulus","title":"Stimulus","text":"<p>Empty class that handles the stimuli used in the experiment.</p> <p>Implemented stimulus types: * Grating: Orientation gratings * Bar: Moving bar for retinotopic mapping * Movies: Movie presentation * Olfactory: Odor persentation * Panda: Object presentation * VROdors: Virtual environment with odors * SmellyObjects: Odor-Visual objects</p> <p>Non-overridable classes:</p>"},{"location":"#logger-non-overridable","title":"Logger (non-overridable)","text":"<p>Handles all database interactions and it is shared across Experiment/Behavior/Stimulus classes non-overridable</p> <p>Data are storred in tables within 3 different schemata that are automatically created:</p> <p>lab_experiments: </p> <p>lab_behavior: </p> <p>lab_stimuli: </p>"},{"location":"#interface-non-overridable","title":"Interface (non-overridable)","text":"<p>Handles all communication with hardware</p>"},{"location":"#how-to-run","title":"How to run","text":"<p>You can run experiments in two modes:</p> <ol> <li>Service Mode: Controlled by the Control table in the database</li> <li>Direct Mode: Run a specific task directly</li> </ol> <p>Example of running a task: <pre><code># Run a grating test experiment\nethopy -p grating_test.py\n\n# Run a specific task by ID\nethopy --task-idx 1\n</code></pre></p> <p>This process can be automated by either a bash script that runs on startup or through control from a salt server. </p>"},{"location":"behavior/","title":"Core Behavior module","text":"<p>Core behavior module handles behavioral variables, responses, and reward management.</p> <p>This module provides the core functionality for managing animal behavior in experimental setups, including response tracking, reward delivery, and behavioral data logging. It interfaces with hardware components and maintains experiment state.</p>"},{"location":"behavior/#ethopy.core.behavior.Activity","title":"<code>Activity</code>","text":"<p>               Bases: <code>Manual</code></p> <p>DataJoint table for tracking behavioral responses.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>@behavior.schema\nclass Activity(dj.Manual):\n    \"\"\"DataJoint table for tracking behavioral responses.\"\"\"\n\n    definition = \"\"\"\n    # Mouse behavioral response\n    -&gt; experiment.Trial\n    \"\"\"\n\n    class Proximity(dj.Part):\n        \"\"\"DataJoint table for tracking proximity port information.\"\"\"\n\n        definition = \"\"\"\n        # Center port information\n        -&gt; Activity\n        port                 : tinyint          # port id\n        time\t     \t  \t : int           \t# time from session start (ms)\n        ---\n        in_position          : tinyint\n        \"\"\"\n\n    class Lick(dj.Part):\n        \"\"\"DataJoint table for licking.\"\"\"\n\n        definition = \"\"\"\n        # Lick timestamps\n        -&gt; Activity\n        port                 : tinyint          # port id\n        time\t     \t  \t : int           \t# time from session start (ms)\n        \"\"\"\n\n    class Touch(dj.Part):\n        \"\"\"DataJoint table for touch timestamps.\"\"\"\n\n        definition = \"\"\"\n        # Touch timestamps\n        -&gt; Activity\n        loc_x               : int               # x touch location\n        loc_y               : int               # y touch location\n        time\t     \t    : int           \t# time from session start (ms)\n        \"\"\"\n\n    class Position(dj.Part):\n        \"\"\"DataJoint table for 2D possition timestamps.\"\"\"\n\n        definition = \"\"\"\n        # 2D possition timestamps\n        -&gt; Activity\n        loc_x               : float             # x 2d location\n        loc_y               : float             # y 2d location\n        theta               : float             # direction in space\n        time\t     \t    : int           \t# time from session start (ms)\n        \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Activity.Lick","title":"<code>Lick</code>","text":"<p>               Bases: <code>Part</code></p> <p>DataJoint table for licking.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>class Lick(dj.Part):\n    \"\"\"DataJoint table for licking.\"\"\"\n\n    definition = \"\"\"\n    # Lick timestamps\n    -&gt; Activity\n    port                 : tinyint          # port id\n    time\t     \t  \t : int           \t# time from session start (ms)\n    \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Activity.Position","title":"<code>Position</code>","text":"<p>               Bases: <code>Part</code></p> <p>DataJoint table for 2D possition timestamps.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>class Position(dj.Part):\n    \"\"\"DataJoint table for 2D possition timestamps.\"\"\"\n\n    definition = \"\"\"\n    # 2D possition timestamps\n    -&gt; Activity\n    loc_x               : float             # x 2d location\n    loc_y               : float             # y 2d location\n    theta               : float             # direction in space\n    time\t     \t    : int           \t# time from session start (ms)\n    \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Activity.Proximity","title":"<code>Proximity</code>","text":"<p>               Bases: <code>Part</code></p> <p>DataJoint table for tracking proximity port information.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>class Proximity(dj.Part):\n    \"\"\"DataJoint table for tracking proximity port information.\"\"\"\n\n    definition = \"\"\"\n    # Center port information\n    -&gt; Activity\n    port                 : tinyint          # port id\n    time\t     \t  \t : int           \t# time from session start (ms)\n    ---\n    in_position          : tinyint\n    \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Activity.Touch","title":"<code>Touch</code>","text":"<p>               Bases: <code>Part</code></p> <p>DataJoint table for touch timestamps.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>class Touch(dj.Part):\n    \"\"\"DataJoint table for touch timestamps.\"\"\"\n\n    definition = \"\"\"\n    # Touch timestamps\n    -&gt; Activity\n    loc_x               : int               # x touch location\n    loc_y               : int               # y touch location\n    time\t     \t    : int           \t# time from session start (ms)\n    \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.BehActivity","title":"<code>BehActivity</code>  <code>dataclass</code>","text":"<p>Dataclass for tracking behavioral activity.</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>Port number where activity occurred</p> <code>type</code> <code>str</code> <p>Type of activity (e.g., 'Lick', 'Touch')</p> <code>time</code> <code>int</code> <p>Timestamp of activity</p> <code>in_position</code> <code>int</code> <p>Position status</p> <code>loc_x</code> <code>int</code> <p>X coordinate of activity</p> <code>loc_y</code> <code>int</code> <p>Y coordinate of activity</p> <code>theta</code> <code>int</code> <p>Angular position</p> <code>ready</code> <code>bool</code> <p>Ready status</p> <code>reward</code> <code>bool</code> <p>Whether activity was rewarded</p> <code>response</code> <code>bool</code> <p>Whether activity was a valid response</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>@dataclass\nclass BehActivity:\n    \"\"\"Dataclass for tracking behavioral activity.\n\n    Attributes:\n        port: Port number where activity occurred\n        type: Type of activity (e.g., 'Lick', 'Touch')\n        time: Timestamp of activity\n        in_position: Position status\n        loc_x: X coordinate of activity\n        loc_y: Y coordinate of activity\n        theta: Angular position\n        ready: Ready status\n        reward: Whether activity was rewarded\n        response: Whether activity was a valid response\n\n    \"\"\"\n\n    port: int = datafield(compare=True, default=0, hash=True)\n    type: str = datafield(compare=True, default=\"\", hash=True)\n    time: int = datafield(compare=False, default=0)\n    in_position: int = datafield(compare=False, default=0)\n    loc_x: int = datafield(compare=False, default=0)\n    loc_y: int = datafield(compare=False, default=0)\n    theta: int = datafield(compare=False, default=0)\n    ready: bool = datafield(compare=False, default=False)\n    reward: bool = datafield(compare=False, default=False)\n    response: bool = datafield(compare=False, default=False)\n\n    def __init__(self, **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"Initialize the behavior object with the provided keyword arguments.\"\"\"\n        names = set([f.name for f in fields(self)])\n        for k, v in kwargs.items():\n            if k in names:\n                setattr(self, k, v)\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.BehActivity.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize the behavior object with the provided keyword arguments.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def __init__(self, **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Initialize the behavior object with the provided keyword arguments.\"\"\"\n    names = set([f.name for f in fields(self)])\n    for k, v in kwargs.items():\n        if k in names:\n            setattr(self, k, v)\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.BehCondition","title":"<code>BehCondition</code>","text":"<p>               Bases: <code>Manual</code></p> <p>Datajoint table with a hash defining all the conditions.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>@behavior.schema\nclass BehCondition(dj.Manual):\n    \"\"\"Datajoint table with a hash defining all the conditions.\"\"\"\n\n    definition = \"\"\"\n    # reward probe conditions\n    beh_hash               : char(24)                     # unique reward hash\n    \"\"\"\n\n    class Trial(dj.Part):\n        \"\"\"Datajoint table for keeping the hash for each trial.\"\"\"\n\n        definition = \"\"\"\n        # movie clip conditions\n        -&gt; experiment.Trial\n        -&gt; BehCondition\n        time\t\t\t      : int \t                # time from session start (ms)\n        \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.BehCondition.Trial","title":"<code>Trial</code>","text":"<p>               Bases: <code>Part</code></p> <p>Datajoint table for keeping the hash for each trial.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>class Trial(dj.Part):\n    \"\"\"Datajoint table for keeping the hash for each trial.\"\"\"\n\n    definition = \"\"\"\n    # movie clip conditions\n    -&gt; experiment.Trial\n    -&gt; BehCondition\n    time\t\t\t      : int \t                # time from session start (ms)\n    \"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior","title":"<code>Behavior</code>","text":"<p>Manages behavioral variables and interactions in experimental setups.</p> <p>This class handles all aspects of behavioral monitoring and control: - Response tracking and validation - Reward delivery and management - Behavioral data logging through logger module - Condition management and history tracking - Interface with hardware components through experiment module</p> <p>Attributes:</p> Name Type Description <code>interface</code> <code>List[Any]</code> <p>List of interface objects</p> <code>required_fields</code> <code>List[str]</code> <p>Required fields for condition validation</p> <code>curr_cond</code> <code>List[Dict]</code> <p>Current condition parameters</p> <code>response</code> <code>List[Any]</code> <p>Current response data</p> <code>licked_port</code> <code>int</code> <p>ID of the most recently licked port</p> <code>logging</code> <code>bool</code> <p>Whether logging is enabled</p> <code>reward_amount</code> <code>Dict[int, float]</code> <p>Reward amounts by port</p> <code>choice_history</code> <code>List[float]</code> <p>History of animal choices</p> <code>reward_history</code> <code>List[float]</code> <p>History of rewards given</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>class Behavior:\n    \"\"\"Manages behavioral variables and interactions in experimental setups.\n\n    This class handles all aspects of behavioral monitoring and control:\n    - Response tracking and validation\n    - Reward delivery and management\n    - Behavioral data logging through logger module\n    - Condition management and history tracking\n    - Interface with hardware components through experiment module\n\n    Attributes:\n        interface (List[Any]): List of interface objects\n        required_fields (List[str]): Required fields for condition validation\n        curr_cond (List[Dict]): Current condition parameters\n        response (List[Any]): Current response data\n        licked_port (int): ID of the most recently licked port\n        logging (bool): Whether logging is enabled\n        reward_amount (Dict[int, float]): Reward amounts by port\n        choice_history (List[float]): History of animal choices\n        reward_history (List[float]): History of rewards given\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the behavior class with default values.\n\n        Attributes:\n            cond_tables (List[str]): A list of condition table names.\n            default_key (Dict[str, Any]): A dictionary for default key-value pairs.\n            interface (Any): The interface object (initially None).\n            required_fields (List[str]): A list of required field names.\n            curr_cond (List[Dict[str, Any]]): A list of current trial conditions.\n            response (List[Any]): A list for storing responses.\n            licked_port (int): The port is that was licked.\n            logging (bool): A flag indicating if logging is enabled.\n            reward_amount (Dict[int, float]): A dictionary mapping port numbers to\n                reward amounts.\n            choice_history (List[float]): A list of choice history values.\n            reward_history (List[float]): A list of reward history values.\n            punish_history (List[float]): A list of punishment history values.\n            choices (np.ndarray): An array of choices.\n            response_queue (Queue): A queue for storing responses with a maximum size\n                of 4.\n            last_lick: The last lick event (initially None).\n            params: Parameters for the experiment (initially None).\n            exp: The experiment object (initially None).\n            logger: The logger object (initially None).\n\n        \"\"\"\n        self.cond_tables: List[str] = []\n        self.default_key: Dict[str, Any] = {}\n        self.interface = None\n        self.required_fields: List[str] = []\n        self.curr_cond: List[Dict[str, Any]] = []\n        self.response: List[Any] = []\n        self.licked_port: int = 0\n        self.logging: bool = False\n        self.reward_amount: Dict[int, float] = {}\n        self.choice_history: List[float] = []\n        self.reward_history: List[float] = []\n        self.punish_history: List[float] = []\n        self.choices = np.array([])\n        self.response_queue: Queue = Queue(maxsize=4)\n        self.last_lick = None\n\n        self.params = None\n        self.exp = None\n        self.logger = None\n\n    def setup(self, exp: ExperimentClass) -&gt; None:\n        \"\"\"Set up behavior.\"\"\"\n        self.params = exp.params\n        self.exp = exp\n        self.logger = exp.logger\n        self.interface = exp.interface\n\n        self.choices = np.array(np.empty(0))\n        self.choice_history = []  # History term for bias calculation\n        self.reward_history = []  # History term for performance calculation\n        self.punish_history = []\n        self.reward_amount = dict()\n        self.response, self.last_lick = BehActivity(), BehActivity()\n        self.response_queue = Queue(maxsize=4)\n        self.logging = True\n\n    def is_ready(self, duration: int, since: int = 0) -&gt; Tuple[bool, int]:\n        \"\"\"Check if has been in position for a duration.\"\"\"\n        return True, 0\n\n    def get_response(self, since: int = 0, clear: bool = True) -&gt; bool:\n        \"\"\"Check for valid behavioral responses since a given time point.\n\n        Args:\n            since: Time reference point in milliseconds\n            clear: Whether to clear existing responses before checking\n\n        Returns:\n            Whether a valid response was detected\n\n        \"\"\"\n        # set a flag to indicate whether there is a valid response since the given time\n        _valid_response = False\n\n        # clear existing response if clear is True\n        if clear:\n            self.response = BehActivity()\n            self.licked_port = 0\n\n        while not self.response_queue.empty():\n            _response = self.response_queue.get()\n            if not _valid_response and _response.time &gt;= since and _response.port:\n                self.response = _response\n                _valid_response = True\n\n        return _valid_response\n\n    def is_licking(\n        self, since: int = 0, reward: bool = False, clear: bool = True\n    ) -&gt; int:\n        \"\"\"Check for licking activity since a given time point.\n\n        This method can be used in two ways:\n        1. To detect any licking activity since the given time\n        2. To check for rewarded licking (when reward=True) where only licks at reward\n        ports count\n\n        Args:\n            since (int, optional): Time reference point in milliseconds. Defaults to 0.\n            reward (bool, optional): Whether to only count licks at reward ports.\n                Defaults to False.\n            clear (bool, optional): Whether to reset last_lick after checking.\n                Defaults to True.\n\n        Returns:\n            int: Port number of valid lick (0 if no valid lick detected)\n\n        \"\"\"\n        # check if there is any licking since the given time\n        if self.last_lick.time &gt;= since and self.last_lick.port:\n            # if reward == False return the licked port number\n            # if reward == True check if the licked port is alse a reward port\n            if not reward or (reward and self.last_lick.reward):\n                self.licked_port = self.last_lick.port\n            else:\n                self.licked_port = 0\n        else:\n            self.licked_port = 0\n        # by default if it licked since the last time this function was called\n        if clear:\n            self.last_lick = BehActivity()\n\n        return self.licked_port\n\n    def reward(self) -&gt; None:\n        \"\"\"Reward action.\"\"\"\n        return True\n\n    def punish(self) -&gt; None:\n        \"\"\"Punish action.\"\"\"\n\n    def exit(self) -&gt; None:\n        \"\"\"Clean up and exit the behavior module.\"\"\"\n        self.logging = False\n\n    def log_activity(self, activity_key: dict) -&gt; int:\n        \"\"\"Log behavioral activity to the database.\n\n        Updates last_lick and licked_port variables, manages response queue,\n        and logs the activity in the database.\n\n        Args:\n            activity_key (dict): Dictionary containing activity parameters\n\n        Returns:\n            (int):Timestamp of the logged activity in milliseconds\n\n        \"\"\"\n        activity = BehActivity(**activity_key)\n        # if activity.time is not set, set it to the current time\n        if not activity.time:\n            activity.time = self.logger.logger_timer.elapsed_time()\n        key = {**self.logger.trial_key, **activity.__dict__}\n        # log the activity in the database\n        if self.exp.in_operation and self.logging:\n            self.logger.log(\"Activity\", key, schema=\"behavior\", priority=10)\n            self.logger.log(\"Activity.\" + activity.type, key, schema=\"behavior\")\n        # if activity.type == 'Response': append to the response queue\n        if activity.response:\n            if self.response_queue.full():\n                self.response_queue.get()\n            self.response_queue.put(activity)\n        # get the last lick and licked port to use it in is_licking function\n        if activity.type == \"Lick\":\n            self.last_lick = activity\n            self.licked_port = activity.port\n        return key[\"time\"]\n\n    def log_reward(self, reward_amount: float) -&gt; None:\n        \"\"\"Log delivered reward to the database.\n\n        Args:\n            reward_amount (float): Amount of reward delivered\n\n        \"\"\"\n        if isinstance(self.curr_cond[\"reward_port\"], list):\n            self.curr_cond[\"reward_port\"] = [self.licked_port]\n            self.curr_cond[\"response_port\"] = [self.licked_port]\n        self.logger.log(\n            \"Rewards\",\n            {**self.curr_cond, \"reward_amount\": reward_amount},\n            schema=\"behavior\",\n        )\n\n    def make_conditions(self, conditions: List[Dict[str, Any]]) -&gt; Dict[str, Any]:\n        \"\"\"Validate, update with default_key and generate hash for stimulus conditions.\n\n        Args:\n            conditions: List of condition dictionaries\n\n        Returns:\n            Dictionary containing processed conditions and metadata\n\n        \"\"\"\n        for cond in conditions:\n            missing_fields = [\n                field for field in self.required_fields if field not in cond\n            ]\n            assert not missing_fields, (\n                f\"Missing behavior required fields: {missing_fields}\"\n            )\n            cond.update({**self.default_key, **cond})\n\n        if self.cond_tables:\n            return self.exp.log_conditions(\n                conditions=conditions,\n                condition_tables=[\"BehCondition\"] + self.cond_tables,\n                schema=\"behavior\",\n                hash_field=\"beh_hash\",\n            )\n\n        return self.exp.log_conditions(\n            conditions=conditions, condition_tables=[], schema=\"behavior\",\n            hash_field=\"beh_hash\"\n        )\n\n    def prepare(self, condition: Dict[str, Any]) -&gt; None:\n        \"\"\"Prepare for a new trial with given conditions.\n\n        Args:\n            condition: Dictionary of trial conditions\n\n        \"\"\"\n        self.curr_cond = condition\n        self.reward_amount = self.interface.calc_pulse_dur(condition[\"reward_amount\"])\n        self.logger.log(\n            \"BehCondition.Trial\",\n            dict(beh_hash=self.curr_cond[\"beh_hash\"]),\n            schema=\"behavior\",\n        )\n\n    def update_history(\n        self, choice: float = np.nan, reward: float = np.nan, punish: float = np.nan\n    ) -&gt; None:\n        \"\"\"Update choice and reward history.\n\n        Args:\n            choice: Choice made (port number)\n            reward: Reward amount\n            punish: Punishment value\n\n        \"\"\"\n        if (\n            np.isnan(choice)\n            and (~np.isnan(reward) or ~np.isnan(punish))\n            and self.response.time &gt; 0\n        ):\n            choice = self.response.port\n        self.choice_history.append(choice)\n        self.reward_history.append(reward)\n        self.punish_history.append(punish)\n        self.logger.total_reward = np.nansum(self.reward_history)\n\n    def get_false_history(self, h: int = 10) -&gt; float:\n        \"\"\"Get history of false responses.\n\n        Args:\n            h: Number of trials to look back\n\n        Returns:\n            Cumulative product of false responses\n\n        \"\"\"\n        idx = np.nan_to_num(self.punish_history)\n        return np.nansum(np.cumprod(np.flip(idx[-h:], axis=0)))\n\n    def is_sleep_time(self) -&gt; bool:\n        \"\"\"Check if current time is within sleep period.\n\n        Returns:\n            Whether current time is in sleep period\n\n        \"\"\"\n        now = datetime.now()\n        start_time = self.logger.setup_info[\"start_time\"]\n        if isinstance(start_time, str):\n            dt = datetime.strptime(start_time, \"%H:%M:%S\")\n            start_time = timedelta(seconds=dt.hour * 3600 + dt.minute * 60 + dt.second)\n        stop_time = self.logger.setup_info[\"stop_time\"]\n        if isinstance(stop_time, str):\n            dt = datetime.strptime(stop_time, \"%H:%M:%S\")\n            stop_time = timedelta(seconds=dt.hour * 3600 + dt.minute * 60 + dt.second)\n\n        start = now.replace(hour=0, minute=0, second=0) + start_time\n        stop = now.replace(hour=0, minute=0, second=0) + stop_time\n        if stop &lt; start:\n            stop = stop + timedelta(days=1)\n        time_restriction = now &lt; start or now &gt; stop\n        return time_restriction\n\n    def is_hydrated(self, rew: Optional[float] = None) -&gt; bool:\n        \"\"\"Check if animal has received enough reward.\n\n        Args:\n            rew: Optional override for maximum reward amount\n\n        Returns:\n            Whether maximum reward threshold has been reached\n\n        \"\"\"\n        if rew:\n            return self.logger.total_reward &gt;= rew\n        elif self.params[\"max_reward\"]:\n            return self.logger.total_reward &gt;= self.params[\"max_reward\"]\n        else:\n            return False\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the behavior class with default values.</p> <p>Attributes:</p> Name Type Description <code>cond_tables</code> <code>List[str]</code> <p>A list of condition table names.</p> <code>default_key</code> <code>Dict[str, Any]</code> <p>A dictionary for default key-value pairs.</p> <code>interface</code> <code>Any</code> <p>The interface object (initially None).</p> <code>required_fields</code> <code>List[str]</code> <p>A list of required field names.</p> <code>curr_cond</code> <code>List[Dict[str, Any]]</code> <p>A list of current trial conditions.</p> <code>response</code> <code>List[Any]</code> <p>A list for storing responses.</p> <code>licked_port</code> <code>int</code> <p>The port is that was licked.</p> <code>logging</code> <code>bool</code> <p>A flag indicating if logging is enabled.</p> <code>reward_amount</code> <code>Dict[int, float]</code> <p>A dictionary mapping port numbers to reward amounts.</p> <code>choice_history</code> <code>List[float]</code> <p>A list of choice history values.</p> <code>reward_history</code> <code>List[float]</code> <p>A list of reward history values.</p> <code>punish_history</code> <code>List[float]</code> <p>A list of punishment history values.</p> <code>choices</code> <code>ndarray</code> <p>An array of choices.</p> <code>response_queue</code> <code>Queue</code> <p>A queue for storing responses with a maximum size of 4.</p> <code>last_lick</code> <code>Queue</code> <p>The last lick event (initially None).</p> <code>params</code> <code>Queue</code> <p>Parameters for the experiment (initially None).</p> <code>exp</code> <code>Queue</code> <p>The experiment object (initially None).</p> <code>logger</code> <code>Queue</code> <p>The logger object (initially None).</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the behavior class with default values.\n\n    Attributes:\n        cond_tables (List[str]): A list of condition table names.\n        default_key (Dict[str, Any]): A dictionary for default key-value pairs.\n        interface (Any): The interface object (initially None).\n        required_fields (List[str]): A list of required field names.\n        curr_cond (List[Dict[str, Any]]): A list of current trial conditions.\n        response (List[Any]): A list for storing responses.\n        licked_port (int): The port is that was licked.\n        logging (bool): A flag indicating if logging is enabled.\n        reward_amount (Dict[int, float]): A dictionary mapping port numbers to\n            reward amounts.\n        choice_history (List[float]): A list of choice history values.\n        reward_history (List[float]): A list of reward history values.\n        punish_history (List[float]): A list of punishment history values.\n        choices (np.ndarray): An array of choices.\n        response_queue (Queue): A queue for storing responses with a maximum size\n            of 4.\n        last_lick: The last lick event (initially None).\n        params: Parameters for the experiment (initially None).\n        exp: The experiment object (initially None).\n        logger: The logger object (initially None).\n\n    \"\"\"\n    self.cond_tables: List[str] = []\n    self.default_key: Dict[str, Any] = {}\n    self.interface = None\n    self.required_fields: List[str] = []\n    self.curr_cond: List[Dict[str, Any]] = []\n    self.response: List[Any] = []\n    self.licked_port: int = 0\n    self.logging: bool = False\n    self.reward_amount: Dict[int, float] = {}\n    self.choice_history: List[float] = []\n    self.reward_history: List[float] = []\n    self.punish_history: List[float] = []\n    self.choices = np.array([])\n    self.response_queue: Queue = Queue(maxsize=4)\n    self.last_lick = None\n\n    self.params = None\n    self.exp = None\n    self.logger = None\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.exit","title":"<code>exit()</code>","text":"<p>Clean up and exit the behavior module.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Clean up and exit the behavior module.\"\"\"\n    self.logging = False\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.get_false_history","title":"<code>get_false_history(h=10)</code>","text":"<p>Get history of false responses.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>int</code> <p>Number of trials to look back</p> <code>10</code> <p>Returns:</p> Type Description <code>float</code> <p>Cumulative product of false responses</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def get_false_history(self, h: int = 10) -&gt; float:\n    \"\"\"Get history of false responses.\n\n    Args:\n        h: Number of trials to look back\n\n    Returns:\n        Cumulative product of false responses\n\n    \"\"\"\n    idx = np.nan_to_num(self.punish_history)\n    return np.nansum(np.cumprod(np.flip(idx[-h:], axis=0)))\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.get_response","title":"<code>get_response(since=0, clear=True)</code>","text":"<p>Check for valid behavioral responses since a given time point.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>int</code> <p>Time reference point in milliseconds</p> <code>0</code> <code>clear</code> <code>bool</code> <p>Whether to clear existing responses before checking</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether a valid response was detected</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def get_response(self, since: int = 0, clear: bool = True) -&gt; bool:\n    \"\"\"Check for valid behavioral responses since a given time point.\n\n    Args:\n        since: Time reference point in milliseconds\n        clear: Whether to clear existing responses before checking\n\n    Returns:\n        Whether a valid response was detected\n\n    \"\"\"\n    # set a flag to indicate whether there is a valid response since the given time\n    _valid_response = False\n\n    # clear existing response if clear is True\n    if clear:\n        self.response = BehActivity()\n        self.licked_port = 0\n\n    while not self.response_queue.empty():\n        _response = self.response_queue.get()\n        if not _valid_response and _response.time &gt;= since and _response.port:\n            self.response = _response\n            _valid_response = True\n\n    return _valid_response\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.is_hydrated","title":"<code>is_hydrated(rew=None)</code>","text":"<p>Check if animal has received enough reward.</p> <p>Parameters:</p> Name Type Description Default <code>rew</code> <code>Optional[float]</code> <p>Optional override for maximum reward amount</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether maximum reward threshold has been reached</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def is_hydrated(self, rew: Optional[float] = None) -&gt; bool:\n    \"\"\"Check if animal has received enough reward.\n\n    Args:\n        rew: Optional override for maximum reward amount\n\n    Returns:\n        Whether maximum reward threshold has been reached\n\n    \"\"\"\n    if rew:\n        return self.logger.total_reward &gt;= rew\n    elif self.params[\"max_reward\"]:\n        return self.logger.total_reward &gt;= self.params[\"max_reward\"]\n    else:\n        return False\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.is_licking","title":"<code>is_licking(since=0, reward=False, clear=True)</code>","text":"<p>Check for licking activity since a given time point.</p> <p>This method can be used in two ways: 1. To detect any licking activity since the given time 2. To check for rewarded licking (when reward=True) where only licks at reward ports count</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>int</code> <p>Time reference point in milliseconds. Defaults to 0.</p> <code>0</code> <code>reward</code> <code>bool</code> <p>Whether to only count licks at reward ports. Defaults to False.</p> <code>False</code> <code>clear</code> <code>bool</code> <p>Whether to reset last_lick after checking. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Port number of valid lick (0 if no valid lick detected)</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def is_licking(\n    self, since: int = 0, reward: bool = False, clear: bool = True\n) -&gt; int:\n    \"\"\"Check for licking activity since a given time point.\n\n    This method can be used in two ways:\n    1. To detect any licking activity since the given time\n    2. To check for rewarded licking (when reward=True) where only licks at reward\n    ports count\n\n    Args:\n        since (int, optional): Time reference point in milliseconds. Defaults to 0.\n        reward (bool, optional): Whether to only count licks at reward ports.\n            Defaults to False.\n        clear (bool, optional): Whether to reset last_lick after checking.\n            Defaults to True.\n\n    Returns:\n        int: Port number of valid lick (0 if no valid lick detected)\n\n    \"\"\"\n    # check if there is any licking since the given time\n    if self.last_lick.time &gt;= since and self.last_lick.port:\n        # if reward == False return the licked port number\n        # if reward == True check if the licked port is alse a reward port\n        if not reward or (reward and self.last_lick.reward):\n            self.licked_port = self.last_lick.port\n        else:\n            self.licked_port = 0\n    else:\n        self.licked_port = 0\n    # by default if it licked since the last time this function was called\n    if clear:\n        self.last_lick = BehActivity()\n\n    return self.licked_port\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.is_ready","title":"<code>is_ready(duration, since=0)</code>","text":"<p>Check if has been in position for a duration.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def is_ready(self, duration: int, since: int = 0) -&gt; Tuple[bool, int]:\n    \"\"\"Check if has been in position for a duration.\"\"\"\n    return True, 0\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.is_sleep_time","title":"<code>is_sleep_time()</code>","text":"<p>Check if current time is within sleep period.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether current time is in sleep period</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def is_sleep_time(self) -&gt; bool:\n    \"\"\"Check if current time is within sleep period.\n\n    Returns:\n        Whether current time is in sleep period\n\n    \"\"\"\n    now = datetime.now()\n    start_time = self.logger.setup_info[\"start_time\"]\n    if isinstance(start_time, str):\n        dt = datetime.strptime(start_time, \"%H:%M:%S\")\n        start_time = timedelta(seconds=dt.hour * 3600 + dt.minute * 60 + dt.second)\n    stop_time = self.logger.setup_info[\"stop_time\"]\n    if isinstance(stop_time, str):\n        dt = datetime.strptime(stop_time, \"%H:%M:%S\")\n        stop_time = timedelta(seconds=dt.hour * 3600 + dt.minute * 60 + dt.second)\n\n    start = now.replace(hour=0, minute=0, second=0) + start_time\n    stop = now.replace(hour=0, minute=0, second=0) + stop_time\n    if stop &lt; start:\n        stop = stop + timedelta(days=1)\n    time_restriction = now &lt; start or now &gt; stop\n    return time_restriction\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.log_activity","title":"<code>log_activity(activity_key)</code>","text":"<p>Log behavioral activity to the database.</p> <p>Updates last_lick and licked_port variables, manages response queue, and logs the activity in the database.</p> <p>Parameters:</p> Name Type Description Default <code>activity_key</code> <code>dict</code> <p>Dictionary containing activity parameters</p> required <p>Returns:</p> Type Description <code>int</code> <p>Timestamp of the logged activity in milliseconds</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def log_activity(self, activity_key: dict) -&gt; int:\n    \"\"\"Log behavioral activity to the database.\n\n    Updates last_lick and licked_port variables, manages response queue,\n    and logs the activity in the database.\n\n    Args:\n        activity_key (dict): Dictionary containing activity parameters\n\n    Returns:\n        (int):Timestamp of the logged activity in milliseconds\n\n    \"\"\"\n    activity = BehActivity(**activity_key)\n    # if activity.time is not set, set it to the current time\n    if not activity.time:\n        activity.time = self.logger.logger_timer.elapsed_time()\n    key = {**self.logger.trial_key, **activity.__dict__}\n    # log the activity in the database\n    if self.exp.in_operation and self.logging:\n        self.logger.log(\"Activity\", key, schema=\"behavior\", priority=10)\n        self.logger.log(\"Activity.\" + activity.type, key, schema=\"behavior\")\n    # if activity.type == 'Response': append to the response queue\n    if activity.response:\n        if self.response_queue.full():\n            self.response_queue.get()\n        self.response_queue.put(activity)\n    # get the last lick and licked port to use it in is_licking function\n    if activity.type == \"Lick\":\n        self.last_lick = activity\n        self.licked_port = activity.port\n    return key[\"time\"]\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.log_reward","title":"<code>log_reward(reward_amount)</code>","text":"<p>Log delivered reward to the database.</p> <p>Parameters:</p> Name Type Description Default <code>reward_amount</code> <code>float</code> <p>Amount of reward delivered</p> required Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def log_reward(self, reward_amount: float) -&gt; None:\n    \"\"\"Log delivered reward to the database.\n\n    Args:\n        reward_amount (float): Amount of reward delivered\n\n    \"\"\"\n    if isinstance(self.curr_cond[\"reward_port\"], list):\n        self.curr_cond[\"reward_port\"] = [self.licked_port]\n        self.curr_cond[\"response_port\"] = [self.licked_port]\n    self.logger.log(\n        \"Rewards\",\n        {**self.curr_cond, \"reward_amount\": reward_amount},\n        schema=\"behavior\",\n    )\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.make_conditions","title":"<code>make_conditions(conditions)</code>","text":"<p>Validate, update with default_key and generate hash for stimulus conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>List[Dict[str, Any]]</code> <p>List of condition dictionaries</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing processed conditions and metadata</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def make_conditions(self, conditions: List[Dict[str, Any]]) -&gt; Dict[str, Any]:\n    \"\"\"Validate, update with default_key and generate hash for stimulus conditions.\n\n    Args:\n        conditions: List of condition dictionaries\n\n    Returns:\n        Dictionary containing processed conditions and metadata\n\n    \"\"\"\n    for cond in conditions:\n        missing_fields = [\n            field for field in self.required_fields if field not in cond\n        ]\n        assert not missing_fields, (\n            f\"Missing behavior required fields: {missing_fields}\"\n        )\n        cond.update({**self.default_key, **cond})\n\n    if self.cond_tables:\n        return self.exp.log_conditions(\n            conditions=conditions,\n            condition_tables=[\"BehCondition\"] + self.cond_tables,\n            schema=\"behavior\",\n            hash_field=\"beh_hash\",\n        )\n\n    return self.exp.log_conditions(\n        conditions=conditions, condition_tables=[], schema=\"behavior\",\n        hash_field=\"beh_hash\"\n    )\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.prepare","title":"<code>prepare(condition)</code>","text":"<p>Prepare for a new trial with given conditions.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Dict[str, Any]</code> <p>Dictionary of trial conditions</p> required Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def prepare(self, condition: Dict[str, Any]) -&gt; None:\n    \"\"\"Prepare for a new trial with given conditions.\n\n    Args:\n        condition: Dictionary of trial conditions\n\n    \"\"\"\n    self.curr_cond = condition\n    self.reward_amount = self.interface.calc_pulse_dur(condition[\"reward_amount\"])\n    self.logger.log(\n        \"BehCondition.Trial\",\n        dict(beh_hash=self.curr_cond[\"beh_hash\"]),\n        schema=\"behavior\",\n    )\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.punish","title":"<code>punish()</code>","text":"<p>Punish action.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def punish(self) -&gt; None:\n    \"\"\"Punish action.\"\"\"\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.reward","title":"<code>reward()</code>","text":"<p>Reward action.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def reward(self) -&gt; None:\n    \"\"\"Reward action.\"\"\"\n    return True\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.setup","title":"<code>setup(exp)</code>","text":"<p>Set up behavior.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def setup(self, exp: ExperimentClass) -&gt; None:\n    \"\"\"Set up behavior.\"\"\"\n    self.params = exp.params\n    self.exp = exp\n    self.logger = exp.logger\n    self.interface = exp.interface\n\n    self.choices = np.array(np.empty(0))\n    self.choice_history = []  # History term for bias calculation\n    self.reward_history = []  # History term for performance calculation\n    self.punish_history = []\n    self.reward_amount = dict()\n    self.response, self.last_lick = BehActivity(), BehActivity()\n    self.response_queue = Queue(maxsize=4)\n    self.logging = True\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Behavior.update_history","title":"<code>update_history(choice=np.nan, reward=np.nan, punish=np.nan)</code>","text":"<p>Update choice and reward history.</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>float</code> <p>Choice made (port number)</p> <code>nan</code> <code>reward</code> <code>float</code> <p>Reward amount</p> <code>nan</code> <code>punish</code> <code>float</code> <p>Punishment value</p> <code>nan</code> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>def update_history(\n    self, choice: float = np.nan, reward: float = np.nan, punish: float = np.nan\n) -&gt; None:\n    \"\"\"Update choice and reward history.\n\n    Args:\n        choice: Choice made (port number)\n        reward: Reward amount\n        punish: Punishment value\n\n    \"\"\"\n    if (\n        np.isnan(choice)\n        and (~np.isnan(reward) or ~np.isnan(punish))\n        and self.response.time &gt; 0\n    ):\n        choice = self.response.port\n    self.choice_history.append(choice)\n    self.reward_history.append(reward)\n    self.punish_history.append(punish)\n    self.logger.total_reward = np.nansum(self.reward_history)\n</code></pre>"},{"location":"behavior/#ethopy.core.behavior.Rewards","title":"<code>Rewards</code>","text":"<p>               Bases: <code>Manual</code></p> <p>DataJoint table for tracking reward trials.</p> Source code in <code>src/ethopy/core/behavior.py</code> <pre><code>@behavior.schema\nclass Rewards(dj.Manual):\n    \"\"\"DataJoint table for tracking reward trials.\"\"\"\n\n    definition = \"\"\"\n    # reward trials\n    -&gt; experiment.Trial\n    time\t\t\t        : int \t           # time from session start (ms)\n    ---\n    reward_type             : varchar(16)\n    reward_amount           : float            # reward amount\n    \"\"\"\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/ef-lab/ethopy_package/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>EthoPy could always use more documentation, whether as part of the official EthoPy docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/ef-lab/ethopy_package/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>Ready to contribute? Here's how to set up Ethopy for local development:</p> <ol> <li> <p>Fork the Ethopy repo on GitHub.</p> </li> <li> <p>Clone your fork locally:     <pre><code>git clone git@github.com:your_name_here/ethopy.git\ncd ethopy\n</code></pre></p> </li> <li> <p>Install development dependencies:     <pre><code>pip install -e \".[dev,docs]\"\n</code></pre></p> </li> <li> <p>Create a branch for local development:     <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre></p> </li> <li> <p>Make your changes locally. The project uses several tools to maintain code quality:         - ruff: Code formatting         - isort: Import sorting         - mypy: Static type checking         - ruff: Linting         - pytest: Testing</p> </li> <li> <p>Run the test suite and code quality checks:     <pre><code># Run tests with coverage\npytest\n\n# Run linting\nruff check src/ethopy\n</code></pre></p> </li> <li> <p>Build and check documentation locally:     <pre><code>mkdocs serve\n</code></pre>    Visit http://127.0.0.1:8000 to view the documentation.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:     <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre></p> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.md</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/ef-lab/ethopy_package/pulls and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"control/","title":"Using of the Control Table","text":"<p>The Control table is a critical component in EthoPy that manages experiment execution and setup status. It's part of the <code>lab_experiments</code> schema and is used primarily when running EthoPy in Service Mode.</p>"},{"location":"control/#control-table-fields","title":"Control Table Fields","text":"<p>The Control table contains the following important fields:</p> <ol> <li> <p><code>setup</code> (primary key)</p> <ul> <li>The hostname of the machine running the experiment</li> <li>Used to identify different experimental setups</li> </ul> </li> <li> <p><code>status</code></p> <ul> <li>Current status of the setup</li> <li>Possible values:<ul> <li>\"ready\" - Setup is in Welcome gui and ready for a new experiment</li> <li>\"running\" - Experiment is currently running</li> <li>\"stop\" - Request to stop the current experiment</li> <li>\"exit\" - An error has occured and it is in exit</li> </ul> </li> </ul> </li> <li> <p><code>last_ping</code></p> <ul> <li>Timestamp of the last status update</li> <li>Format: \"YYYY-MM-DD HH:MM:SS\"</li> <li>Updated every 5 seconds by default</li> </ul> </li> <li> <p><code>queue_size</code></p> <ul> <li>Number of pending operations in the queue</li> <li>Indicates the backlog of data waiting to be written to the database</li> </ul> </li> <li> <p><code>trials</code></p> <ul> <li>Current trial index in the session</li> <li>Tracks progress through the experiment</li> </ul> </li> <li> <p><code>total_liquid</code></p> <ul> <li>Total amount of reward delivered in the session</li> <li>Used for tracking reward delivery</li> </ul> </li> <li> <p><code>state</code></p> <ul> <li>Current state of the experiment</li> <li>Reflects which part of the experiment is currently executing (check experiment states)</li> </ul> </li> <li> <p><code>task_idx</code></p> <ul> <li>Index of the task to be executed</li> <li>Used to determine which experiment configuration to load</li> </ul> </li> </ol>"},{"location":"control/#how-to-use-the-control-table","title":"How to Use the Control Table","text":""},{"location":"control/#1-service-mode-operation","title":"1. Service Mode Operation","text":"<p>The Control table is automatically updated by the Logger class. You don't need to modify it directly in most cases.</p>"},{"location":"control/#2-monitoring-experiment-status","title":"2. Monitoring Experiment Status","text":"<pre><code># Example of checking setup status\ncontrol_entry = (experiment.Control &amp; {'setup': setup_name}).fetch1()\ncurrent_status = control_entry['status']\ncurrent_state = control_entry['state']\n</code></pre>"},{"location":"control/#3-controlling-experiments","title":"3. Controlling Experiments","text":"<p>The user only change the status of the experiment from running to stop and from ready to running. Also can change the animal_id and the task_id.</p> <pre><code># To start an experiment on a setup\nexperiment.Control.update1({\n    'setup': setup_name,\n    'status': 'running',\n    'task_idx': your_task_id\n})\n\n# To stop an experiment\nexperiment.Control.update1({\n    'setup': setup_name,\n    'status': 'stop'\n})\n</code></pre>"},{"location":"control/#important-notes","title":"Important Notes","text":"<ol> <li> <p>Automatic Updates: The Control table is automatically updated by the Logger class every 5 seconds (default update_period = 5000ms)</p> </li> <li> <p>Status Flow:</p> <ul> <li>Normal flow: ready -&gt; running</li> <li>Stop flow: running -&gt; stop -&gt; ready</li> <li>Exit flow: any_status (raised error) -&gt; exit</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>If an error occurs during experiment execution, the state field will show \"ERROR!\"</li> <li>Additional error details will be stored in the notes field</li> </ul> </li> <li> <p>Monitoring:</p> <ul> <li>The <code>last_ping</code> field can be used to monitor if a setup is active</li> <li>If a setup hasn't updated its status for a long time, it might indicate issues</li> </ul> </li> <li> <p>Thread Safety:</p> <ul> <li>All Control table operations are thread-safe</li> <li>Updates are protected by a thread lock to prevent race conditions</li> </ul> </li> </ol>"},{"location":"control/#example-usage-in-service-mode","title":"Example Usage in Service Mode","text":"<pre><code>from ethopy.core.logger import Logger\n\n# Initialize logger\nlogger = Logger()\n\n# Logger will automatically:\n# 1. Create an entry in Control table for this setup\n# 2. Monitor Control table for status changes\n# 3. Update setup status every 5 seconds\n# 4. Execute tasks based on task_idx when status is 'running'\n</code></pre>"},{"location":"control/#implementation-details","title":"Implementation Details","text":"<p>The Control table is managed primarily by the Logger class (<code>ethopy.core.logger.Logger</code>). Key implementation details include:</p> <ol> <li> <p>Status Synchronization:</p> <ul> <li>The <code>_sync_control_table</code> method runs in a separate thread</li> <li>Updates occur every 5 seconds by default</li> <li>Uses thread locks to ensure thread-safe operations</li> </ul> </li> <li> <p>Setup Information Updates:    <pre><code># Example of information updated in each cycle\ninfo = {\n    'last_ping': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n    'queue_size': self.queue.qsize(),\n    'trials': self.trial_key['trial_idx'],\n    'total_liquid': self.total_reward,\n    'state': self.curr_state,\n}\n</code></pre></p> </li> <li> <p>Error Recovery:</p> <ul> <li>The system includes automatic error recovery mechanisms</li> <li>Failed database operations are retried with increased priority</li> <li>Persistent failures trigger system shutdown with error logging</li> </ul> </li> </ol>"},{"location":"control/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Status Monitoring:</p> <ul> <li>Regularly check <code>last_ping</code> to ensure setups are active</li> <li>Monitor <code>queue_size</code> to detect potential bottlenecks</li> <li>Use <code>state</code> field to track experiment progress</li> </ul> </li> <li> <p>Error Handling:</p> <ul> <li>Implement monitoring for \"ERROR!\" states</li> <li>Check notes field for detailed error information</li> <li>check ethopy.log to track the issue</li> </ul> </li> <li> <p>Resource Management:</p> <ul> <li>Monitor <code>total_liquid</code> to ensure proper reward delivery</li> <li>Track <code>trials</code> to ensure experiment progress</li> <li>Use <code>task_idx</code> to verify correct experiment execution</li> </ul> </li> </ol>"},{"location":"database/","title":"Database Setup Guide","text":""},{"location":"database/#quick-start","title":"Quick Start","text":"<p>If you just want to get the database running:</p> <ol> <li>Install Docker on your system</li> <li>Run the setup command: <pre><code>ethopy-setup-djdocker\n</code></pre></li> <li>Enter a password when prompted</li> <li>Verify the setup: <pre><code>ethopy-db-connection\n</code></pre></li> </ol> <p>That's it! The database is ready to use.</p>"},{"location":"database/#detailed-guide","title":"Detailed Guide","text":""},{"location":"database/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker installed and running on your system</li> <li>Python 3.8 or higher</li> <li>EthoPy package installed</li> </ul>"},{"location":"database/#understanding-the-components","title":"Understanding the Components","text":"<p>The database setup consists of: - A MySQL database running in Docker - DataJoint configuration for EthoPy</p>"},{"location":"database/#setup-process","title":"Setup Process","text":""},{"location":"database/#1-docker-container-setup","title":"1. Docker Container Setup","text":"<pre><code>ethopy-setup-djdocker [--mysql-path PATH] [--container-name NAME]\n</code></pre> <p>Options: - <code>--mysql-path</code>: Custom path to store MySQL data (default: ~/.ethopy/mysql-docker) - <code>--container-name</code>: Custom name for the container (default: ethopy_sql_db)</p> <p>This command: - Creates a Docker container with MySQL - Sets up initial configuration - Ensures the database is accessible</p>"},{"location":"database/#2-database-connection-check","title":"2. Database Connection Check","text":"<p><pre><code>ethopy-db-connection\n</code></pre> Verifies that EthoPy can connect to the database.</p>"},{"location":"database/#3-schema-creation","title":"3. Schema Creation","text":"<p><pre><code>ethopy-setup-schema\n</code></pre> Creates all required database tables and structures.</p>"},{"location":"database/#troubleshooting","title":"Troubleshooting","text":""},{"location":"database/#container-wont-start","title":"Container Won't Start","text":"<ol> <li>Check Docker status: <pre><code>docker ps -a\n</code></pre></li> <li>Check Docker logs: <pre><code>docker logs ethopy_sql_db\n</code></pre></li> </ol>"},{"location":"database/#connection-issues","title":"Connection Issues","text":"<ol> <li>Verify port 3306 is available: <pre><code>netstat -an | grep 3306\n</code></pre></li> <li>Check your local configuration file (~/.ethopy/local_conf.json)</li> </ol>"},{"location":"database/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"database/#custom-database-host","title":"Custom Database Host","text":"<p>Edit your local_conf.json: <pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"YOUR_HOST\",\n        \"database.user\": \"root\",\n        \"database.password\": \"YOUR_PASSWORD\",\n        \"database.port\": 3306\n    }\n}\n</code></pre></p>"},{"location":"database/#multiple-environments","title":"Multiple Environments","text":"<p>You can run multiple database instances by using different container names: <pre><code>ethopy-setup-djdocker --container-name ethopy_dev\nethopy-setup-djdocker --container-name ethopy_prod\n</code></pre></p>"},{"location":"database/#security-considerations","title":"Security Considerations","text":"<ul> <li>Use strong passwords</li> <li>Don't expose the database port publicly</li> <li>Regular backups of ~/.ethopy/mysql-docker/data_*</li> </ul>"},{"location":"database/#technical-reference","title":"Technical Reference","text":""},{"location":"database/#command-details","title":"Command Details","text":""},{"location":"database/#setup_dj_docker","title":"setup_dj_docker","text":"<p>Sets up the Docker container with MySQL configured for EthoPy. <pre><code>setup_dj_docker(mysql_path: Optional[str], container_name: str)\n</code></pre></p>"},{"location":"database/#check_db_connection","title":"check_db_connection","text":"<p>Verifies database connectivity. <pre><code>check_db_connection()\n</code></pre></p>"},{"location":"database/#architecture","title":"Architecture","text":"<p>The setup follows a three-tier approach: 1. Container Management (Docker) 2. Database Configuration (MySQL) 3. Schema Management (DataJoint)</p> <p>Each tier is independent and can be modified without affecting the others.</p>"},{"location":"database_setup/","title":"Database Setup Guide","text":"<p>Ethopy uses MySQL as its database backend, with DataJoint as the data management framework. This guide explains how to set up and manage the database for Ethopy.</p>"},{"location":"database_setup/#docker-setup-recommended","title":"Docker Setup (Recommended)","text":"<p>The recommended way to run the database is using Docker with the official DataJoint MySQL image.</p>"},{"location":"database_setup/#prerequisites","title":"Prerequisites","text":"<ol> <li>Docker installed and running</li> <li>Docker Compose (usually included with Docker Desktop)</li> </ol>"},{"location":"database_setup/#using-the-built-in-setup-command","title":"Using the Built-in Setup Command","text":"<p>The easiest way to set up the database is using the provided command:</p> <pre><code>ethopy-setup-djdocker\n</code></pre> <p>This command will: 1. Check if Docker is running 2. Create a MySQL container named <code>ethopy_sql_db</code> 3. Set up the necessary volumes and configurations 4. Prompt for a root password 5. Start the container</p> <p>The Docker container uses: - Image: <code>datajoint/mysql:5.7</code> (https://github.com/datajoint/mysql-docker) - Port: 3306 (standard MySQL port) - Volume: <code>./data_ethopy_sql_db:/var/lib/mysql</code> for persistent data storage</p>"},{"location":"database_setup/#manual-docker-setup","title":"Manual Docker Setup","text":"<p>If you prefer to set up the container manually:</p> <ol> <li> <p>Create a <code>docker-compose.yaml</code> file: <pre><code>version: '2.4'\nservices:\n  ethopy_sql_db:\n    image: datajoint/mysql:5.7\n    environment:\n      - MYSQL_ROOT_PASSWORD=your_password\n    ports:\n      - '3306:3306'\n    volumes:\n      - ./data_ethopy_sql_db:/var/lib/mysql\n</code></pre></p> </li> <li> <p>Start the container: <pre><code>docker compose up -d\n</code></pre></p> </li> </ol>"},{"location":"database_setup/#remote-access","title":"Remote Access","text":"<p>To access the database from another computer:</p> <ol> <li> <p>Update the Docker port mapping to allow external access: <pre><code>ports:\n  - '0.0.0.0:3306:3306'\n</code></pre></p> </li> <li> <p>Configure the remote machine's <code>local_conf.json</code>: <pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"remote_server_ip\",\n        \"database.user\": \"root\",\n        \"database.password\": \"your_password\",\n        \"database.port\": 3306\n    }\n}\n</code></pre></p> </li> <li> <p>Ensure the Docker host's firewall allows connections on port 3306</p> </li> </ol>"},{"location":"database_setup/#standalone-mysql-setup","title":"Standalone MySQL Setup","text":"<p>If you prefer not to use Docker, you can install MySQL directly:</p>"},{"location":"database_setup/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install MySQL\nsudo apt update\nsudo apt install mysql-server\n\n# Start MySQL service\nsudo systemctl start mysql\nsudo systemctl enable mysql\n\n# Secure the installation\nsudo mysql_secure_installation\n\n# Create user and grant privileges\nsudo mysql\nCREATE USER 'ethopy'@'localhost' IDENTIFIED BY 'your_password';\nGRANT ALL PRIVILEGES ON *.* TO 'ethopy'@'localhost';\nFLUSH PRIVILEGES;\n</code></pre>"},{"location":"database_setup/#macos-using-homebrew","title":"macOS (using Homebrew)","text":"<pre><code># Install MySQL\nbrew install mysql\n\n# Start MySQL service\nbrew services start mysql\n\n# Secure the installation\nmysql_secure_installation\n\n# Create user and grant privileges\nmysql -u root -p\nCREATE USER 'ethopy'@'localhost' IDENTIFIED BY 'your_password';\nGRANT ALL PRIVILEGES ON *.* TO 'ethopy'@'localhost';\nFLUSH PRIVILEGES;\n</code></pre>"},{"location":"database_setup/#windows","title":"Windows","text":"<ol> <li>Download and install MySQL Community Server</li> <li>Follow the installation wizard</li> <li>Use MySQL Workbench or command line to create user and grant privileges</li> </ol>"},{"location":"database_setup/#database-schema-setup","title":"Database Schema Setup","text":"<p>After setting up the MySQL server (either via Docker or standalone), initialize the schemas:</p> <pre><code># Verify database connection\nethopy-db-connection\n\n# Create schemas\nethopy-setup-schema\n</code></pre> <p>This will create the following schemas: - <code>lab_experiments</code> - <code>lab_behavior</code> - <code>lab_stimuli</code></p>"},{"location":"database_setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"database_setup/#common-issues","title":"Common Issues","text":"<ol> <li>Connection Refused</li> <li>Check if MySQL service is running</li> <li>Verify port 3306 is not blocked by firewall</li> <li> <p>Ensure correct host/IP in configuration</p> </li> <li> <p>Authentication Failed</p> </li> <li>Verify username and password in <code>local_conf.json</code></li> <li> <p>Check user privileges in MySQL</p> </li> <li> <p>Docker Container Issues</p> </li> <li>Check Docker logs: <code>docker logs ethopy_sql_db</code></li> <li>Verify Docker daemon is running</li> <li>Check available disk space for volume</li> </ol>"},{"location":"database_setup/#useful-commands","title":"Useful Commands","text":"<pre><code># Check Docker container status\ndocker ps -a | grep ethopy_sql_db\n\n# View Docker logs\ndocker logs ethopy_sql_db\n\n# Restart Docker container\ndocker restart ethopy_sql_db\n\n# Check MySQL status (standalone installation)\nsudo systemctl status mysql\n\n# Test MySQL connection\nmysql -u root -p\n</code></pre>"},{"location":"database_setup/#additional-resources","title":"Additional Resources","text":"<ul> <li>DataJoint Documentation</li> <li>MySQL Documentation</li> <li>Docker MySQL Guide</li> <li>DataJoint MySQL Image</li> </ul>"},{"location":"experiment/","title":"Core Experiment module","text":"<p>Core experiment module for experiment control.</p> <p>This module provides the base classes and functionality for running behavioral experiments. It includes: - State machine implementation for experiment flow control - Condition management and randomization - Trial preparation and execution - Performance tracking and analysis</p> <p>The module is built around three main classes: - State: Base class for implementing experiment states - StateMachine: Control the flow of the experiment - ExperimentClass: Base class for experiment implementation</p>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass","title":"<code>ExperimentClass</code>","text":"<p>Parent Experiment.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>class ExperimentClass:\n    \"\"\"Parent Experiment.\"\"\"\n\n    curr_trial = 0  # the current trial number in the session\n    cur_block = 0  # the current block number in the session\n    states = {}  # dictionary wiht all states of the experiment\n    stims = {}  # dictionary with all stimulus classes\n    stim = False  # the current condition stimulus class\n    sync = False  # a boolean to make synchronization available\n    un_choices = []\n    blocks = []\n    iter = []\n    curr_cond = {}\n    block_h = []\n    has_responded = False\n    resp_ready = False\n    required_fields = []\n    default_key = {}\n    conditions = []\n    cond_tables = []\n    quit = False\n    in_operation = False\n    cur_block_sz = 0\n    params = None\n    logger = None\n    setup_conf_idx = 0\n    interface = None\n    beh = None\n    trial_start = 0  # time in ms of the trial start\n\n    def setup(self, logger: Logger, behavior_class, session_params: Dict) -&gt; None:\n        \"\"\"Set up Experiment.\"\"\"\n        self.in_operation = False\n        self.conditions = []\n        self.iter = []\n        self.quit = False\n        self.curr_cond = {}\n        self.block_h = []\n        self.stims = dict()\n        self.curr_trial = 0\n        self.cur_block_sz = 0\n        self.setup_conf_idx = session_params.get(\"setup_conf_idx\", 0)\n        session_params[\"setup_conf_idx\"] = self.setup_conf_idx\n\n        self.params = {**self.default_key, **session_params, \"setup_conf_idx\": self.setup_conf_idx}\n\n        self.logger = logger\n        self.beh = behavior_class()\n        self.interface = self._interface_setup(\n            self.beh, self.logger, self.setup_conf_idx\n        )\n        self.interface.load_calibration()\n        self.beh.setup(self)\n\n        self.logger.log_session(\n            session_params, experiment_type=self.cond_tables[0], log_task=True\n        )\n\n        self.session_timer = Timer()\n\n        np.random.seed(0)  # fix random seed, it can be overidden in the task file\n\n    def _interface_setup(self, beh, logger: Logger, setup_conf_idx: int) -&gt; \"Interface\":  # noqa: F821\n        interface_module = logger.get(\n            schema=\"interface\",\n            table=\"SetupConfiguration\",\n            fields=[\"interface\"],\n            key={\"setup_conf_idx\": setup_conf_idx},\n        )[0]\n        log.info(f\"Interface: {interface_module}\")\n        interface = getattr(\n            import_module(f\"ethopy.interfaces.{interface_module}\"), interface_module\n        )\n\n        return interface(exp=self, beh=beh)\n\n    def start(self) -&gt; None:\n        \"\"\"Start the StateMachine.\"\"\"\n        states = dict()\n        for state in self.__class__.__subclasses__():  # Initialize states\n            states.update({state().__class__.__name__: state(self)})\n        state_control = StateMachine(states)\n        self.interface.set_operation_status(True)\n        state_control.run()\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the epxeriment.\"\"\"\n        self.stim.exit()\n        self.interface.release()\n        self.beh.exit()\n        if self.sync:\n            while self.interface.is_recording():\n                log.info(\"Waiting for recording to end...\")\n                time.sleep(1)\n        self.logger.closeDatasets()\n        self.in_operation = False\n\n    def is_stopped(self) -&gt; None:\n        \"\"\"Check is experiment should stop.\"\"\"\n        self.quit = self.quit or self.logger.setup_status in [\"stop\", \"exit\"]\n        if self.quit and self.logger.setup_status not in [\"stop\", \"exit\"]:\n            self.logger.update_setup_info({\"status\": \"stop\"})\n        if self.quit:\n            self.in_operation = False\n        return self.quit\n\n    def _stim_init(self, stim_class, stims: Dict) -&gt; Dict:\n        # get stimulus class name\n        stim_name = stim_class.name()\n        if stim_name not in stims:\n            stim_class.init(self)\n            stims[stim_name] = stim_class\n        return stims\n\n    def get_keys_from_dict(self, data: Dict, keys: List) -&gt; Dict:\n        \"\"\"Efficiently extract specific keys from a dictionary.\n\n        Args:\n            data (dict): The input dictionary.\n            keys (list): The list of keys to extract.\n\n        Returns:\n            dict: A new dictionary with only the specified keys if they exist.\n\n        \"\"\"\n        keys_set = set(keys)  # Convert list to set for O(1) lookup\n        return {key: data[key] for key in keys_set.intersection(data)}\n\n    def _get_task_classes(self, stim_class) -&gt; Dict:\n        exp_name = {\"experiment_class\": self.cond_tables[0]}\n        beh_name = {\n            \"behavior_class\": self.beh.cond_tables[0] if self.beh.cond_tables else \"None\"\n        }\n        stim_name = {\"stimulus_class\": stim_class.name()}\n        return {**exp_name, **beh_name, **stim_name}\n\n    def make_conditions(\n        self,\n        stim_class,\n        conditions: Dict[str, Any],\n        stim_periods: List[str] = None,\n    ) -&gt; List[Dict]:\n        \"\"\"Create conditions by combining stimulus, behavior, and experiment.\"\"\"\n        log.debug(\"-------------- Make conditions --------------\")\n        self.stims = self._stim_init(stim_class, self.stims)\n        used_keys = set()  # all the keys used from dictionary conditions\n\n        # Handle stimulus conditions\n        stim_conditions, stim_keys = self._process_stim_conditions(\n            stim_class, conditions, stim_periods\n        )\n        used_keys.update(stim_keys)\n\n        # Process behavior conditions\n        beh_conditions, beh_keys = self._process_behavior_conditions(conditions)\n        used_keys.update(beh_keys)\n\n        # Process experiment conditions\n        exp_conditions, exp_keys = self._process_experiment_conditions(\n            self._get_task_classes(stim_class), conditions\n        )\n        used_keys.update(exp_keys)\n\n        # Combine results and handle unused parameters\n        partial_results = [exp_conditions, beh_conditions, stim_conditions]\n        unused_conditions = self._handle_unused_parameters(conditions, used_keys)\n        if unused_conditions:\n            partial_results.append(unused_conditions)\n        log.debug(\"-----------------------------------------------\")\n        return [\n            {k: v for d in comb for k, v in d.items()}\n            for comb in product(*partial_results)\n        ]\n\n    def _process_stim_conditions(\n        self, stim_class, conditions: Dict, stim_periods: List\n    ) -&gt; Tuple[List, List]:\n        \"\"\"Process stimulus-specific conditions.\"\"\"\n        if stim_periods:\n            period_conditions = {}\n            for period in stim_periods:\n                stim_dict = self.get_keys_from_dict(\n                    conditions[period], get_parameters(stim_class).keys()\n                )\n                log.debug(\n                    f\"Stimulus period: {period} use default conditions:\"\n                    f\"\\n{get_parameters(stim_class).keys() - stim_dict.keys()}\"\n                )\n                period_conditions[period] = factorize(stim_dict)\n                period_conditions[period] = self.stims[\n                    stim_class.name()\n                ].make_conditions(period_conditions[period])\n                for i, stim_condition in enumerate(period_conditions[period]):\n                    log.debug(\n                        f\"Stimulus condition {i}:\\n\"\n                        f\"{format_params_print(stim_condition)}\"\n                    )\n            stim_conditions = factorize(period_conditions)\n            return stim_conditions, stim_periods\n\n        stim_dict = self.get_keys_from_dict(\n            conditions, get_parameters(stim_class).keys()\n        )\n        log.debug(\n            f\"Stimulus use default conditions:\\n\"\n            f\"{get_parameters(stim_class).keys() - stim_dict.keys()}\"\n        )\n        stim_conditions = factorize(stim_dict)\n        stim_conditions = self.stims[stim_class.name()].make_conditions(stim_conditions)\n        for i, stim_condition in enumerate(stim_conditions):\n            log.debug(f\"Stimulus condition {i}:\\n{format_params_print(stim_condition)}\")\n        return stim_conditions, stim_dict.keys()\n\n    def _process_behavior_conditions(self, conditions: Dict) -&gt; Tuple[List, List]:\n        \"\"\"Process behavior-related conditions.\"\"\"\n        beh_dict = self.get_keys_from_dict(conditions, get_parameters(self.beh).keys())\n        log.debug(\n            f\"Behavior use default conditions:\\n\"\n            f\"{get_parameters(self.beh).keys() - beh_dict.keys()}\"\n        )\n        beh_conditions = factorize(beh_dict)\n        beh_conditions = self.beh.make_conditions(beh_conditions)\n        for i, beh_condition in enumerate(beh_conditions):\n            log.debug(f\"Behavior condition {i}:\\n{format_params_print(beh_condition)}\")\n        return beh_conditions, beh_dict.keys()\n\n    def _process_experiment_conditions(\n        self, task_classes: List, conditions: Dict\n    ) -&gt; Tuple[List, list]:\n        \"\"\"Process experiment-wide conditions.\"\"\"\n        exp_dict = self.get_keys_from_dict(conditions, get_parameters(self).keys())\n        exp_dict.update(task_classes)\n        log.debug(\n            f\"Experiment use default conditions:\\n\"\n            f\"{get_parameters(self).keys() - exp_dict.keys()}\"\n        )\n        exp_conditions = factorize(exp_dict)\n\n        for cond in exp_conditions:\n            self.validate_condition(cond)\n            cond.update({**self.default_key, **self.params, **cond})\n        cond_tables = [\"Condition.\" + table for table in self.cond_tables]\n        conditions_list = self.log_conditions(\n            exp_conditions, condition_tables=[\"Condition\"] + cond_tables\n        )\n        for i, exp_condition in enumerate(exp_conditions):\n            log.debug(\n                f\"Experiment condition {i}:\\n{format_params_print(exp_condition)}\"\n            )\n        return conditions_list, exp_dict.keys()\n\n    def _handle_unused_parameters(self, conditions, used_keys) -&gt; Union[List, None]:\n        \"\"\"Process any unused parameters.\"\"\"\n        unused_keys = set(conditions.keys()) - used_keys\n        if unused_keys:\n            log.warning(\n                f\"Keys: {unused_keys} are in condition but are not used from \"\n                f\"Experiment, Behavior or Stimulus\"\n            )\n            unused_dict = self.get_keys_from_dict(conditions, unused_keys)\n            return factorize(unused_dict)\n        return None\n\n    def validate_condition(self, condition: Dict) -&gt; None:\n        \"\"\"Validate a condition dictionary against the required fields.\n\n        Args:\n            condition (Dict): The condition dictionary to validate.\n\n        Raises:\n            ValueError: If required fields are missing from the condition.\n\n        \"\"\"\n        missing_fields = set(self.required_fields) - set(condition)\n        if missing_fields:\n            raise ValueError(f\"Missing experiment required fields: {missing_fields}\")\n\n    def push_conditions(self, conditions: List) -&gt; None:\n        \"\"\"Set the experimental conditions and initializes related data structures.\n\n        This method takes a list of condition dictionaries, prepares data structures\n        for tracking choices, blocks, and the current condition.  It also determines\n        unique choice hashes based on the response condition and difficulty.\n\n        Args:\n            conditions: A list of dictionaries, where each dictionary\n                represents an experimental condition.  Each condition\n                dictionary is expected to contain at least a \"difficulty\"\n                key.  If a `resp_cond` key (or the default \"response_port\")\n                is present, it's used to create unique choice hashes.\n\n        \"\"\"\n        log.info(f\"Number of conditions: {len(conditions)}\")\n        self.conditions = conditions\n        resp_cond = (\n            self.params[\"resp_cond\"] if \"resp_cond\" in self.params else \"response_port\"\n        )\n        self.blocks = np.array([cond[\"difficulty\"] for cond in self.conditions])\n        if np.all([resp_cond in cond for cond in conditions]):\n            self.choices = np.array(\n                [make_hash([d[resp_cond], d[\"difficulty\"]]) for d in conditions]\n            )\n            self.un_choices, un_idx = np.unique(self.choices, axis=0, return_index=True)\n            self.un_blocks = self.blocks[un_idx]\n        #  select random condition for first trial initialization\n        self.cur_block = min(self.blocks)\n        self.curr_cond = np.random.choice(\n            [i for (i, v) in zip(self.conditions, self.blocks == self.cur_block) if v]\n        )\n\n    def prepare_trial(self) -&gt; None:\n        \"\"\"Prepare trial conditions, stimuli and update trial index.\"\"\"\n        old_cond = self.curr_cond\n        self._get_new_cond()\n\n        if not self.curr_cond or self.logger.thread_end.is_set():\n            self.quit = True\n            return\n        if (\n            \"stimulus_class\" not in old_cond\n            or self.curr_trial == 0\n            or old_cond[\"stimulus_class\"] != self.curr_cond[\"stimulus_class\"]\n        ):\n            if \"stimulus_class\" in old_cond and self.curr_trial != 0:\n                self.stim.exit()\n            self.stim = self.stims[self.curr_cond[\"stimulus_class\"]]\n            log.debug(\"setting up stimulus\")\n            self.stim.setup()\n            log.debug(\"stimuli is done\")\n        self.curr_trial += 1\n        self.logger.update_trial_idx(self.curr_trial)\n        self.trial_start = self.logger.logger_timer.elapsed_time()\n        self.logger.log(\n            \"Trial\",\n            dict(cond_hash=self.curr_cond[\"cond_hash\"], time=self.trial_start),\n            priority=3,\n        )\n        if not self.in_operation:\n            self.in_operation = True\n\n    def name(self) -&gt; str:\n        \"\"\"Name of experiment class.\"\"\"\n        return type(self).__name__\n\n    def _make_cond_hash(\n        self,\n        conditions: List[Dict],\n        hash_field: str,\n        schema: dj.schema,\n        condition_tables: List,\n    ) -&gt; List[Dict]:\n        \"\"\"Make unique hash based on all fields from condition tables.\"\"\"\n        # get all fields from condition tables except hash\n        fields_key = {\n            key\n            for ctable in condition_tables\n            for key in self.logger.get_table_keys(schema, ctable)\n        }\n        fields_key.discard(hash_field)\n        for condition in conditions:\n            # find all dependant fields and generate hash\n            key = {k: condition[k] for k in fields_key if k in condition}\n            condition.update({hash_field: make_hash(key)})\n        return conditions\n\n    def log_conditions(\n        self,\n        conditions,\n        condition_tables=None,\n        schema=\"experiment\",\n        hash_field=\"cond_hash\",\n        priority=2,\n    ) -&gt; List[Dict]:\n        \"\"\"Log experimental conditions to specified tables with hashes tracking.\n\n        Args:\n            conditions (List): List of condition dictionaries to log\n            condition_tables (List): List of table names to log to\n            schema (db.shcema): Database schema name\n            hash_field (str): Name of the hash field\n            priority (int): for the insertion order of the logger\n\n        Returns:\n            List of processed conditions with added hashes\n\n        \"\"\"\n        if not conditions:\n            return []\n\n        if condition_tables is None:\n            condition_tables = [\"Condition\"]\n\n        conditions = self._make_cond_hash(\n            conditions, hash_field, schema, condition_tables\n        )\n\n        processed_conditions = conditions.copy()\n        for condition in processed_conditions:\n            # insert conditions fields to the correspond table\n            for ctable in condition_tables:\n                # Get table metadata\n                fields = set(self.logger.get_table_keys(schema, ctable))\n                primary_keys = set(\n                    self.logger.get_table_keys(schema, ctable, key_type=\"primary\")\n                )\n                core = [key for key in primary_keys if key != hash_field]\n\n                # Validate condition has all required fields\n                missing_keys = set(fields) - set(condition.keys())\n                if missing_keys:\n                    log.warning(f\"Skipping {ctable}, Missing keys:{missing_keys}\")\n                    continue\n\n                # check if there is a primary key which is not hash and it is iterable\n                if core and hasattr(condition[core[0]], \"__iter__\"):\n                    # TODO make a function for this and clarify it\n                    # If any of the primary keys is iterable all the rest should be.\n                    # The first element of the iterable will be matched with the first\n                    # element of the rest of the keys\n                    for idx, _ in enumerate(condition[core[0]]):\n                        cond_key = {}\n                        for k in fields:\n                            if isinstance(condition[k], (int, float, str)):\n                                cond_key[k] = condition[k]\n                            else:\n                                cond_key[k] = condition[k][idx]\n\n                        self.logger.put(\n                            table=ctable,\n                            tuple=cond_key,\n                            schema=schema,\n                            priority=priority,\n                        )\n\n                else:\n                    self.logger.put(\n                        table=ctable, tuple=condition, schema=schema, priority=priority\n                    )\n\n                # Increment the priority for each subsequent table\n                # to ensure they are inserted in the correct order\n                priority += 1\n\n        return processed_conditions\n\n    def _anti_bias(self, choice_h, un_choices):\n        choice_h = np.array(\n            [make_hash(c) for c in choice_h[-self.curr_cond[\"bias_window\"] :]]\n        )\n        if len(choice_h) &lt; self.curr_cond[\"bias_window\"]:\n            choice_h = self.choices\n        fixed_p = 1 - np.array([np.mean(choice_h == un) for un in un_choices])\n        if sum(fixed_p) == 0:\n            fixed_p = np.ones(np.shape(fixed_p))\n        return np.random.choice(un_choices, 1, p=fixed_p / sum(fixed_p))\n\n    def _get_new_cond(self) -&gt; None:\n        \"\"\"Get next condition based on trial selection method.\"\"\"\n        selection_method = self.curr_cond[\"trial_selection\"]\n        selection_handlers = {\n            \"fixed\": self._fixed_selection,\n            \"block\": self._block_selection,\n            \"random\": self._random_selection,\n            \"staircase\": self._staircase_selection,\n            \"biased\": self._biased_selection,\n        }\n\n        handler = selection_handlers.get(selection_method)\n        if handler:\n            self.curr_cond = handler()\n        else:\n            log.error(f\"Selection method '{selection_method}' not implemented!\")\n            self.quit = True\n\n    def _fixed_selection(self) -&gt; Dict:\n        \"\"\"Select next condition by popping from ordered list.\"\"\"\n        return [] if len(self.conditions) == 0 else self.conditions.pop(0)\n\n    def _block_selection(self) -&gt; Dict:\n        \"\"\"Select random condition from a block.\n\n        Select a condition from a block of conditions until all\n        conditions has been selected, then repeat them randomnly.\n        \"\"\"\n        if np.size(self.iter) == 0:\n            self.iter = np.random.permutation(np.size(self.conditions))\n        cond = self.conditions[self.iter[0]]\n        self.iter = self.iter[1:]\n        return cond\n\n    def _random_selection(self) -&gt; Dict:\n        \"\"\"Select random condition from available conditions.\"\"\"\n        return np.random.choice(self.conditions)\n\n    def _update_block_difficulty(self, perf: float) -&gt; None:\n        \"\"\"Update block difficulty based on performance.\n\n        Args:\n            perf: Current performance metric\n\n        \"\"\"\n        if self.cur_block_sz &gt;= self.curr_cond[\"staircase_window\"]:\n            if perf &gt;= self.curr_cond[\"stair_up\"]:\n                self.cur_block = self.curr_cond[\"next_up\"]\n                self.cur_block_sz = 0\n                self.logger.update_setup_info({\"difficulty\": self.cur_block})\n            elif perf &lt; self.curr_cond[\"stair_down\"]:\n                self.cur_block = self.curr_cond[\"next_down\"]\n                self.cur_block_sz = 0\n                self.logger.update_setup_info({\"difficulty\": self.cur_block})\n\n    def _get_valid_conditions(self, condition_idx: np.ndarray) -&gt; List[Dict]:\n        \"\"\"Get list of valid conditions based on condition index.\n\n        Args:\n            condition_idx: Boolean array indicating valid conditions\n\n        Returns:\n            List of valid condition dictionaries\n\n        \"\"\"\n        return [c for c, v in zip(self.conditions, condition_idx) if v]\n\n    def _staircase_selection(self) -&gt; Dict:\n        \"\"\"Select next condition using staircase method.\"\"\"\n        # Get performance metrics\n        perf, choice_h = self._get_performance()\n\n        # Update block size if there was a choice in last trial\n        if np.size(self.beh.choice_history) and self.beh.choice_history[-1:][0] &gt; 0:\n            self.cur_block_sz += 1\n\n        # Update difficulty if needed\n        self._update_block_difficulty(perf)\n\n        # Select condition based on current block and anti-bias\n        if self.curr_cond[\"antibias\"]:\n            valid_choices = self.un_choices[self.un_blocks == self.cur_block]\n            anti_bias = self._anti_bias(choice_h, valid_choices)\n            condition_idx = np.logical_and(\n                self.choices == anti_bias, self.blocks == self.cur_block\n            )\n        else:\n            condition_idx = self.blocks == self.cur_block\n\n        valid_conditions = self._get_valid_conditions(condition_idx)\n        self.block_h.append(self.cur_block)\n        return np.random.choice(valid_conditions)\n\n    def _biased_selection(self) -&gt; Dict:\n        \"\"\"Select next condition using anti-bias method.\"\"\"\n        perf, choice_h = self._get_performance()\n        anti_bias = self._anti_bias(choice_h, self.un_choices)\n        condition_idx = self.choices == anti_bias\n        valid_conditions = self._get_valid_conditions(condition_idx)\n        return np.random.choice(valid_conditions)\n\n    def add_selection_method(self, name: str, handler: Callable[[], Dict]) -&gt; None:\n        \"\"\"Add a new trial selection method.\n\n        Args:\n            name: Name of the selection method\n            handler: Function that returns next condition\n\n        Example:\n            def my_selection_method(self):\n                # Custom selection logic\n                return selected_condition\n\n            experiment.add_selection_method('custom', my_selection_method)\n\n        \"\"\"\n        if not hasattr(self, f\"_{name}_selection\"):\n            setattr(self, f\"_{name}_selection\", handler)\n            log.info(f\"Added new selection method: {name}\")\n        else:\n            log.warning(f\"Selection method '{name}' already exists\")\n\n    def _get_performance(self) -&gt; Tuple[float, List[List[int]]]:\n        \"\"\"Calculate performance metrics based on trial history.\"\"\"\n        rewards, choices, blocks = self._extract_valid_trial_data()\n\n        if not rewards.size:  # Check if there are any valid trials\n            return np.nan, []\n\n        window = self.curr_cond[\"staircase_window\"]\n        recent_rewards = rewards[-window:]\n        recent_choices = choices[-window:]\n        recent_blocks = blocks[-window:] if blocks is not None else None\n\n        performance = self._calculate_metric(\n            recent_rewards, recent_choices, recent_blocks\n        )\n\n        choice_history = self._get_choice_history(choices, blocks)\n\n        log.debug(\n            f\"\\nstaircase_window: {window},\\n\"\n            f\"rewards: {recent_rewards},\\n\"\n            f\"choices: {recent_choices},\\n\"\n            f\"blocks: {recent_blocks},\\n\"\n            f\"performace: {performance}\"\n        )\n\n        return performance, choice_history\n\n    def _extract_valid_trial_data(\n        self,\n    ) -&gt; Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n        \"\"\"Extract trials that are either punish or reward.\n\n        rewards: reward amount given at trials that have been rewarded else nan\n        choices: selected port in reward &amp; punish trials\n        blocks: block index in each trial that is reward or punish\n\n        \"\"\"\n        valid_idx = np.logical_or(\n            ~np.isnan(self.beh.reward_history), ~np.isnan(self.beh.punish_history)\n        )\n\n        rewards = np.asarray(self.beh.reward_history)[valid_idx]\n        choices = np.int64(np.asarray(self.beh.choice_history)[valid_idx])\n        blocks = np.asarray(self.block_h)[valid_idx] if self.block_h else None\n\n        return rewards, choices, blocks\n\n    def _calculate_accuracy(\n        self, rewards: np.ndarray, choices: np.ndarray, blocks: Optional[np.ndarray]\n    ) -&gt; float:\n        \"\"\"Calculate accuracy from trial data.\"\"\"\n        return np.nanmean(np.greater(rewards, 0))\n\n    def _calculate_dprime(\n        self, rewards: np.ndarray, choices: np.ndarray, blocks: Optional[np.ndarray]\n    ) -&gt; float:\n        \"\"\"Calculate d-prime from trial data.\"\"\"\n        y_true = [c if r &gt; 0 else c % 2 + 1 for (c, r) in zip(choices, rewards)]\n\n        if len(np.unique(y_true)) &gt; 1:\n            auc = roc_auc_score(y_true, choices)\n            return np.sqrt(2) * stats.norm.ppf(auc)\n\n        return np.nan\n\n    def _calculate_metric(\n        self, rewards: np.ndarray, choices: np.ndarray, blocks: Optional[np.ndarray]\n    ) -&gt; float:\n        \"\"\"Calculate performance metric specified in current condition.\"\"\"\n        metric_handlers = {\n            \"accuracy\": self._calculate_accuracy,\n            \"dprime\": self._calculate_dprime,\n        }\n\n        handler = metric_handlers.get(self.curr_cond[\"metric\"])\n        if handler:\n            return handler(rewards, choices, blocks)\n        else:\n            log.error(\n                f\"Performance metric '{self.curr_cond['metric']}' not implemented!\"\n            )\n            self.quit = True\n            return np.nan\n\n    def _get_choice_history(\n        self, choices: np.ndarray, blocks: Optional[np.ndarray]\n    ) -&gt; List[List[int]]:\n        \"\"\"Create choice history with difficulty levels.\"\"\"\n        if blocks is not None:\n            return [[c, d] for c, d in zip(choices, blocks)]\n        return [[c, 0] for c in choices]\n\n    def add_performance_metric(\n        self,\n        name: str,\n        handler: Callable[[np.ndarray, np.ndarray, Optional[np.ndarray]], float],\n    ) -&gt; None:\n        \"\"\"Add a new performance metric calculation method.\n\n        Args:\n            name: Name of the metric\n            handler: Function that takes ValidTrials and returns performance score\n\n        Example:\n            def calculate_custom_metric(trials):\n                # Custom metric calculation\n                return score\n\n            experiment.add_performance_metric('custom', calculate_custom_metric)\n\n        \"\"\"\n        if not hasattr(self, f\"{name}\"):\n            setattr(self, f\"{name}\", handler)\n            log.info(f\"Added new performance metric: {name}\")\n        else:\n            log.warning(f\"Performance metric '{name}' already exists\")\n\n    @dataclass\n    class Block:\n        \"\"\"A class representing a block of trials in an experiment.\n\n        Attributes:\n            difficulty (int): The difficulty level of the block. Default is 0.\n            stair_up (float): Threshold given to compare if performance is higher in\n                order to go to the next_up difficulty. Default is 0.7.\n            stair_down (float): Threshold given to compare if performance is smaller in\n                order to go to the next_down difficulty. Default is 0.7.\n            next_up (int): The difficulty level to go to if perf&gt;stair_up. Default is 0.\n            next_down (int): The difficulty level to go to if perf&lt;stair_down.\n                Default is 0.\n            staircase_window (int): The window size for the staircase procedure.\n                Default is 20.\n            bias_window (int): The window size for bias correction. Default is 5.\n            trial_selection (str): The method for selecting trials. Default is \"fixed\".\n            metric (str): The metric used for evaluating performance. Default is\n                \"accuracy\".\n            antibias (bool): Whether to apply antibias correction. Default is True.\n\n        Returns:\n            Dict: A dictionary containing the block parameters.\n\n        \"\"\"\n\n        difficulty: int = field(compare=True, default=0, hash=True)\n        stair_up: float = field(compare=False, default=0.7)\n        stair_down: float = field(compare=False, default=0.55)\n        next_up: int = field(compare=False, default=0)\n        next_down: int = field(compare=False, default=0)\n        staircase_window: int = field(compare=False, default=20)\n        bias_window: int = field(compare=False, default=5)\n        trial_selection: str = field(compare=False, default=\"fixed\")\n        metric: str = field(compare=False, default=\"accuracy\")\n        antibias: bool = field(compare=False, default=True)\n\n        def dict(self) -&gt; Dict:\n            \"\"\"Rerurn parameters as dictionary.\"\"\"\n            return self.__dict__\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.Block","title":"<code>Block</code>  <code>dataclass</code>","text":"<p>A class representing a block of trials in an experiment.</p> <p>Attributes:</p> Name Type Description <code>difficulty</code> <code>int</code> <p>The difficulty level of the block. Default is 0.</p> <code>stair_up</code> <code>float</code> <p>Threshold given to compare if performance is higher in order to go to the next_up difficulty. Default is 0.7.</p> <code>stair_down</code> <code>float</code> <p>Threshold given to compare if performance is smaller in order to go to the next_down difficulty. Default is 0.7.</p> <code>next_up</code> <code>int</code> <p>The difficulty level to go to if perf&gt;stair_up. Default is 0.</p> <code>next_down</code> <code>int</code> <p>The difficulty level to go to if perf&lt;stair_down. Default is 0.</p> <code>staircase_window</code> <code>int</code> <p>The window size for the staircase procedure. Default is 20.</p> <code>bias_window</code> <code>int</code> <p>The window size for bias correction. Default is 5.</p> <code>trial_selection</code> <code>str</code> <p>The method for selecting trials. Default is \"fixed\".</p> <code>metric</code> <code>str</code> <p>The metric used for evaluating performance. Default is \"accuracy\".</p> <code>antibias</code> <code>bool</code> <p>Whether to apply antibias correction. Default is True.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <p>A dictionary containing the block parameters.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>@dataclass\nclass Block:\n    \"\"\"A class representing a block of trials in an experiment.\n\n    Attributes:\n        difficulty (int): The difficulty level of the block. Default is 0.\n        stair_up (float): Threshold given to compare if performance is higher in\n            order to go to the next_up difficulty. Default is 0.7.\n        stair_down (float): Threshold given to compare if performance is smaller in\n            order to go to the next_down difficulty. Default is 0.7.\n        next_up (int): The difficulty level to go to if perf&gt;stair_up. Default is 0.\n        next_down (int): The difficulty level to go to if perf&lt;stair_down.\n            Default is 0.\n        staircase_window (int): The window size for the staircase procedure.\n            Default is 20.\n        bias_window (int): The window size for bias correction. Default is 5.\n        trial_selection (str): The method for selecting trials. Default is \"fixed\".\n        metric (str): The metric used for evaluating performance. Default is\n            \"accuracy\".\n        antibias (bool): Whether to apply antibias correction. Default is True.\n\n    Returns:\n        Dict: A dictionary containing the block parameters.\n\n    \"\"\"\n\n    difficulty: int = field(compare=True, default=0, hash=True)\n    stair_up: float = field(compare=False, default=0.7)\n    stair_down: float = field(compare=False, default=0.55)\n    next_up: int = field(compare=False, default=0)\n    next_down: int = field(compare=False, default=0)\n    staircase_window: int = field(compare=False, default=20)\n    bias_window: int = field(compare=False, default=5)\n    trial_selection: str = field(compare=False, default=\"fixed\")\n    metric: str = field(compare=False, default=\"accuracy\")\n    antibias: bool = field(compare=False, default=True)\n\n    def dict(self) -&gt; Dict:\n        \"\"\"Rerurn parameters as dictionary.\"\"\"\n        return self.__dict__\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.Block.dict","title":"<code>dict()</code>","text":"<p>Rerurn parameters as dictionary.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def dict(self) -&gt; Dict:\n    \"\"\"Rerurn parameters as dictionary.\"\"\"\n    return self.__dict__\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._biased_selection","title":"<code>_biased_selection()</code>","text":"<p>Select next condition using anti-bias method.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _biased_selection(self) -&gt; Dict:\n    \"\"\"Select next condition using anti-bias method.\"\"\"\n    perf, choice_h = self._get_performance()\n    anti_bias = self._anti_bias(choice_h, self.un_choices)\n    condition_idx = self.choices == anti_bias\n    valid_conditions = self._get_valid_conditions(condition_idx)\n    return np.random.choice(valid_conditions)\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._block_selection","title":"<code>_block_selection()</code>","text":"<p>Select random condition from a block.</p> <p>Select a condition from a block of conditions until all conditions has been selected, then repeat them randomnly.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _block_selection(self) -&gt; Dict:\n    \"\"\"Select random condition from a block.\n\n    Select a condition from a block of conditions until all\n    conditions has been selected, then repeat them randomnly.\n    \"\"\"\n    if np.size(self.iter) == 0:\n        self.iter = np.random.permutation(np.size(self.conditions))\n    cond = self.conditions[self.iter[0]]\n    self.iter = self.iter[1:]\n    return cond\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._calculate_accuracy","title":"<code>_calculate_accuracy(rewards, choices, blocks)</code>","text":"<p>Calculate accuracy from trial data.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _calculate_accuracy(\n    self, rewards: np.ndarray, choices: np.ndarray, blocks: Optional[np.ndarray]\n) -&gt; float:\n    \"\"\"Calculate accuracy from trial data.\"\"\"\n    return np.nanmean(np.greater(rewards, 0))\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._calculate_dprime","title":"<code>_calculate_dprime(rewards, choices, blocks)</code>","text":"<p>Calculate d-prime from trial data.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _calculate_dprime(\n    self, rewards: np.ndarray, choices: np.ndarray, blocks: Optional[np.ndarray]\n) -&gt; float:\n    \"\"\"Calculate d-prime from trial data.\"\"\"\n    y_true = [c if r &gt; 0 else c % 2 + 1 for (c, r) in zip(choices, rewards)]\n\n    if len(np.unique(y_true)) &gt; 1:\n        auc = roc_auc_score(y_true, choices)\n        return np.sqrt(2) * stats.norm.ppf(auc)\n\n    return np.nan\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._calculate_metric","title":"<code>_calculate_metric(rewards, choices, blocks)</code>","text":"<p>Calculate performance metric specified in current condition.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _calculate_metric(\n    self, rewards: np.ndarray, choices: np.ndarray, blocks: Optional[np.ndarray]\n) -&gt; float:\n    \"\"\"Calculate performance metric specified in current condition.\"\"\"\n    metric_handlers = {\n        \"accuracy\": self._calculate_accuracy,\n        \"dprime\": self._calculate_dprime,\n    }\n\n    handler = metric_handlers.get(self.curr_cond[\"metric\"])\n    if handler:\n        return handler(rewards, choices, blocks)\n    else:\n        log.error(\n            f\"Performance metric '{self.curr_cond['metric']}' not implemented!\"\n        )\n        self.quit = True\n        return np.nan\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._extract_valid_trial_data","title":"<code>_extract_valid_trial_data()</code>","text":"<p>Extract trials that are either punish or reward.</p> <p>rewards: reward amount given at trials that have been rewarded else nan choices: selected port in reward &amp; punish trials blocks: block index in each trial that is reward or punish</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _extract_valid_trial_data(\n    self,\n) -&gt; Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n    \"\"\"Extract trials that are either punish or reward.\n\n    rewards: reward amount given at trials that have been rewarded else nan\n    choices: selected port in reward &amp; punish trials\n    blocks: block index in each trial that is reward or punish\n\n    \"\"\"\n    valid_idx = np.logical_or(\n        ~np.isnan(self.beh.reward_history), ~np.isnan(self.beh.punish_history)\n    )\n\n    rewards = np.asarray(self.beh.reward_history)[valid_idx]\n    choices = np.int64(np.asarray(self.beh.choice_history)[valid_idx])\n    blocks = np.asarray(self.block_h)[valid_idx] if self.block_h else None\n\n    return rewards, choices, blocks\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._fixed_selection","title":"<code>_fixed_selection()</code>","text":"<p>Select next condition by popping from ordered list.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _fixed_selection(self) -&gt; Dict:\n    \"\"\"Select next condition by popping from ordered list.\"\"\"\n    return [] if len(self.conditions) == 0 else self.conditions.pop(0)\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._get_choice_history","title":"<code>_get_choice_history(choices, blocks)</code>","text":"<p>Create choice history with difficulty levels.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _get_choice_history(\n    self, choices: np.ndarray, blocks: Optional[np.ndarray]\n) -&gt; List[List[int]]:\n    \"\"\"Create choice history with difficulty levels.\"\"\"\n    if blocks is not None:\n        return [[c, d] for c, d in zip(choices, blocks)]\n    return [[c, 0] for c in choices]\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._get_new_cond","title":"<code>_get_new_cond()</code>","text":"<p>Get next condition based on trial selection method.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _get_new_cond(self) -&gt; None:\n    \"\"\"Get next condition based on trial selection method.\"\"\"\n    selection_method = self.curr_cond[\"trial_selection\"]\n    selection_handlers = {\n        \"fixed\": self._fixed_selection,\n        \"block\": self._block_selection,\n        \"random\": self._random_selection,\n        \"staircase\": self._staircase_selection,\n        \"biased\": self._biased_selection,\n    }\n\n    handler = selection_handlers.get(selection_method)\n    if handler:\n        self.curr_cond = handler()\n    else:\n        log.error(f\"Selection method '{selection_method}' not implemented!\")\n        self.quit = True\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._get_performance","title":"<code>_get_performance()</code>","text":"<p>Calculate performance metrics based on trial history.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _get_performance(self) -&gt; Tuple[float, List[List[int]]]:\n    \"\"\"Calculate performance metrics based on trial history.\"\"\"\n    rewards, choices, blocks = self._extract_valid_trial_data()\n\n    if not rewards.size:  # Check if there are any valid trials\n        return np.nan, []\n\n    window = self.curr_cond[\"staircase_window\"]\n    recent_rewards = rewards[-window:]\n    recent_choices = choices[-window:]\n    recent_blocks = blocks[-window:] if blocks is not None else None\n\n    performance = self._calculate_metric(\n        recent_rewards, recent_choices, recent_blocks\n    )\n\n    choice_history = self._get_choice_history(choices, blocks)\n\n    log.debug(\n        f\"\\nstaircase_window: {window},\\n\"\n        f\"rewards: {recent_rewards},\\n\"\n        f\"choices: {recent_choices},\\n\"\n        f\"blocks: {recent_blocks},\\n\"\n        f\"performace: {performance}\"\n    )\n\n    return performance, choice_history\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._get_valid_conditions","title":"<code>_get_valid_conditions(condition_idx)</code>","text":"<p>Get list of valid conditions based on condition index.</p> <p>Parameters:</p> Name Type Description Default <code>condition_idx</code> <code>ndarray</code> <p>Boolean array indicating valid conditions</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of valid condition dictionaries</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _get_valid_conditions(self, condition_idx: np.ndarray) -&gt; List[Dict]:\n    \"\"\"Get list of valid conditions based on condition index.\n\n    Args:\n        condition_idx: Boolean array indicating valid conditions\n\n    Returns:\n        List of valid condition dictionaries\n\n    \"\"\"\n    return [c for c, v in zip(self.conditions, condition_idx) if v]\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._handle_unused_parameters","title":"<code>_handle_unused_parameters(conditions, used_keys)</code>","text":"<p>Process any unused parameters.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _handle_unused_parameters(self, conditions, used_keys) -&gt; Union[List, None]:\n    \"\"\"Process any unused parameters.\"\"\"\n    unused_keys = set(conditions.keys()) - used_keys\n    if unused_keys:\n        log.warning(\n            f\"Keys: {unused_keys} are in condition but are not used from \"\n            f\"Experiment, Behavior or Stimulus\"\n        )\n        unused_dict = self.get_keys_from_dict(conditions, unused_keys)\n        return factorize(unused_dict)\n    return None\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._make_cond_hash","title":"<code>_make_cond_hash(conditions, hash_field, schema, condition_tables)</code>","text":"<p>Make unique hash based on all fields from condition tables.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _make_cond_hash(\n    self,\n    conditions: List[Dict],\n    hash_field: str,\n    schema: dj.schema,\n    condition_tables: List,\n) -&gt; List[Dict]:\n    \"\"\"Make unique hash based on all fields from condition tables.\"\"\"\n    # get all fields from condition tables except hash\n    fields_key = {\n        key\n        for ctable in condition_tables\n        for key in self.logger.get_table_keys(schema, ctable)\n    }\n    fields_key.discard(hash_field)\n    for condition in conditions:\n        # find all dependant fields and generate hash\n        key = {k: condition[k] for k in fields_key if k in condition}\n        condition.update({hash_field: make_hash(key)})\n    return conditions\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._process_behavior_conditions","title":"<code>_process_behavior_conditions(conditions)</code>","text":"<p>Process behavior-related conditions.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _process_behavior_conditions(self, conditions: Dict) -&gt; Tuple[List, List]:\n    \"\"\"Process behavior-related conditions.\"\"\"\n    beh_dict = self.get_keys_from_dict(conditions, get_parameters(self.beh).keys())\n    log.debug(\n        f\"Behavior use default conditions:\\n\"\n        f\"{get_parameters(self.beh).keys() - beh_dict.keys()}\"\n    )\n    beh_conditions = factorize(beh_dict)\n    beh_conditions = self.beh.make_conditions(beh_conditions)\n    for i, beh_condition in enumerate(beh_conditions):\n        log.debug(f\"Behavior condition {i}:\\n{format_params_print(beh_condition)}\")\n    return beh_conditions, beh_dict.keys()\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._process_experiment_conditions","title":"<code>_process_experiment_conditions(task_classes, conditions)</code>","text":"<p>Process experiment-wide conditions.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _process_experiment_conditions(\n    self, task_classes: List, conditions: Dict\n) -&gt; Tuple[List, list]:\n    \"\"\"Process experiment-wide conditions.\"\"\"\n    exp_dict = self.get_keys_from_dict(conditions, get_parameters(self).keys())\n    exp_dict.update(task_classes)\n    log.debug(\n        f\"Experiment use default conditions:\\n\"\n        f\"{get_parameters(self).keys() - exp_dict.keys()}\"\n    )\n    exp_conditions = factorize(exp_dict)\n\n    for cond in exp_conditions:\n        self.validate_condition(cond)\n        cond.update({**self.default_key, **self.params, **cond})\n    cond_tables = [\"Condition.\" + table for table in self.cond_tables]\n    conditions_list = self.log_conditions(\n        exp_conditions, condition_tables=[\"Condition\"] + cond_tables\n    )\n    for i, exp_condition in enumerate(exp_conditions):\n        log.debug(\n            f\"Experiment condition {i}:\\n{format_params_print(exp_condition)}\"\n        )\n    return conditions_list, exp_dict.keys()\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._process_stim_conditions","title":"<code>_process_stim_conditions(stim_class, conditions, stim_periods)</code>","text":"<p>Process stimulus-specific conditions.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _process_stim_conditions(\n    self, stim_class, conditions: Dict, stim_periods: List\n) -&gt; Tuple[List, List]:\n    \"\"\"Process stimulus-specific conditions.\"\"\"\n    if stim_periods:\n        period_conditions = {}\n        for period in stim_periods:\n            stim_dict = self.get_keys_from_dict(\n                conditions[period], get_parameters(stim_class).keys()\n            )\n            log.debug(\n                f\"Stimulus period: {period} use default conditions:\"\n                f\"\\n{get_parameters(stim_class).keys() - stim_dict.keys()}\"\n            )\n            period_conditions[period] = factorize(stim_dict)\n            period_conditions[period] = self.stims[\n                stim_class.name()\n            ].make_conditions(period_conditions[period])\n            for i, stim_condition in enumerate(period_conditions[period]):\n                log.debug(\n                    f\"Stimulus condition {i}:\\n\"\n                    f\"{format_params_print(stim_condition)}\"\n                )\n        stim_conditions = factorize(period_conditions)\n        return stim_conditions, stim_periods\n\n    stim_dict = self.get_keys_from_dict(\n        conditions, get_parameters(stim_class).keys()\n    )\n    log.debug(\n        f\"Stimulus use default conditions:\\n\"\n        f\"{get_parameters(stim_class).keys() - stim_dict.keys()}\"\n    )\n    stim_conditions = factorize(stim_dict)\n    stim_conditions = self.stims[stim_class.name()].make_conditions(stim_conditions)\n    for i, stim_condition in enumerate(stim_conditions):\n        log.debug(f\"Stimulus condition {i}:\\n{format_params_print(stim_condition)}\")\n    return stim_conditions, stim_dict.keys()\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._random_selection","title":"<code>_random_selection()</code>","text":"<p>Select random condition from available conditions.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _random_selection(self) -&gt; Dict:\n    \"\"\"Select random condition from available conditions.\"\"\"\n    return np.random.choice(self.conditions)\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._staircase_selection","title":"<code>_staircase_selection()</code>","text":"<p>Select next condition using staircase method.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _staircase_selection(self) -&gt; Dict:\n    \"\"\"Select next condition using staircase method.\"\"\"\n    # Get performance metrics\n    perf, choice_h = self._get_performance()\n\n    # Update block size if there was a choice in last trial\n    if np.size(self.beh.choice_history) and self.beh.choice_history[-1:][0] &gt; 0:\n        self.cur_block_sz += 1\n\n    # Update difficulty if needed\n    self._update_block_difficulty(perf)\n\n    # Select condition based on current block and anti-bias\n    if self.curr_cond[\"antibias\"]:\n        valid_choices = self.un_choices[self.un_blocks == self.cur_block]\n        anti_bias = self._anti_bias(choice_h, valid_choices)\n        condition_idx = np.logical_and(\n            self.choices == anti_bias, self.blocks == self.cur_block\n        )\n    else:\n        condition_idx = self.blocks == self.cur_block\n\n    valid_conditions = self._get_valid_conditions(condition_idx)\n    self.block_h.append(self.cur_block)\n    return np.random.choice(valid_conditions)\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass._update_block_difficulty","title":"<code>_update_block_difficulty(perf)</code>","text":"<p>Update block difficulty based on performance.</p> <p>Parameters:</p> Name Type Description Default <code>perf</code> <code>float</code> <p>Current performance metric</p> required Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def _update_block_difficulty(self, perf: float) -&gt; None:\n    \"\"\"Update block difficulty based on performance.\n\n    Args:\n        perf: Current performance metric\n\n    \"\"\"\n    if self.cur_block_sz &gt;= self.curr_cond[\"staircase_window\"]:\n        if perf &gt;= self.curr_cond[\"stair_up\"]:\n            self.cur_block = self.curr_cond[\"next_up\"]\n            self.cur_block_sz = 0\n            self.logger.update_setup_info({\"difficulty\": self.cur_block})\n        elif perf &lt; self.curr_cond[\"stair_down\"]:\n            self.cur_block = self.curr_cond[\"next_down\"]\n            self.cur_block_sz = 0\n            self.logger.update_setup_info({\"difficulty\": self.cur_block})\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.add_performance_metric","title":"<code>add_performance_metric(name, handler)</code>","text":"<p>Add a new performance metric calculation method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the metric</p> required <code>handler</code> <code>Callable[[ndarray, ndarray, Optional[ndarray]], float]</code> <p>Function that takes ValidTrials and returns performance score</p> required Example <p>def calculate_custom_metric(trials):     # Custom metric calculation     return score</p> <p>experiment.add_performance_metric('custom', calculate_custom_metric)</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def add_performance_metric(\n    self,\n    name: str,\n    handler: Callable[[np.ndarray, np.ndarray, Optional[np.ndarray]], float],\n) -&gt; None:\n    \"\"\"Add a new performance metric calculation method.\n\n    Args:\n        name: Name of the metric\n        handler: Function that takes ValidTrials and returns performance score\n\n    Example:\n        def calculate_custom_metric(trials):\n            # Custom metric calculation\n            return score\n\n        experiment.add_performance_metric('custom', calculate_custom_metric)\n\n    \"\"\"\n    if not hasattr(self, f\"{name}\"):\n        setattr(self, f\"{name}\", handler)\n        log.info(f\"Added new performance metric: {name}\")\n    else:\n        log.warning(f\"Performance metric '{name}' already exists\")\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.add_selection_method","title":"<code>add_selection_method(name, handler)</code>","text":"<p>Add a new trial selection method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the selection method</p> required <code>handler</code> <code>Callable[[], Dict]</code> <p>Function that returns next condition</p> required Example <p>def my_selection_method(self):     # Custom selection logic     return selected_condition</p> <p>experiment.add_selection_method('custom', my_selection_method)</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def add_selection_method(self, name: str, handler: Callable[[], Dict]) -&gt; None:\n    \"\"\"Add a new trial selection method.\n\n    Args:\n        name: Name of the selection method\n        handler: Function that returns next condition\n\n    Example:\n        def my_selection_method(self):\n            # Custom selection logic\n            return selected_condition\n\n        experiment.add_selection_method('custom', my_selection_method)\n\n    \"\"\"\n    if not hasattr(self, f\"_{name}_selection\"):\n        setattr(self, f\"_{name}_selection\", handler)\n        log.info(f\"Added new selection method: {name}\")\n    else:\n        log.warning(f\"Selection method '{name}' already exists\")\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.get_keys_from_dict","title":"<code>get_keys_from_dict(data, keys)</code>","text":"<p>Efficiently extract specific keys from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The input dictionary.</p> required <code>keys</code> <code>list</code> <p>The list of keys to extract.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict</code> <p>A new dictionary with only the specified keys if they exist.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def get_keys_from_dict(self, data: Dict, keys: List) -&gt; Dict:\n    \"\"\"Efficiently extract specific keys from a dictionary.\n\n    Args:\n        data (dict): The input dictionary.\n        keys (list): The list of keys to extract.\n\n    Returns:\n        dict: A new dictionary with only the specified keys if they exist.\n\n    \"\"\"\n    keys_set = set(keys)  # Convert list to set for O(1) lookup\n    return {key: data[key] for key in keys_set.intersection(data)}\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.is_stopped","title":"<code>is_stopped()</code>","text":"<p>Check is experiment should stop.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def is_stopped(self) -&gt; None:\n    \"\"\"Check is experiment should stop.\"\"\"\n    self.quit = self.quit or self.logger.setup_status in [\"stop\", \"exit\"]\n    if self.quit and self.logger.setup_status not in [\"stop\", \"exit\"]:\n        self.logger.update_setup_info({\"status\": \"stop\"})\n    if self.quit:\n        self.in_operation = False\n    return self.quit\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.log_conditions","title":"<code>log_conditions(conditions, condition_tables=None, schema='experiment', hash_field='cond_hash', priority=2)</code>","text":"<p>Log experimental conditions to specified tables with hashes tracking.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>List</code> <p>List of condition dictionaries to log</p> required <code>condition_tables</code> <code>List</code> <p>List of table names to log to</p> <code>None</code> <code>schema</code> <code>shcema</code> <p>Database schema name</p> <code>'experiment'</code> <code>hash_field</code> <code>str</code> <p>Name of the hash field</p> <code>'cond_hash'</code> <code>priority</code> <code>int</code> <p>for the insertion order of the logger</p> <code>2</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>List of processed conditions with added hashes</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def log_conditions(\n    self,\n    conditions,\n    condition_tables=None,\n    schema=\"experiment\",\n    hash_field=\"cond_hash\",\n    priority=2,\n) -&gt; List[Dict]:\n    \"\"\"Log experimental conditions to specified tables with hashes tracking.\n\n    Args:\n        conditions (List): List of condition dictionaries to log\n        condition_tables (List): List of table names to log to\n        schema (db.shcema): Database schema name\n        hash_field (str): Name of the hash field\n        priority (int): for the insertion order of the logger\n\n    Returns:\n        List of processed conditions with added hashes\n\n    \"\"\"\n    if not conditions:\n        return []\n\n    if condition_tables is None:\n        condition_tables = [\"Condition\"]\n\n    conditions = self._make_cond_hash(\n        conditions, hash_field, schema, condition_tables\n    )\n\n    processed_conditions = conditions.copy()\n    for condition in processed_conditions:\n        # insert conditions fields to the correspond table\n        for ctable in condition_tables:\n            # Get table metadata\n            fields = set(self.logger.get_table_keys(schema, ctable))\n            primary_keys = set(\n                self.logger.get_table_keys(schema, ctable, key_type=\"primary\")\n            )\n            core = [key for key in primary_keys if key != hash_field]\n\n            # Validate condition has all required fields\n            missing_keys = set(fields) - set(condition.keys())\n            if missing_keys:\n                log.warning(f\"Skipping {ctable}, Missing keys:{missing_keys}\")\n                continue\n\n            # check if there is a primary key which is not hash and it is iterable\n            if core and hasattr(condition[core[0]], \"__iter__\"):\n                # TODO make a function for this and clarify it\n                # If any of the primary keys is iterable all the rest should be.\n                # The first element of the iterable will be matched with the first\n                # element of the rest of the keys\n                for idx, _ in enumerate(condition[core[0]]):\n                    cond_key = {}\n                    for k in fields:\n                        if isinstance(condition[k], (int, float, str)):\n                            cond_key[k] = condition[k]\n                        else:\n                            cond_key[k] = condition[k][idx]\n\n                    self.logger.put(\n                        table=ctable,\n                        tuple=cond_key,\n                        schema=schema,\n                        priority=priority,\n                    )\n\n            else:\n                self.logger.put(\n                    table=ctable, tuple=condition, schema=schema, priority=priority\n                )\n\n            # Increment the priority for each subsequent table\n            # to ensure they are inserted in the correct order\n            priority += 1\n\n    return processed_conditions\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.make_conditions","title":"<code>make_conditions(stim_class, conditions, stim_periods=None)</code>","text":"<p>Create conditions by combining stimulus, behavior, and experiment.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def make_conditions(\n    self,\n    stim_class,\n    conditions: Dict[str, Any],\n    stim_periods: List[str] = None,\n) -&gt; List[Dict]:\n    \"\"\"Create conditions by combining stimulus, behavior, and experiment.\"\"\"\n    log.debug(\"-------------- Make conditions --------------\")\n    self.stims = self._stim_init(stim_class, self.stims)\n    used_keys = set()  # all the keys used from dictionary conditions\n\n    # Handle stimulus conditions\n    stim_conditions, stim_keys = self._process_stim_conditions(\n        stim_class, conditions, stim_periods\n    )\n    used_keys.update(stim_keys)\n\n    # Process behavior conditions\n    beh_conditions, beh_keys = self._process_behavior_conditions(conditions)\n    used_keys.update(beh_keys)\n\n    # Process experiment conditions\n    exp_conditions, exp_keys = self._process_experiment_conditions(\n        self._get_task_classes(stim_class), conditions\n    )\n    used_keys.update(exp_keys)\n\n    # Combine results and handle unused parameters\n    partial_results = [exp_conditions, beh_conditions, stim_conditions]\n    unused_conditions = self._handle_unused_parameters(conditions, used_keys)\n    if unused_conditions:\n        partial_results.append(unused_conditions)\n    log.debug(\"-----------------------------------------------\")\n    return [\n        {k: v for d in comb for k, v in d.items()}\n        for comb in product(*partial_results)\n    ]\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.name","title":"<code>name()</code>","text":"<p>Name of experiment class.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"Name of experiment class.\"\"\"\n    return type(self).__name__\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.prepare_trial","title":"<code>prepare_trial()</code>","text":"<p>Prepare trial conditions, stimuli and update trial index.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def prepare_trial(self) -&gt; None:\n    \"\"\"Prepare trial conditions, stimuli and update trial index.\"\"\"\n    old_cond = self.curr_cond\n    self._get_new_cond()\n\n    if not self.curr_cond or self.logger.thread_end.is_set():\n        self.quit = True\n        return\n    if (\n        \"stimulus_class\" not in old_cond\n        or self.curr_trial == 0\n        or old_cond[\"stimulus_class\"] != self.curr_cond[\"stimulus_class\"]\n    ):\n        if \"stimulus_class\" in old_cond and self.curr_trial != 0:\n            self.stim.exit()\n        self.stim = self.stims[self.curr_cond[\"stimulus_class\"]]\n        log.debug(\"setting up stimulus\")\n        self.stim.setup()\n        log.debug(\"stimuli is done\")\n    self.curr_trial += 1\n    self.logger.update_trial_idx(self.curr_trial)\n    self.trial_start = self.logger.logger_timer.elapsed_time()\n    self.logger.log(\n        \"Trial\",\n        dict(cond_hash=self.curr_cond[\"cond_hash\"], time=self.trial_start),\n        priority=3,\n    )\n    if not self.in_operation:\n        self.in_operation = True\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.push_conditions","title":"<code>push_conditions(conditions)</code>","text":"<p>Set the experimental conditions and initializes related data structures.</p> <p>This method takes a list of condition dictionaries, prepares data structures for tracking choices, blocks, and the current condition.  It also determines unique choice hashes based on the response condition and difficulty.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>List</code> <p>A list of dictionaries, where each dictionary represents an experimental condition.  Each condition dictionary is expected to contain at least a \"difficulty\" key.  If a <code>resp_cond</code> key (or the default \"response_port\") is present, it's used to create unique choice hashes.</p> required Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def push_conditions(self, conditions: List) -&gt; None:\n    \"\"\"Set the experimental conditions and initializes related data structures.\n\n    This method takes a list of condition dictionaries, prepares data structures\n    for tracking choices, blocks, and the current condition.  It also determines\n    unique choice hashes based on the response condition and difficulty.\n\n    Args:\n        conditions: A list of dictionaries, where each dictionary\n            represents an experimental condition.  Each condition\n            dictionary is expected to contain at least a \"difficulty\"\n            key.  If a `resp_cond` key (or the default \"response_port\")\n            is present, it's used to create unique choice hashes.\n\n    \"\"\"\n    log.info(f\"Number of conditions: {len(conditions)}\")\n    self.conditions = conditions\n    resp_cond = (\n        self.params[\"resp_cond\"] if \"resp_cond\" in self.params else \"response_port\"\n    )\n    self.blocks = np.array([cond[\"difficulty\"] for cond in self.conditions])\n    if np.all([resp_cond in cond for cond in conditions]):\n        self.choices = np.array(\n            [make_hash([d[resp_cond], d[\"difficulty\"]]) for d in conditions]\n        )\n        self.un_choices, un_idx = np.unique(self.choices, axis=0, return_index=True)\n        self.un_blocks = self.blocks[un_idx]\n    #  select random condition for first trial initialization\n    self.cur_block = min(self.blocks)\n    self.curr_cond = np.random.choice(\n        [i for (i, v) in zip(self.conditions, self.blocks == self.cur_block) if v]\n    )\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.setup","title":"<code>setup(logger, behavior_class, session_params)</code>","text":"<p>Set up Experiment.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def setup(self, logger: Logger, behavior_class, session_params: Dict) -&gt; None:\n    \"\"\"Set up Experiment.\"\"\"\n    self.in_operation = False\n    self.conditions = []\n    self.iter = []\n    self.quit = False\n    self.curr_cond = {}\n    self.block_h = []\n    self.stims = dict()\n    self.curr_trial = 0\n    self.cur_block_sz = 0\n    self.setup_conf_idx = session_params.get(\"setup_conf_idx\", 0)\n    session_params[\"setup_conf_idx\"] = self.setup_conf_idx\n\n    self.params = {**self.default_key, **session_params, \"setup_conf_idx\": self.setup_conf_idx}\n\n    self.logger = logger\n    self.beh = behavior_class()\n    self.interface = self._interface_setup(\n        self.beh, self.logger, self.setup_conf_idx\n    )\n    self.interface.load_calibration()\n    self.beh.setup(self)\n\n    self.logger.log_session(\n        session_params, experiment_type=self.cond_tables[0], log_task=True\n    )\n\n    self.session_timer = Timer()\n\n    np.random.seed(0)  # fix random seed, it can be overidden in the task file\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.start","title":"<code>start()</code>","text":"<p>Start the StateMachine.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start the StateMachine.\"\"\"\n    states = dict()\n    for state in self.__class__.__subclasses__():  # Initialize states\n        states.update({state().__class__.__name__: state(self)})\n    state_control = StateMachine(states)\n    self.interface.set_operation_status(True)\n    state_control.run()\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.stop","title":"<code>stop()</code>","text":"<p>Stop the epxeriment.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the epxeriment.\"\"\"\n    self.stim.exit()\n    self.interface.release()\n    self.beh.exit()\n    if self.sync:\n        while self.interface.is_recording():\n            log.info(\"Waiting for recording to end...\")\n            time.sleep(1)\n    self.logger.closeDatasets()\n    self.in_operation = False\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.ExperimentClass.validate_condition","title":"<code>validate_condition(condition)</code>","text":"<p>Validate a condition dictionary against the required fields.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Dict</code> <p>The condition dictionary to validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If required fields are missing from the condition.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def validate_condition(self, condition: Dict) -&gt; None:\n    \"\"\"Validate a condition dictionary against the required fields.\n\n    Args:\n        condition (Dict): The condition dictionary to validate.\n\n    Raises:\n        ValueError: If required fields are missing from the condition.\n\n    \"\"\"\n    missing_fields = set(self.required_fields) - set(condition)\n    if missing_fields:\n        raise ValueError(f\"Missing experiment required fields: {missing_fields}\")\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.State","title":"<code>State</code>","text":"<p>Base class for implementing experiment states.</p> <p>This class provides the template for creating states in the experiment state machine. Each state should inherit from this class and implement the required methods.</p> <p>Attributes:</p> Name Type Description <code>state_timer</code> <code>Timer</code> <p>Timer instance shared across all states</p> <code>__shared_state</code> <code>Dict[str, Any]</code> <p>Dictionary containing shared state variables</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>class State:\n    \"\"\"Base class for implementing experiment states.\n\n    This class provides the template for creating states in the experiment state\n    machine. Each state should inherit from this class and implement the required\n    methods.\n\n    Attributes:\n        state_timer: Timer instance shared across all states\n        __shared_state: Dictionary containing shared state variables\n\n    \"\"\"\n\n    state_timer: Timer = Timer()\n    __shared_state: Dict[str, Any] = {}\n\n    def __init__(self, parent: Optional[\"ExperimentClass\"] = None) -&gt; None:\n        \"\"\"Initialize state with optional parent experiment.\n\n        Args:\n            parent: Parent experiment instance this state belongs to\n\n        \"\"\"\n        self.__dict__ = self.__shared_state\n        if parent:\n            self.__dict__.update(parent.__dict__)\n\n    def entry(self) -&gt; None:\n        \"\"\"Execute actions when entering this state.\"\"\"\n\n    def run(self) -&gt; None:\n        \"\"\"Execute the main state logic.\"\"\"\n\n    def next(self) -&gt; str:\n        \"\"\"Determine the next state to transition to.\n\n        Returns:\n            Name of the next state to transition to\n\n        Raises:\n            AssertionError: If next() is not implemented by child class\n\n        \"\"\"\n        raise AssertionError(\"next not implemented\")\n\n    def exit(self) -&gt; None:\n        \"\"\"Execute actions when exiting this state.\"\"\"\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.State.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Initialize state with optional parent experiment.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>Optional[ExperimentClass]</code> <p>Parent experiment instance this state belongs to</p> <code>None</code> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def __init__(self, parent: Optional[\"ExperimentClass\"] = None) -&gt; None:\n    \"\"\"Initialize state with optional parent experiment.\n\n    Args:\n        parent: Parent experiment instance this state belongs to\n\n    \"\"\"\n    self.__dict__ = self.__shared_state\n    if parent:\n        self.__dict__.update(parent.__dict__)\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.State.entry","title":"<code>entry()</code>","text":"<p>Execute actions when entering this state.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def entry(self) -&gt; None:\n    \"\"\"Execute actions when entering this state.\"\"\"\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.State.exit","title":"<code>exit()</code>","text":"<p>Execute actions when exiting this state.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Execute actions when exiting this state.\"\"\"\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.State.next","title":"<code>next()</code>","text":"<p>Determine the next state to transition to.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the next state to transition to</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If next() is not implemented by child class</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def next(self) -&gt; str:\n    \"\"\"Determine the next state to transition to.\n\n    Returns:\n        Name of the next state to transition to\n\n    Raises:\n        AssertionError: If next() is not implemented by child class\n\n    \"\"\"\n    raise AssertionError(\"next not implemented\")\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.State.run","title":"<code>run()</code>","text":"<p>Execute the main state logic.</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Execute the main state logic.\"\"\"\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.StateMachine","title":"<code>StateMachine</code>","text":"<p>State machine implementation for experiment control flow.</p> <p>Manages transitions between experiment states and ensures proper execution of state entry/exit hooks. The state machine runs until it reaches the exit state.</p> <p>Attributes:</p> Name Type Description <code>states</code> <code>Dict[str, State]</code> <p>Mapping of state names to state instances</p> <code>futureState</code> <code>State</code> <p>Next state to transition to</p> <code>currentState</code> <code>State</code> <p>Currently executing state</p> <code>exitState</code> <code>State</code> <p>Final state that ends the state machine</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>class StateMachine:\n    \"\"\"State machine implementation for experiment control flow.\n\n    Manages transitions between experiment states and ensures proper execution\n    of state entry/exit hooks. The state machine runs until it reaches the exit\n    state.\n\n    Attributes:\n        states (Dict[str, State]): Mapping of state names to state instances\n        futureState (State): Next state to transition to\n        currentState (State): Currently executing state\n        exitState (State): Final state that ends the state machine\n\n    \"\"\"\n\n    def __init__(self, states: Dict[str, State]) -&gt; None:\n        \"\"\"Initialize the state machine.\n\n        Args:\n            states: Dictionary mapping state names to state instances\n\n        Raises:\n            ValueError: If required states (Entry, Exit) are missing\n\n        \"\"\"\n        if \"Entry\" not in states or \"Exit\" not in states:\n            raise ValueError(\"StateMachine requires Entry and Exit states\")\n\n        self.states = states\n        self.futureState = states[\"Entry\"]\n        self.currentState = states[\"Entry\"]\n        self.exitState = states[\"Exit\"]\n\n    # # # # Main state loop # # # # #\n    def run(self) -&gt; None:\n        \"\"\"Execute the state machine until reaching exit state.\n\n        The machine will:\n        1. Check for state transition\n        2. Execute exit hook of current state if transitioning\n        3. Execute entry hook of new state if transitioning\n        4. Execute the current state's main logic\n        5. Determine next state\n\n        Raises:\n            KeyError: If a state requests transition to non-existent state\n            RuntimeError: If a state's next() method raises an exception\n\n        \"\"\"\n        try:\n            while self.futureState != self.exitState:\n                if self.currentState != self.futureState:\n                    self.currentState.exit()\n                    self.currentState = self.futureState\n                    self.currentState.entry()\n\n                self.currentState.run()\n\n                next_state = self.currentState.next()\n                if next_state not in self.states:\n                    raise KeyError(f\"Invalid state transition to: {next_state}\")\n\n                self.futureState = self.states[next_state]\n\n            self.currentState.exit()\n            self.exitState.run()\n\n        except Exception as e:\n            raise RuntimeError(\n                f\"\"\"State machine error in state\n                    {self.currentState.__class__.__name__}: {str(e)}\"\"\"\n            ) from e\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.StateMachine.__init__","title":"<code>__init__(states)</code>","text":"<p>Initialize the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>Dict[str, State]</code> <p>Dictionary mapping state names to state instances</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If required states (Entry, Exit) are missing</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def __init__(self, states: Dict[str, State]) -&gt; None:\n    \"\"\"Initialize the state machine.\n\n    Args:\n        states: Dictionary mapping state names to state instances\n\n    Raises:\n        ValueError: If required states (Entry, Exit) are missing\n\n    \"\"\"\n    if \"Entry\" not in states or \"Exit\" not in states:\n        raise ValueError(\"StateMachine requires Entry and Exit states\")\n\n    self.states = states\n    self.futureState = states[\"Entry\"]\n    self.currentState = states[\"Entry\"]\n    self.exitState = states[\"Exit\"]\n</code></pre>"},{"location":"experiment/#ethopy.core.experiment.StateMachine.run","title":"<code>run()</code>","text":"<p>Execute the state machine until reaching exit state.</p> <p>The machine will: 1. Check for state transition 2. Execute exit hook of current state if transitioning 3. Execute entry hook of new state if transitioning 4. Execute the current state's main logic 5. Determine next state</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a state requests transition to non-existent state</p> <code>RuntimeError</code> <p>If a state's next() method raises an exception</p> Source code in <code>src/ethopy/core/experiment.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Execute the state machine until reaching exit state.\n\n    The machine will:\n    1. Check for state transition\n    2. Execute exit hook of current state if transitioning\n    3. Execute entry hook of new state if transitioning\n    4. Execute the current state's main logic\n    5. Determine next state\n\n    Raises:\n        KeyError: If a state requests transition to non-existent state\n        RuntimeError: If a state's next() method raises an exception\n\n    \"\"\"\n    try:\n        while self.futureState != self.exitState:\n            if self.currentState != self.futureState:\n                self.currentState.exit()\n                self.currentState = self.futureState\n                self.currentState.entry()\n\n            self.currentState.run()\n\n            next_state = self.currentState.next()\n            if next_state not in self.states:\n                raise KeyError(f\"Invalid state transition to: {next_state}\")\n\n            self.futureState = self.states[next_state]\n\n        self.currentState.exit()\n        self.exitState.run()\n\n    except Exception as e:\n        raise RuntimeError(\n            f\"\"\"State machine error in state\n                {self.currentState.__class__.__name__}: {str(e)}\"\"\"\n        ) from e\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"getting_started/","title":"Getting Started with EthoPy","text":"<p>This guide will walk you through the process of setting up and running your first experiment with EthoPy. After completing this guide, you'll have a solid understanding of how to configure and run basic behavioral experiments.</p>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.8 or higher (but less than 3.12) installed</li> <li>Docker (for new database setup)</li> </ul>"},{"location":"getting_started/#installation","title":"Installation","text":"<ol> <li>Install EthoPy package:</li> </ol> <p>For the basic installation with core functionality:</p> <pre><code>pip install ethopy\n</code></pre> <p>From source (latest development version):</p> <pre><code>pip install git+https://github.com/ef-lab/ethopy_package\n</code></pre> <p>For development installation:</p> <pre><code>git clone https://github.com/ef-lab/ethopy_package.git\ncd ethopy_package\npip install -e \".[dev,docs]\"\n</code></pre> <ol> <li>Verify installation:</li> </ol> <pre><code>ethopy --version\n</code></pre>"},{"location":"getting_started/#database-setup","title":"Database Setup","text":"<p>EthoPy relies on a database for experiment configuration and data logging. If there is not a database availabe, here is a quick setup of setting mysql database with docker:</p> <ol> <li>Start the database container:</li> </ol> <p><pre><code>ethopy-setup-djdocker\n</code></pre>    alterative follow the instruction from datajoint here</p> <p>The default username is \"root\".</p> <p>Note: ethopy-setup-djdocker works only in unix operating systems, for windows try to setup the docker image based on the datajoint instructions</p> <p>Note: By default, Docker requires sudo because the Docker daemon runs as root. This command adds your user to the docker group, so you can run Docker commands without sudo.</p> <pre><code>sudo usermod -aG docker $USER\n</code></pre> <p>restart your session (log out and back in) or run: <pre><code>newgrp docker\n</code></pre> </p> <ol> <li>Configure the database connection:</li> </ol> <p>Create a configuration file at:    - Linux/macOS: <code>~/.ethopy/local_conf.json</code>    - Windows: <code>%USERPROFILE%\\.ethopy\\local_conf.json</code></p> <pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"127.0.0.1\",\n        \"database.user\": \"root\",\n        \"database.password\": \"your_password\",\n        \"database.port\": 3306\n    },\n  \"SCHEMATA\": {\n    \"experiment\": \"lab_experiments\",\n    \"stimulus\": \"lab_stimuli\",\n    \"behavior\": \"lab_behavior\",\n    \"recording\": \"lab_recordings\",\n  }\n}\n</code></pre> <ol> <li>Verify database connection:</li> </ol> <pre><code>ethopy-db-connection\n</code></pre> <ol> <li>Create required schemas:</li> </ol> <pre><code>ethopy-setup-schema\n</code></pre> <p>Tip</p> <p>For verifing the schema/tables creation you can download DBeaver which is a popular and versatile database tool.</p>"},{"location":"getting_started/#run-your-first-experiment","title":"Run your first experiment","text":"<p><pre><code>ethopy --task-path grating_test.py --log-console\n</code></pre> The option --task-path is for defining the path of the task. The example tasks can run by the file name, for any other experiment you must define the full path. Option --log-console is to enable the logging in terminal.</p> <p>You can check all the options of ethopy by: <pre><code>ethopy --help\n</code></pre></p>"},{"location":"getting_started/#example-tasks","title":"Example Tasks","text":"<p>Explore these sample tasks in the <code>ethopy/task/</code> directory:</p> <ol> <li>calibrate_ports.py - Calibrate water delivery ports</li> <li>free_water.py - Reward delivery without complex stimuli</li> <li>no_stimulus.py - Run experiment without visual stimuli</li> <li>grating_test.py - Grating stimulus presentation</li> <li>bar_test.py - Moving bar stimulus</li> <li>dot_test.py - Moving dot patterns</li> </ol>"},{"location":"getting_started/#troubleshooting-and-help","title":"Troubleshooting and Help","text":"<p>If you encounter issues, refer to the Troubleshooting Guide.</p> <p>For specific questions, check the: - API Reference for detailed module documentation - GitHub Issues for known problems</p>"},{"location":"getting_started/#where-to-go-next","title":"Where to Go Next","text":"<p>Now that you have a basic understanding of EthoPy:</p> <ol> <li>Dive deeper into Local Configuration for advanced settings</li> <li>Understand setup configuration index</li> <li>How to create a Task </li> <li>Explore the Plugin System to extend functionality</li> <li>Learn about Database Setup for data storage</li> <li>Study the API Reference for detailed documentation</li> <li>Check Contributing if you want to help improve EthoPy</li> </ol>"},{"location":"gui/","title":"Graphical User Interface","text":""},{"location":"gui/#control-setups","title":"Control Setups","text":""},{"location":"gui/#control-table","title":"Control table","text":""},{"location":"gui/#pywelocome","title":"PyWelocome","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;=3.8,&lt;3.12</li> <li>Docker (for database setup)</li> <li>Dependencies: numpy, pandas, datajoint, pygame, pillow, and more (automatically installed)</li> </ul>"},{"location":"installation/#installation-options","title":"Installation Options","text":""},{"location":"installation/#basic-installation","title":"Basic Installation","text":"<p>To install EthoPy with basic features, run:</p> <pre><code>pip install ethopy\n</code></pre> <p>This is the preferred method as it will install the most recent stable release.</p>"},{"location":"installation/#optional-features","title":"Optional Features","text":"<p>For additional functionality:</p> <pre><code># For 3D object support\npip install \"ethopy[obj]\"\n\n# For development\npip install \"ethopy[dev]\"\n\n# For documentation\npip install \"ethopy[docs]\"\n</code></pre>"},{"location":"installation/#from-source","title":"From Source","text":"<p>To install the latest development version:</p> <pre><code>pip install git+https://github.com/ef-lab/ethopy_package\n</code></pre> <p>For development installation:</p> <pre><code>git clone https://github.com/ef-lab/ethopy_package/.git\ncd ethopy\npip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"installation/#database-setup","title":"Database Setup","text":"<ol> <li> <p>Start the database container: <pre><code>ethopy-setup-djdocker\n</code></pre></p> </li> <li> <p>Configure the database connection:</p> </li> </ol> <p>Create a configuration file at: - Linux/macOS: <code>~/.ethopy/local_conf.json</code> - Windows: <code>%USERPROFILE%\\.ethopy\\local_conf.json</code></p> <pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"127.0.0.1\",\n        \"database.user\": \"root\",\n        \"database.password\": \"your_password\",\n        \"database.port\": 3306\n    },\n    \"source_path\": \"/path/to/data\",\n    \"target_path\": \"/path/to/backup\",\n    \"logging\": {\n        \"level\": \"INFO\",\n        \"filename\": \"ethopy.log\"\n    }\n}\n</code></pre> <ol> <li> <p>Verify database connection: <pre><code>ethopy-db-connection\n</code></pre></p> </li> <li> <p>Create required schemas: <pre><code>ethopy-setup-schema\n</code></pre></p> </li> </ol>"},{"location":"installation/#raspberry-pi-setup","title":"Raspberry Pi Setup","text":"<p>For detailed Raspberry Pi setup instructions, including hardware-specific configurations and dependencies, please refer to our Raspberry Pi Setup Guide.</p>"},{"location":"interface/","title":"Core Interface module","text":"<p>Core interface module for EthoPy.</p> <p>This module provides the base interface for hardware interaction and configuration of hardware based on setup index.</p>"},{"location":"interface/#ethopy.core.interface.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>Manual</code></p> <p>DataJoint table for saving setup configurations for each session.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>@interface.schema\nclass Configuration(dj.Manual):\n    \"\"\"DataJoint table for saving setup configurations for each session.\"\"\"\n\n    definition = \"\"\"\n    # Session behavior configuration info\n    -&gt; experiment.Session\n    \"\"\"\n\n    class Port(dj.Part):\n        \"\"\"Port configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Probe identity\n        -&gt; Configuration\n        port                     : tinyint                      # port id\n        type=\"Lick\"              : varchar(24)                 # port type\n        ---\n        ready=0                  : tinyint                      # ready flag\n        response=0               : tinyint                      # response flag\n        reward=0                 : tinyint                      # reward flag\n        discription              : varchar(256)\n        \"\"\"\n\n    class Ball(dj.Part):\n        \"\"\"Ball configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Ball information\n        -&gt; Configuration\n        ---\n        ball_radius=0.125        : float                   # in meters\n        material=\"styrofoam\"     : varchar(64)             # ball material\n        coupling=\"bearings\"      : enum('bearings','air')  # mechanical coupling\n        discription              : varchar(256)\n        \"\"\"\n\n    class Screen(dj.Part):\n        \"\"\"Screen configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Screen information\n        -&gt; Configuration\n        screen_idx               : tinyint\n        ---\n        intensity                : tinyint UNSIGNED\n        distance         : float\n        center_x         : float\n        center_y         : float\n        aspect           : float\n        size             : float\n        fps                      : tinyint UNSIGNED\n        resolution_x             : smallint\n        resolution_y             : smallint\n        description              : varchar(256)\n        \"\"\"\n\n    class Speaker(dj.Part):\n        \"\"\"Speaker configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Speaker information\n        speaker_idx             : tinyint\n        -&gt; Configuration\n        ---\n        sound_freq=10000        : int           # in Hz\n        duration=500            : int           # in ms\n        volume=50               : tinyint       # 0-100 percentage\n        discription             : varchar(256)\n        \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Configuration.Ball","title":"<code>Ball</code>","text":"<p>               Bases: <code>Part</code></p> <p>Ball configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Ball(dj.Part):\n    \"\"\"Ball configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Ball information\n    -&gt; Configuration\n    ---\n    ball_radius=0.125        : float                   # in meters\n    material=\"styrofoam\"     : varchar(64)             # ball material\n    coupling=\"bearings\"      : enum('bearings','air')  # mechanical coupling\n    discription              : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Configuration.Port","title":"<code>Port</code>","text":"<p>               Bases: <code>Part</code></p> <p>Port configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Port(dj.Part):\n    \"\"\"Port configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Probe identity\n    -&gt; Configuration\n    port                     : tinyint                      # port id\n    type=\"Lick\"              : varchar(24)                 # port type\n    ---\n    ready=0                  : tinyint                      # ready flag\n    response=0               : tinyint                      # response flag\n    reward=0                 : tinyint                      # reward flag\n    discription              : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Configuration.Screen","title":"<code>Screen</code>","text":"<p>               Bases: <code>Part</code></p> <p>Screen configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Screen(dj.Part):\n    \"\"\"Screen configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Screen information\n    -&gt; Configuration\n    screen_idx               : tinyint\n    ---\n    intensity                : tinyint UNSIGNED\n    distance         : float\n    center_x         : float\n    center_y         : float\n    aspect           : float\n    size             : float\n    fps                      : tinyint UNSIGNED\n    resolution_x             : smallint\n    resolution_y             : smallint\n    description              : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Configuration.Speaker","title":"<code>Speaker</code>","text":"<p>               Bases: <code>Part</code></p> <p>Speaker configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Speaker(dj.Part):\n    \"\"\"Speaker configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Speaker information\n    speaker_idx             : tinyint\n    -&gt; Configuration\n    ---\n    sound_freq=10000        : int           # in Hz\n    duration=500            : int           # in ms\n    volume=50               : tinyint       # 0-100 percentage\n    discription             : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface","title":"<code>Interface</code>","text":"<p>Base interface class for hardware interaction in experimental setups.</p> <p>This class manages hardware interfaces including ports, cameras, and other peripherals. It provides methods for stimulus delivery, reward management, and hardware control.</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>Current active port</p> <code>resp_tmst</code> <code>int</code> <p>Response timestamp</p> <code>ready_dur</code> <code>int</code> <p>Ready duration</p> <code>activity_tmst</code> <code>int</code> <p>Activity timestamp</p> <code>ready_tmst</code> <code>int</code> <p>Ready state timestamp</p> <code>pulse_rew</code> <code>Dict[int, Dict]</code> <p>Reward pulse settings by port</p> <code>ports</code> <code>List[Port]</code> <p>List of available ports</p> <code>response</code> <code>List</code> <p>List of responses</p> <code>duration</code> <code>Dict[int, float]</code> <p>Duration settings by port</p> <code>ready</code> <code>bool</code> <p>Ready state flag</p> <code>timer_ready</code> <code>Timer</code> <p>Timer for ready state</p> <code>weight_per_pulse</code> <code>Dict[int, float]</code> <p>Calibration weights per pulse</p> <code>pulse_dur</code> <code>Dict[int, float]</code> <p>Pulse durations by port</p> <code>channels</code> <code>Dict[str, Any]</code> <p>Channel mappings</p> <code>position_dur</code> <code>int</code> <p>Position duration</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Interface:\n    \"\"\"Base interface class for hardware interaction in experimental setups.\n\n    This class manages hardware interfaces including ports, cameras, and other\n    peripherals.\n    It provides methods for stimulus delivery, reward management, and hardware control.\n\n    Attributes:\n        port (int): Current active port\n        resp_tmst (int): Response timestamp\n        ready_dur (int): Ready duration\n        activity_tmst (int): Activity timestamp\n        ready_tmst (int): Ready state timestamp\n        pulse_rew (Dict[int, Dict]): Reward pulse settings by port\n        ports (List[Port]): List of available ports\n        response (List): List of responses\n        duration (Dict[int, float]): Duration settings by port\n        ready (bool): Ready state flag\n        timer_ready (Timer): Timer for ready state\n        weight_per_pulse (Dict[int, float]): Calibration weights per pulse\n        pulse_dur (Dict[int, float]): Pulse durations by port\n        channels (Dict[str, Any]): Channel mappings\n        position_dur (int): Position duration\n\n    \"\"\"\n\n    def __init__(\n        self,\n        exp: Optional = None,\n        beh: Optional = None,\n        callbacks: bool = True,\n    ) -&gt; None:\n        \"\"\"Initialize the interface with experiment and behavior objects.\n\n        Args:\n            exp: Experiment object containing parameters and logger\n            beh: Behavior object for tracking responses\n            callbacks: Whether to enable callback functions\n\n        \"\"\"\n        # Initialize basic attributes\n        self.callbacks = callbacks\n        self.beh = beh\n        self.exp = exp\n        self.logger = exp.logger if exp else None\n        self.position = Port()\n        self.position_tmst: int = 0\n        self.camera = None\n        self.ports: List[Port] = []\n        self.pulse_rew: Dict[int, Dict] = {}\n        self.duration: Dict[int, float] = {}\n        self.weight_per_pulse: Dict[int, float] = {}\n        self.pulse_dur: Dict[int, float] = {}\n\n        # Initialize timing variables\n        self.port: int = 0\n        self.resp_tmst: int = 0\n        self.ready_dur: int = 0\n        self.activity_tmst: int = 0\n        self.ready_tmst: int = 0\n        self.position_dur: int = 0\n\n        # Initialize state variables\n        self.ready: bool = False\n        self.timer_ready = Timer()\n        self.response: List[Any] = []\n\n        if exp and hasattr(exp, \"params\"):\n            self._initialize_hardware()\n\n    def _initialize_hardware(self) -&gt; None:\n        \"\"\"Initialize hardware components based on setup configuration.\n\n        This method sets up ports and camera if configured in the experiment parameters.\n        \"\"\"\n        # Initialize ports\n        port_configs = self.logger.get(\n            schema=\"interface\",\n            table=\"SetupConfiguration.Port\",\n            key=self.exp.params,\n            as_dict=True,\n        )\n\n        for port_config in port_configs:\n            self.ports.append(Port(**port_config))\n\n        self.ports = np.array(self.ports)\n        self.proximity_ports = np.array(\n            [p.port for p in self.ports if p.type == \"Proximity\"]\n        )\n        self.rew_ports = np.array([p.port for p in self.ports if p.reward])\n\n        # Initialize camera if configured\n        self._initialize_camera()\n\n    def _initialize_camera(self) -&gt; None:\n        \"\"\"Initialize camera if configured in setup.\"\"\"\n        setup_cameras = self.logger.get(\n            schema=\"interface\",\n            table=\"SetupConfiguration.Camera\",\n            fields=[\"setup_conf_idx\"],\n        )\n\n        if self.exp.params[\"setup_conf_idx\"] in setup_cameras:\n            camera_params = self.logger.get(\n                schema=\"interface\",\n                table=\"SetupConfiguration.Camera\",\n                key=f\"setup_conf_idx={self.exp.params['setup_conf_idx']}\",\n                as_dict=True,\n            )[0]\n\n            camera_class = getattr(\n                import_module(\"Interfaces.Camera\"), camera_params[\"discription\"]\n            )\n\n            self.camera = camera_class(\n                filename=f\"{self.logger.trial_key['animal_id']}\"\n                f\"_{self.logger.trial_key['session']}\",\n                logger=self.logger,\n                logger_timer=self.logger.logger_timer,\n                video_aim=camera_params.pop(\"video_aim\"),\n                **camera_params,\n            )\n\n    def give_liquid(self, port: int, duration: Optional[float] = 0) -&gt; None:\n        \"\"\"Deliver liquid reward through specified port.\n\n        Args:\n            port: Port number for delivery\n            duration: Duration of delivery in milliseconds\n\n        \"\"\"\n\n    def give_odor(self, odor_idx: int, duration: float) -&gt; None:\n        \"\"\"Deliver odor stimulus.\n\n        Args:\n            odor_idx: Index of odor to deliver\n            duration: Duration of delivery in milliseconds\n\n        \"\"\"\n\n    def give_sound(self, sound_freq: float, duration: float, dutycycle: float) -&gt; None:\n        \"\"\"Generate sound stimulus.\n\n        Args:\n            sound_freq: Frequency of sound in Hz\n            duration: Duration of sound in milliseconds\n            dutycycle: Duty cycle for sound generation (0-1)\n\n        \"\"\"\n\n    def in_position(self) -&gt; Tuple[bool, float]:\n        \"\"\"Check if subject is in correct position.\n\n        Returns:\n            Tuple of (position status, position time)\n\n        \"\"\"\n        return True, 0\n\n    def create_pulse(self, port: int, duration: float) -&gt; None:\n        \"\"\"Create a pulse for stimulus delivery.\n\n        Args:\n            port: Port number for pulse\n            duration: Duration of pulse in milliseconds\n\n        \"\"\"\n\n    def sync_out(self, state: bool = False) -&gt; None:\n        \"\"\"Send synchronization signal.\n\n        Args:\n            state: Synchronization state to set\n\n        \"\"\"\n\n    def set_operation_status(self, operation_status: bool) -&gt; None:\n        \"\"\"Set operation status of interface.\n\n        Args:\n            operation_status: Status to set\n\n        \"\"\"\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Clean up interface resources.\"\"\"\n\n    def release(self) -&gt; None:\n        \"\"\"Release hardware resources, especially camera.\"\"\"\n        if self.camera:\n            log.info(\"Release camear\" * 10)\n            if self.camera.recording.is_set():\n                self.camera.stop_rec()\n\n    def load_calibration(self) -&gt; None:\n        \"\"\"Load port calibration data from database.\n\n        This method loads the most recent calibration data for each reward port,\n        including pulse durations and weights.\n\n        Raises:\n            RuntimeError: If no calibration data is found\n\n        \"\"\"\n        for port in list(set(self.rew_ports)):\n            self.pulse_rew[port] = dict()\n            key = dict(setup=self.logger.setup, port=port)\n            dates = self.logger.get(\n                schema=\"interface\",\n                table=\"PortCalibration.Liquid\",\n                key=key,\n                fields=[\"date\"],\n                order_by=\"date\",\n            )\n            if np.size(dates) &lt; 1:\n                log.error(\"No PortCalibration found!\")\n                self.exp.quit = True\n                break\n\n            key[\"date\"] = dates[-1]  # use most recent calibration\n\n            self.pulse_dur[port], pulse_num, weight = self.logger.get(\n                schema=\"interface\",\n                table=\"PortCalibration.Liquid\",\n                key=key,\n                fields=[\"pulse_dur\", \"pulse_num\", \"weight\"],\n            )\n            self.weight_per_pulse[port] = np.divide(weight, pulse_num)\n\n    def calc_pulse_dur(self, reward_amount: float) -&gt; Dict[int, float]:\n        \"\"\"Calculate pulse duration for desired reward amount.\n\n        Args:\n            reward_amount: Desired reward amount in microliters\n\n        Returns:\n            Dictionary mapping ports to actual reward amounts\n\n        \"\"\"\n        actual_rew = {}\n        for port in self.rew_ports:\n            if reward_amount not in self.pulse_rew[port]:\n                self.duration[port] = np.interp(\n                    reward_amount / 1000,\n                    self.weight_per_pulse[port],\n                    self.pulse_dur[port],\n                )\n                self.pulse_rew[port][reward_amount] = (\n                    np.max((np.min(self.weight_per_pulse[port]), reward_amount / 1000))\n                    * 1000\n                )  # in uL\n            actual_rew[port] = self.pulse_rew[port][reward_amount]\n        return actual_rew\n\n    def _channel2port(self, channel: Optional[int], category: str = \"Proximity\"):\n        \"\"\"Convert channel number to port object.\n\n        Args:\n            channel: Channel number to convert\n            category: Port category to match\n\n        Returns:\n            Corresponding port or None if not found\n\n        \"\"\"\n        port = reverse_lookup(self.channels[category], channel) if channel else 0\n        if port:\n            port = self.ports[Port(type=category, port=port) == self.ports][0]\n        return port\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.__init__","title":"<code>__init__(exp=None, beh=None, callbacks=True)</code>","text":"<p>Initialize the interface with experiment and behavior objects.</p> <p>Parameters:</p> Name Type Description Default <code>exp</code> <code>Optional</code> <p>Experiment object containing parameters and logger</p> <code>None</code> <code>beh</code> <code>Optional</code> <p>Behavior object for tracking responses</p> <code>None</code> <code>callbacks</code> <code>bool</code> <p>Whether to enable callback functions</p> <code>True</code> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def __init__(\n    self,\n    exp: Optional = None,\n    beh: Optional = None,\n    callbacks: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the interface with experiment and behavior objects.\n\n    Args:\n        exp: Experiment object containing parameters and logger\n        beh: Behavior object for tracking responses\n        callbacks: Whether to enable callback functions\n\n    \"\"\"\n    # Initialize basic attributes\n    self.callbacks = callbacks\n    self.beh = beh\n    self.exp = exp\n    self.logger = exp.logger if exp else None\n    self.position = Port()\n    self.position_tmst: int = 0\n    self.camera = None\n    self.ports: List[Port] = []\n    self.pulse_rew: Dict[int, Dict] = {}\n    self.duration: Dict[int, float] = {}\n    self.weight_per_pulse: Dict[int, float] = {}\n    self.pulse_dur: Dict[int, float] = {}\n\n    # Initialize timing variables\n    self.port: int = 0\n    self.resp_tmst: int = 0\n    self.ready_dur: int = 0\n    self.activity_tmst: int = 0\n    self.ready_tmst: int = 0\n    self.position_dur: int = 0\n\n    # Initialize state variables\n    self.ready: bool = False\n    self.timer_ready = Timer()\n    self.response: List[Any] = []\n\n    if exp and hasattr(exp, \"params\"):\n        self._initialize_hardware()\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface._channel2port","title":"<code>_channel2port(channel, category='Proximity')</code>","text":"<p>Convert channel number to port object.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Optional[int]</code> <p>Channel number to convert</p> required <code>category</code> <code>str</code> <p>Port category to match</p> <code>'Proximity'</code> <p>Returns:</p> Type Description <p>Corresponding port or None if not found</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def _channel2port(self, channel: Optional[int], category: str = \"Proximity\"):\n    \"\"\"Convert channel number to port object.\n\n    Args:\n        channel: Channel number to convert\n        category: Port category to match\n\n    Returns:\n        Corresponding port or None if not found\n\n    \"\"\"\n    port = reverse_lookup(self.channels[category], channel) if channel else 0\n    if port:\n        port = self.ports[Port(type=category, port=port) == self.ports][0]\n    return port\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface._initialize_camera","title":"<code>_initialize_camera()</code>","text":"<p>Initialize camera if configured in setup.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def _initialize_camera(self) -&gt; None:\n    \"\"\"Initialize camera if configured in setup.\"\"\"\n    setup_cameras = self.logger.get(\n        schema=\"interface\",\n        table=\"SetupConfiguration.Camera\",\n        fields=[\"setup_conf_idx\"],\n    )\n\n    if self.exp.params[\"setup_conf_idx\"] in setup_cameras:\n        camera_params = self.logger.get(\n            schema=\"interface\",\n            table=\"SetupConfiguration.Camera\",\n            key=f\"setup_conf_idx={self.exp.params['setup_conf_idx']}\",\n            as_dict=True,\n        )[0]\n\n        camera_class = getattr(\n            import_module(\"Interfaces.Camera\"), camera_params[\"discription\"]\n        )\n\n        self.camera = camera_class(\n            filename=f\"{self.logger.trial_key['animal_id']}\"\n            f\"_{self.logger.trial_key['session']}\",\n            logger=self.logger,\n            logger_timer=self.logger.logger_timer,\n            video_aim=camera_params.pop(\"video_aim\"),\n            **camera_params,\n        )\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface._initialize_hardware","title":"<code>_initialize_hardware()</code>","text":"<p>Initialize hardware components based on setup configuration.</p> <p>This method sets up ports and camera if configured in the experiment parameters.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def _initialize_hardware(self) -&gt; None:\n    \"\"\"Initialize hardware components based on setup configuration.\n\n    This method sets up ports and camera if configured in the experiment parameters.\n    \"\"\"\n    # Initialize ports\n    port_configs = self.logger.get(\n        schema=\"interface\",\n        table=\"SetupConfiguration.Port\",\n        key=self.exp.params,\n        as_dict=True,\n    )\n\n    for port_config in port_configs:\n        self.ports.append(Port(**port_config))\n\n    self.ports = np.array(self.ports)\n    self.proximity_ports = np.array(\n        [p.port for p in self.ports if p.type == \"Proximity\"]\n    )\n    self.rew_ports = np.array([p.port for p in self.ports if p.reward])\n\n    # Initialize camera if configured\n    self._initialize_camera()\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.calc_pulse_dur","title":"<code>calc_pulse_dur(reward_amount)</code>","text":"<p>Calculate pulse duration for desired reward amount.</p> <p>Parameters:</p> Name Type Description Default <code>reward_amount</code> <code>float</code> <p>Desired reward amount in microliters</p> required <p>Returns:</p> Type Description <code>Dict[int, float]</code> <p>Dictionary mapping ports to actual reward amounts</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def calc_pulse_dur(self, reward_amount: float) -&gt; Dict[int, float]:\n    \"\"\"Calculate pulse duration for desired reward amount.\n\n    Args:\n        reward_amount: Desired reward amount in microliters\n\n    Returns:\n        Dictionary mapping ports to actual reward amounts\n\n    \"\"\"\n    actual_rew = {}\n    for port in self.rew_ports:\n        if reward_amount not in self.pulse_rew[port]:\n            self.duration[port] = np.interp(\n                reward_amount / 1000,\n                self.weight_per_pulse[port],\n                self.pulse_dur[port],\n            )\n            self.pulse_rew[port][reward_amount] = (\n                np.max((np.min(self.weight_per_pulse[port]), reward_amount / 1000))\n                * 1000\n            )  # in uL\n        actual_rew[port] = self.pulse_rew[port][reward_amount]\n    return actual_rew\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.cleanup","title":"<code>cleanup()</code>","text":"<p>Clean up interface resources.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Clean up interface resources.\"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.create_pulse","title":"<code>create_pulse(port, duration)</code>","text":"<p>Create a pulse for stimulus delivery.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port number for pulse</p> required <code>duration</code> <code>float</code> <p>Duration of pulse in milliseconds</p> required Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def create_pulse(self, port: int, duration: float) -&gt; None:\n    \"\"\"Create a pulse for stimulus delivery.\n\n    Args:\n        port: Port number for pulse\n        duration: Duration of pulse in milliseconds\n\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.give_liquid","title":"<code>give_liquid(port, duration=0)</code>","text":"<p>Deliver liquid reward through specified port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port number for delivery</p> required <code>duration</code> <code>Optional[float]</code> <p>Duration of delivery in milliseconds</p> <code>0</code> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def give_liquid(self, port: int, duration: Optional[float] = 0) -&gt; None:\n    \"\"\"Deliver liquid reward through specified port.\n\n    Args:\n        port: Port number for delivery\n        duration: Duration of delivery in milliseconds\n\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.give_odor","title":"<code>give_odor(odor_idx, duration)</code>","text":"<p>Deliver odor stimulus.</p> <p>Parameters:</p> Name Type Description Default <code>odor_idx</code> <code>int</code> <p>Index of odor to deliver</p> required <code>duration</code> <code>float</code> <p>Duration of delivery in milliseconds</p> required Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def give_odor(self, odor_idx: int, duration: float) -&gt; None:\n    \"\"\"Deliver odor stimulus.\n\n    Args:\n        odor_idx: Index of odor to deliver\n        duration: Duration of delivery in milliseconds\n\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.give_sound","title":"<code>give_sound(sound_freq, duration, dutycycle)</code>","text":"<p>Generate sound stimulus.</p> <p>Parameters:</p> Name Type Description Default <code>sound_freq</code> <code>float</code> <p>Frequency of sound in Hz</p> required <code>duration</code> <code>float</code> <p>Duration of sound in milliseconds</p> required <code>dutycycle</code> <code>float</code> <p>Duty cycle for sound generation (0-1)</p> required Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def give_sound(self, sound_freq: float, duration: float, dutycycle: float) -&gt; None:\n    \"\"\"Generate sound stimulus.\n\n    Args:\n        sound_freq: Frequency of sound in Hz\n        duration: Duration of sound in milliseconds\n        dutycycle: Duty cycle for sound generation (0-1)\n\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.in_position","title":"<code>in_position()</code>","text":"<p>Check if subject is in correct position.</p> <p>Returns:</p> Type Description <code>Tuple[bool, float]</code> <p>Tuple of (position status, position time)</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def in_position(self) -&gt; Tuple[bool, float]:\n    \"\"\"Check if subject is in correct position.\n\n    Returns:\n        Tuple of (position status, position time)\n\n    \"\"\"\n    return True, 0\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.load_calibration","title":"<code>load_calibration()</code>","text":"<p>Load port calibration data from database.</p> <p>This method loads the most recent calibration data for each reward port, including pulse durations and weights.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no calibration data is found</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def load_calibration(self) -&gt; None:\n    \"\"\"Load port calibration data from database.\n\n    This method loads the most recent calibration data for each reward port,\n    including pulse durations and weights.\n\n    Raises:\n        RuntimeError: If no calibration data is found\n\n    \"\"\"\n    for port in list(set(self.rew_ports)):\n        self.pulse_rew[port] = dict()\n        key = dict(setup=self.logger.setup, port=port)\n        dates = self.logger.get(\n            schema=\"interface\",\n            table=\"PortCalibration.Liquid\",\n            key=key,\n            fields=[\"date\"],\n            order_by=\"date\",\n        )\n        if np.size(dates) &lt; 1:\n            log.error(\"No PortCalibration found!\")\n            self.exp.quit = True\n            break\n\n        key[\"date\"] = dates[-1]  # use most recent calibration\n\n        self.pulse_dur[port], pulse_num, weight = self.logger.get(\n            schema=\"interface\",\n            table=\"PortCalibration.Liquid\",\n            key=key,\n            fields=[\"pulse_dur\", \"pulse_num\", \"weight\"],\n        )\n        self.weight_per_pulse[port] = np.divide(weight, pulse_num)\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.release","title":"<code>release()</code>","text":"<p>Release hardware resources, especially camera.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def release(self) -&gt; None:\n    \"\"\"Release hardware resources, especially camera.\"\"\"\n    if self.camera:\n        log.info(\"Release camear\" * 10)\n        if self.camera.recording.is_set():\n            self.camera.stop_rec()\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.set_operation_status","title":"<code>set_operation_status(operation_status)</code>","text":"<p>Set operation status of interface.</p> <p>Parameters:</p> Name Type Description Default <code>operation_status</code> <code>bool</code> <p>Status to set</p> required Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def set_operation_status(self, operation_status: bool) -&gt; None:\n    \"\"\"Set operation status of interface.\n\n    Args:\n        operation_status: Status to set\n\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Interface.sync_out","title":"<code>sync_out(state=False)</code>","text":"<p>Send synchronization signal.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>Synchronization state to set</p> <code>False</code> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def sync_out(self, state: bool = False) -&gt; None:\n    \"\"\"Send synchronization signal.\n\n    Args:\n        state: Synchronization state to set\n\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Port","title":"<code>Port</code>  <code>dataclass</code>","text":"<p>Dataclass representing a hardware port configuration.</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>Port identifier</p> <code>type</code> <code>str</code> <p>Port type (e.g., 'Lick', 'Proximity')</p> <code>ready</code> <code>bool</code> <p>Whether port is in ready state</p> <code>reward</code> <code>bool</code> <p>Whether port can deliver rewards</p> <code>response</code> <code>bool</code> <p>Whether port accepts responses</p> <code>invert</code> <code>bool</code> <p>Whether to invert port signal</p> <code>state</code> <code>bool</code> <p>Current port state</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>@dataclass\nclass Port:\n    \"\"\"Dataclass representing a hardware port configuration.\n\n    Attributes:\n        port (int): Port identifier\n        type (str): Port type (e.g., 'Lick', 'Proximity')\n        ready (bool): Whether port is in ready state\n        reward (bool): Whether port can deliver rewards\n        response (bool): Whether port accepts responses\n        invert (bool): Whether to invert port signal\n        state (bool): Current port state\n\n    \"\"\"\n\n    port: int = datafield(compare=True, default=0, hash=True)\n    type: str = datafield(compare=True, default=\"\", hash=True)\n    ready: bool = datafield(compare=False, default=False)\n    reward: bool = datafield(compare=False, default=False)\n    response: bool = datafield(compare=False, default=False)\n    invert: bool = datafield(compare=False, default=False)\n    state: bool = datafield(compare=False, default=False)\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the instance with the given keyword arguments.\n\n        This constructor dynamically sets the attributes of the instance\n        based on the provided keyword arguments. Only attributes that are\n        defined as fields of the class will be set.\n        \"\"\"\n        names = set([f.name for f in fields(self)])\n        for k, v in kwargs.items():\n            if k in names:\n                setattr(self, k, v)\n</code></pre>"},{"location":"interface/#ethopy.core.interface.Port.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize the instance with the given keyword arguments.</p> <p>This constructor dynamically sets the attributes of the instance based on the provided keyword arguments. Only attributes that are defined as fields of the class will be set.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the instance with the given keyword arguments.\n\n    This constructor dynamically sets the attributes of the instance\n    based on the provided keyword arguments. Only attributes that are\n    defined as fields of the class will be set.\n    \"\"\"\n    names = set([f.name for f in fields(self)])\n    for k, v in kwargs.items():\n        if k in names:\n            setattr(self, k, v)\n</code></pre>"},{"location":"interface/#ethopy.core.interface.PortCalibration","title":"<code>PortCalibration</code>","text":"<p>               Bases: <code>Manual</code></p> <p>Liquid delivery calibration sessions for each port with water availability.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>@interface.schema\nclass PortCalibration(dj.Manual):\n    \"\"\"Liquid delivery calibration sessions for each port with water availability.\"\"\"\n\n    definition = \"\"\"\n    # Liquid delivery calibration sessions for each port with water availability\n    setup                        : varchar(256)  # Setup name\n    port                         : tinyint       # port id\n    date                         : date # session date (only one per day is allowed)\n    \"\"\"\n\n    class Liquid(dj.Part):\n        \"\"\"Datajoint table for volume per pulse duty cycle estimation.\"\"\"\n\n        definition = \"\"\"\n        # Data for volume per pulse duty cycle estimation\n        -&gt; PortCalibration\n        pulse_dur                    : int       # duration of pulse in ms\n        ---\n        pulse_num                    : int       # number of pulses\n        weight                       : float     # weight of total liquid released in gr\n        timestamp=CURRENT_TIMESTAMP  : timestamp # timestamp\n        pressure=0                   : float     # air pressure (PSI)\n        \"\"\"\n\n    class Test(dj.Part):\n        \"\"\"Datajoint table for Lick Test.\"\"\"\n\n        definition = \"\"\"\n        # Lick timestamps\n        setup                        : varchar(256)                 # Setup name\n        port                         : tinyint                      # port id\n        timestamp=CURRENT_TIMESTAMP  : timestamp\n        ___\n        result=null                  : enum('Passed','Failed')\n        pulses=null                  : int\n        \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.PortCalibration.Liquid","title":"<code>Liquid</code>","text":"<p>               Bases: <code>Part</code></p> <p>Datajoint table for volume per pulse duty cycle estimation.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Liquid(dj.Part):\n    \"\"\"Datajoint table for volume per pulse duty cycle estimation.\"\"\"\n\n    definition = \"\"\"\n    # Data for volume per pulse duty cycle estimation\n    -&gt; PortCalibration\n    pulse_dur                    : int       # duration of pulse in ms\n    ---\n    pulse_num                    : int       # number of pulses\n    weight                       : float     # weight of total liquid released in gr\n    timestamp=CURRENT_TIMESTAMP  : timestamp # timestamp\n    pressure=0                   : float     # air pressure (PSI)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.PortCalibration.Test","title":"<code>Test</code>","text":"<p>               Bases: <code>Part</code></p> <p>Datajoint table for Lick Test.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Test(dj.Part):\n    \"\"\"Datajoint table for Lick Test.\"\"\"\n\n    definition = \"\"\"\n    # Lick timestamps\n    setup                        : varchar(256)                 # Setup name\n    port                         : tinyint                      # port id\n    timestamp=CURRENT_TIMESTAMP  : timestamp\n    ___\n    result=null                  : enum('Passed','Failed')\n    pulses=null                  : int\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.SetupConfiguration","title":"<code>SetupConfiguration</code>","text":"<p>               Bases: <code>Lookup</code>, <code>Manual</code></p> <p>DataJoint table for configuring the setup interfaces.</p> <p>The user can define all harware configuration by defining only the setup index.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>@interface.schema\nclass SetupConfiguration(dj.Lookup, dj.Manual):\n    \"\"\"DataJoint table for configuring the setup interfaces.\n\n    The user can define all harware configuration by defining only the setup index.\n    \"\"\"\n\n    definition = \"\"\"\n    # Setup configuration\n    setup_conf_idx           : tinyint      # configuration version\n    ---\n    interface                : enum('DummyPorts','RPPorts', 'PCPorts', 'RPVR')\n    discription              : varchar(256)\n    \"\"\"\n\n    contents = [\n        [0, \"DummyPorts\", \"Simulation\"],\n    ]\n\n    class Port(dj.Lookup, dj.Part):\n        \"\"\"Port configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Probe identityrepeat_n = 1\n\n        port                     : tinyint                      # port id\n        type=\"Lick\"              : enum('Lick','Proximity')     # port type\n        -&gt; SetupConfiguration\n        ---\n        ready=0                  : tinyint                      # ready flag\n        response=0               : tinyint                      # response flag\n        reward=0                 : tinyint                      # reward flag\n        invert=0                 : tinyint                      # invert flag\n        discription              : varchar(256)\n        \"\"\"\n\n        contents = [\n            [1, \"Lick\", 0, 0, 1, 1, 0, \"probe\"],\n            [2, \"Lick\", 0, 0, 1, 1, 0, \"probe\"],\n            [3, \"Proximity\", 0, 1, 0, 0, 0, \"probe\"],\n        ]\n\n    class Screen(dj.Lookup, dj.Part):\n        \"\"\"Screen configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Screen information\n        screen_idx               : tinyint\n        -&gt; SetupConfiguration\n        ---\n        intensity                : tinyint UNSIGNED\n        distance                 : float\n        center_x                 : float\n        center_y                 : float\n        aspect                   : float\n        size                     : float\n        fps                      : tinyint UNSIGNED\n        resolution_x             : smallint\n        resolution_y             : smallint\n        description              : varchar(256)\n        fullscreen               : tinyint\n        \"\"\"\n\n        contents = [\n            [1, 0, 64, 5.0, 0, -0.1, 1.66, 7.0, 30, 800, 480, \"Simulation\", 0],\n        ]\n\n    class Ball(dj.Lookup, dj.Part):\n        \"\"\"Ball configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Ball information\n        -&gt; SetupConfiguration\n        ---\n        ball_radius=0.125        : float                   # in meters\n        material=\"styrofoam\"     : varchar(64)             # ball material\n        coupling=\"bearings\"      : enum('bearings','air')  # mechanical coupling\n        discription              : varchar(256)\n        \"\"\"\n\n    class Speaker(dj.Lookup, dj.Part):\n        \"\"\"Speaker configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Speaker information\n        speaker_idx             : tinyint\n        -&gt; SetupConfiguration\n        ---\n        sound_freq=10000        : int           # in Hz\n        duration=500            : int           # in ms\n        volume=50               : tinyint       # 0-100 percentage\n        discription             : varchar(256)\n        \"\"\"\n\n    class Camera(dj.Lookup, dj.Part):\n        \"\"\"Camera configuration table.\"\"\"\n\n        definition = \"\"\"\n        # Camera information\n        camera_idx               : tinyint\n        -&gt; SetupConfiguration\n        ---\n        fps                      : tinyint UNSIGNED\n        resolution_x             : smallint\n        resolution_y             : smallint\n        shutter_speed            : smallint\n        iso                      : smallint\n        file_format              : varchar(256)\n        video_aim                : enum('eye','body','openfield')\n        discription              : varchar(256)\n        \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.SetupConfiguration.Ball","title":"<code>Ball</code>","text":"<p>               Bases: <code>Lookup</code>, <code>Part</code></p> <p>Ball configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Ball(dj.Lookup, dj.Part):\n    \"\"\"Ball configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Ball information\n    -&gt; SetupConfiguration\n    ---\n    ball_radius=0.125        : float                   # in meters\n    material=\"styrofoam\"     : varchar(64)             # ball material\n    coupling=\"bearings\"      : enum('bearings','air')  # mechanical coupling\n    discription              : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.SetupConfiguration.Camera","title":"<code>Camera</code>","text":"<p>               Bases: <code>Lookup</code>, <code>Part</code></p> <p>Camera configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Camera(dj.Lookup, dj.Part):\n    \"\"\"Camera configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Camera information\n    camera_idx               : tinyint\n    -&gt; SetupConfiguration\n    ---\n    fps                      : tinyint UNSIGNED\n    resolution_x             : smallint\n    resolution_y             : smallint\n    shutter_speed            : smallint\n    iso                      : smallint\n    file_format              : varchar(256)\n    video_aim                : enum('eye','body','openfield')\n    discription              : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"interface/#ethopy.core.interface.SetupConfiguration.Port","title":"<code>Port</code>","text":"<p>               Bases: <code>Lookup</code>, <code>Part</code></p> <p>Port configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Port(dj.Lookup, dj.Part):\n    \"\"\"Port configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Probe identityrepeat_n = 1\n\n    port                     : tinyint                      # port id\n    type=\"Lick\"              : enum('Lick','Proximity')     # port type\n    -&gt; SetupConfiguration\n    ---\n    ready=0                  : tinyint                      # ready flag\n    response=0               : tinyint                      # response flag\n    reward=0                 : tinyint                      # reward flag\n    invert=0                 : tinyint                      # invert flag\n    discription              : varchar(256)\n    \"\"\"\n\n    contents = [\n        [1, \"Lick\", 0, 0, 1, 1, 0, \"probe\"],\n        [2, \"Lick\", 0, 0, 1, 1, 0, \"probe\"],\n        [3, \"Proximity\", 0, 1, 0, 0, 0, \"probe\"],\n    ]\n</code></pre>"},{"location":"interface/#ethopy.core.interface.SetupConfiguration.Screen","title":"<code>Screen</code>","text":"<p>               Bases: <code>Lookup</code>, <code>Part</code></p> <p>Screen configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Screen(dj.Lookup, dj.Part):\n    \"\"\"Screen configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Screen information\n    screen_idx               : tinyint\n    -&gt; SetupConfiguration\n    ---\n    intensity                : tinyint UNSIGNED\n    distance                 : float\n    center_x                 : float\n    center_y                 : float\n    aspect                   : float\n    size                     : float\n    fps                      : tinyint UNSIGNED\n    resolution_x             : smallint\n    resolution_y             : smallint\n    description              : varchar(256)\n    fullscreen               : tinyint\n    \"\"\"\n\n    contents = [\n        [1, 0, 64, 5.0, 0, -0.1, 1.66, 7.0, 30, 800, 480, \"Simulation\", 0],\n    ]\n</code></pre>"},{"location":"interface/#ethopy.core.interface.SetupConfiguration.Speaker","title":"<code>Speaker</code>","text":"<p>               Bases: <code>Lookup</code>, <code>Part</code></p> <p>Speaker configuration table.</p> Source code in <code>src/ethopy/core/interface.py</code> <pre><code>class Speaker(dj.Lookup, dj.Part):\n    \"\"\"Speaker configuration table.\"\"\"\n\n    definition = \"\"\"\n    # Speaker information\n    speaker_idx             : tinyint\n    -&gt; SetupConfiguration\n    ---\n    sound_freq=10000        : int           # in Hz\n    duration=500            : int           # in ms\n    volume=50               : tinyint       # 0-100 percentage\n    discription             : varchar(256)\n    \"\"\"\n</code></pre>"},{"location":"local_conf/","title":"EthoPy Configuration Guide","text":""},{"location":"local_conf/#quick-start","title":"Quick Start","text":"<pre><code>from ethopy.core.config import ConfigurationManager\n\n# Initialize with default configuration\nconfig = ConfigurationManager()\n\n# Get a configuration value\ndb_host = config.get('database.host')\n\n# Set a configuration value\nconfig.set('logging.level', 'DEBUG')\n\n# Save changes\nconfig.save()\n</code></pre>"},{"location":"local_conf/#configuration-file-location","title":"Configuration File Location","text":"<p>The configuration file is stored in: - Linux/macOS: <code>~/.ethopy/local_conf.json</code> - Windows: <code>%USERPROFILE%\\.ethopy\\local_conf.json</code></p>"},{"location":"local_conf/#basic-configuration-structure","title":"Basic Configuration Structure","text":"<pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"127.0.0.1\",\n        \"database.user\": \"root\",\n        \"database.password\": \"your_password\",\n        \"database.port\": 3306\n    },\n    \"source_path\": \"/path/to/data\",\n    \"target_path\": \"/path/to/backup\",\n    \"logging\": {\n        \"level\": \"INFO\",\n        \"directory\": \"~/.ethopy/\",\n        \"filename\": \"ethopy.log\"\n    }\n}\n</code></pre>"},{"location":"local_conf/#using-the-configuration-manager","title":"Using the Configuration Manager","text":""},{"location":"local_conf/#basic-operations","title":"Basic Operations","text":"<pre><code># Initialize\nconfig = ConfigurationManager()\n\n# Get values (with optional default)\ndb_host = config.get('database.host', 'localhost')\nlog_level = config.get('logging.level', 'INFO')\n\n# Set values\nconfig.set('database.password', 'new_password')\n\n# Save changes\nconfig.save()\n\n# Get complete DataJoint config\ndj_config = config.get_datajoint_config()\n</code></pre>"},{"location":"local_conf/#working-with-paths","title":"Working with Paths","text":"<pre><code># Get standard paths\nsource = config.get('source_path')\ntarget = config.get('target_path')\n\n# Create directories automatically\nfrom pathlib import Path\nPath(source).mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"local_conf/#advanced-usage","title":"Advanced Usage","text":""},{"location":"local_conf/#environment-variables-override","title":"Environment Variables Override","text":"<p>Set environment variables to override configuration:</p> <pre><code>export ETHOPY_DB_PASSWORD=\"secret\"\nexport ETHOPY_SOURCE_PATH=\"/custom/path\"\n</code></pre>"},{"location":"local_conf/#custom-configuration-file","title":"Custom Configuration File","text":"<pre><code>config = ConfigurationManager(config_file=\"custom_config.json\")\n</code></pre>"},{"location":"local_conf/#configuration-validation","title":"Configuration Validation","text":"<p>The ConfigurationManager automatically validates and sets defaults for: - Database connection settings - Schema names - Logging configuration - Required paths</p>"},{"location":"local_conf/#configuration-sections","title":"Configuration Sections","text":""},{"location":"local_conf/#database-settings-dj_local_conf","title":"Database Settings (<code>dj_local_conf</code>)","text":"<p>Essential settings for DataJoint database connection:</p> <pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"127.0.0.1\",\n        \"database.user\": \"root\",\n        \"database.password\": \"password\",\n        \"database.port\": 3306,\n        \"database.reconnect\": true,\n        \"database.use_tls\": false,\n        \"datajoint.loglevel\": \"WARNING\"\n    }\n}\n</code></pre>"},{"location":"local_conf/#schema-mapping-schemata","title":"Schema Mapping (<code>SCHEMATA</code>)","text":"<p>Maps internal schema names to database schemas:</p> <pre><code>{\n    \"SCHEMATA\": {\n        \"experiment\": \"lab_experiments\",\n        \"stimulus\": \"lab_stimuli\",\n        \"behavior\": \"lab_behavior\",\n        \"recording\": \"lab_recordings\",\n    }\n}\n</code></pre>"},{"location":"local_conf/#logging-configuration","title":"Logging Configuration","text":"<pre><code>{\n    \"logging\": {\n        \"level\": \"INFO\",\n        \"directory\": \"~/.ethopy/\",\n        \"filename\": \"ethopy.log\",\n        \"max_size\": 31457280,\n        \"backup_count\": 5\n    }\n}\n</code></pre>"},{"location":"local_conf/#hardware-channel-configuration-channels","title":"Hardware Channel Configuration (<code>channels</code>)","text":"<p>The <code>channels</code> configuration defines GPIO pin mappings for various hardware components. This is crucial for experiments that involve physical hardware interaction, particularly on Raspberry Pi systems.</p> <pre><code>{\n    \"channels\": {\n        \"Odor\": {\"1\": 24, \"2\": 25},     // Odor delivery valves\n        \"Liquid\": {\"1\": 22, \"2\": 23},    // Liquid reward valves\n        \"Lick\": {\"1\": 17, \"2\": 27},      // Lick detection sensors\n        \"Proximity\": {\"3\": 9, \"1\": 5, \"2\": 6},  // Proximity sensors\n        \"Sound\": {\"1\": 13},              // Sound output\n        \"Sync\": {                        // Synchronization pins\n            \"in\": 21, \n            \"rec\": 26, \n            \"out\": 16\n        },\n        \"Opto\": 19,                      // Optogenetics control\n        \"Status\": 20                     // Status LED\n    }\n}\n</code></pre>"},{"location":"local_conf/#channel-types-and-their-uses","title":"Channel Types and Their Uses","text":"<ol> <li> <p>Odor Channels</p> <ul> <li>Purpose: Control odor delivery valves</li> <li>Format: <code>{\"port_number\": gpio_pin}</code></li> <li>Example: <code>\"1\": 24</code> maps odor port 1 to GPIO pin 24</li> </ul> </li> <li> <p>Liquid Channels</p> <ul> <li>Purpose: Control water/liquid reward delivery</li> <li>Format: <code>{\"port_number\": gpio_pin}</code></li> <li>Example: <code>\"1\": 22</code> maps liquid port 1 to GPIO pin 22</li> </ul> </li> <li> <p>Lick Channels</p> <ul> <li>Purpose: Detect animal licking behavior</li> <li>Format: <code>{\"port_number\": gpio_pin}</code></li> <li>Example: <code>\"1\": 17</code> maps lick detector 1 to GPIO pin 17</li> </ul> </li> <li> <p>Proximity Channels</p> <ul> <li>Purpose: Detect animal presence/position</li> <li>Format: <code>{\"port_number\": gpio_pin}</code></li> <li>Example: <code>\"3\": 9</code> maps proximity sensor 3 to GPIO pin 9</li> </ul> </li> <li> <p>Sound Channel</p> <ul> <li>Purpose: Control audio output</li> <li>Format: <code>{\"port_number\": gpio_pin}</code></li> <li>Example: <code>\"1\": 13</code> maps sound output to GPIO pin 13</li> </ul> </li> <li> <p>Sync Channels</p> <ul> <li>Purpose: Synchronization with external devices</li> <li>Components:<ul> <li><code>\"in\"</code>: Input synchronization signal</li> <li><code>\"rec\"</code>: Recording trigger</li> <li><code>\"out\"</code>: Output synchronization signal</li> </ul> </li> </ul> </li> <li> <p>Special Channels</p> <ul> <li><code>\"Opto\"</code>: Single pin for optogenetics control</li> <li><code>\"Status\"</code>: LED indicator for system status</li> </ul> </li> </ol>"},{"location":"local_conf/#hardware-setup-considerations","title":"Hardware Setup Considerations","text":"<ol> <li> <p>Pin Conflicts</p> <ul> <li>Ensure no GPIO pin is assigned to multiple channels</li> <li>Check pin capabilities (input/output/PWM support)</li> <li>Avoid system-reserved pins</li> </ul> </li> <li> <p>Safety Checks <pre><code># Example validation\npins_used = set()\nfor device, pins in config.get('channels').items():\n    if isinstance(pins, dict):\n        for pin in pins.values():\n            if pin in pins_used:\n                raise ValueError(f\"Pin {pin} used multiple times\")\n            pins_used.add(pin)\n</code></pre></p> </li> <li> <p>Power Requirements</p> <ul> <li>Consider current limitations of GPIO pins</li> <li>Use appropriate hardware drivers for high-power devices</li> <li>Include safety resistors where needed</li> </ul> </li> </ol>"},{"location":"local_conf/#common-hardware-configurations","title":"Common Hardware Configurations","text":"<ol> <li> <p>Basic Setup (2 ports) <pre><code>{\n    \"Liquid\": {\"1\": 22, \"2\": 23},\n    \"Lick\": {\"1\": 17, \"2\": 27}\n}\n</code></pre></p> </li> <li> <p>Advanced Setup (with all features) <pre><code>{\n    \"Liquid\": {\"1\": 22, \"2\": 23},\n    \"Lick\": {\"1\": 17, \"2\": 27},\n    \"Proximity\": {\"1\": 5, \"2\": 6},\n    \"Odor\": {\"1\": 24, \"2\": 25},\n    \"Sound\": {\"1\": 13},\n    \"Sync\": {\"in\": 21, \"rec\": 26, \"out\": 16},\n    \"Opto\": 19,\n    \"Status\": 20\n}\n</code></pre></p> </li> </ol>"},{"location":"local_conf/#paths-configuration","title":"Paths Configuration","text":"<pre><code>{\n    \"source_path\": \"/path/to/data/source\",\n    \"target_path\": \"/path/to/data/target\",\n    \"plugin_path\": \"/path/to/plugins\"\n}\n</code></pre>"},{"location":"local_conf/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Security</p> <ul> <li>Never commit configuration files with sensitive data</li> <li>Use environment variables for passwords</li> <li>Keep backups of your configuration</li> </ul> </li> <li> <p>Path Management</p> <ul> <li>Use absolute paths when possible</li> <li>Ensure write permissions for logs/data</li> <li>Regularly check available disk space</li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Always check if paths exist before operations</li> <li>Handle missing configuration values gracefully</li> <li>Log configuration changes</li> </ul> </li> </ol>"},{"location":"local_conf/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"local_conf/#database-connection-issues","title":"Database Connection Issues","text":"<p>Problem: Cannot connect to database <pre><code># Check connection settings\nconfig = ConfigurationManager()\nprint(config.get_datajoint_config())\n\n# Verify database is reachable\nimport socket\ns = socket.socket()\ntry:\n    s.connect((config.get('database.host'), config.get('database.port')))\n    print(\"Database reachable\")\nexcept Exception as e:\n    print(f\"Cannot reach database: {e}\")\n</code></pre></p>"},{"location":"local_conf/#path-permission-issues","title":"Path Permission Issues","text":"<p>Problem: Cannot write to paths <pre><code># Check path permissions\nfrom pathlib import Path\n\npath = Path(config.get('source_path'))\nif not path.exists():\n    print(f\"Path does not exist: {path}\")\nelif not os.access(path, os.W_OK):\n    print(f\"Cannot write to path: {path}\")\n</code></pre></p>"},{"location":"local_conf/#future-improvements","title":"Future Improvements","text":"<p>The configuration system is continually being improved. Planned features include:</p> <ol> <li>Schema validation using Pydantic</li> <li>Configuration migration tools</li> <li>GUI configuration editor</li> </ol>"},{"location":"local_conf/#contributing","title":"Contributing","text":"<p>To contribute to the configuration system:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Add tests for new features</li> <li>Submit a pull request</li> </ol>"},{"location":"local_conf/#testing-your-configuration","title":"Testing Your Configuration","text":"<pre><code>from ethopy.core.config import ConfigurationManager\n\ndef test_config():\n    config = ConfigurationManager()\n\n    # Test database connection\n    dj_config = config.get_datajoint_config()\n    assert all(k in dj_config for k in ['database.host', 'database.user'])\n\n    # Test paths\n    assert Path(config.get('source_path')).exists()\n\n    # Test logging\n    assert config.get('logging.level') in ['DEBUG', 'INFO', 'WARNING', 'ERROR']\n\nif __name__ == '__main__':\n    test_config()\n</code></pre>"},{"location":"logger/","title":"Core Logger module","text":"<p>A comprehensive logging system.</p> <p>Managing experimental data, database connections, and data flow control in an experimental setup. It includes functionality for establishing database connections, managing logging sessions, handling data insertion, and synchronizing setup status.</p> <p>Classes:</p> Name Description <code>Logger</code> <p>Manages logging and data handling in an experimental setup.</p> <code>PrioritizedItem</code> <p>Represents an item with a priority for logging purposes.</p> <p>Functions:</p> Name Description <code>_set_connection</code> <p>Establishes connection to the database and initializes global variables for virtual modules.</p>"},{"location":"logger/#ethopy.core.logger.Logger","title":"<code>Logger</code>","text":"<p>Logger class for managing logging and data handling in an experimental setup.</p> <p>This class is designed to handle the logging of experimental data, manage database connections, and control the flow of data from source to target locations. It supports both manual and automatic running modes of a session, integrates with a Python logging setup, and manages threads for data insertion and setup status updates.</p> <p>Attributes:</p> Name Type Description <code>setup</code> <code>str</code> <p>The hostname of the machine running the experiment.</p> <code>is_pi</code> <code>bool</code> <p>Flag indicating if the current machine is a Raspberry Pi.</p> <code>task_idx</code> <code>int</code> <p>Task index</p> <code>task_path</code> <code>str</code> <p>Path to the task file.</p> <code>manual_run</code> <code>bool</code> <p>Flag indicating if the experiment is run manually.</p> <code>setup_status</code> <code>str</code> <p>Current status of the setup (e.g. 'running', 'ready').</p> <code>private_conn</code> <code>Connection</code> <p>Connection for internal database communication.</p> <code>writer</code> <code>Writer</code> <p>Writer class instance for handling data writing.</p> <code>rec_fliptimes</code> <code>bool</code> <p>Flag indicating if flip times should be recorded.</p> <code>trial_key</code> <code>dict</code> <p>Dictionary containing identifiers for the current trial.</p> <code>setup_info</code> <code>dict</code> <p>Dictionary containing setup information.</p> <code>datasets</code> <code>dict</code> <p>Dictionary containing datasets.</p> <code>lock</code> <code>bool</code> <p>Lock flag for thread synchronization.</p> <code>queue</code> <code>PriorityQueue</code> <p>Queue for managing data insertion order.</p> <code>ping_timer</code> <code>Timer</code> <p>Timer for managing pings.</p> <code>logger_timer</code> <code>Timer</code> <p>Timer for managing logging intervals.</p> <code>total_reward</code> <code>int</code> <p>Total reward accumulated.</p> <code>curr_state</code> <code>str</code> <p>Current state of the logger.</p> <code>thread_exception</code> <code>Exception</code> <p>Exception caught in threads, if any.</p> <code>source_path</code> <code>str</code> <p>Path where data are saved.</p> <code>target_path</code> <code>str</code> <p>Path where data will be moved after the session ends.</p> <code>thread_end</code> <code>Event</code> <p>Event to signal thread termination.</p> <code>thread_lock</code> <code>Lock</code> <p>Lock for thread synchronization.</p> <code>inserter_thread</code> <code>Thread</code> <p>Thread for inserting data into the database.</p> <code>getter_thread</code> <code>Thread</code> <p>Thread for periodically updating setup status.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the Logger instance.</p> <code>_check_if_raspberry_pi</code> <p>Checks if the current machine is a Raspberry Pi.</p> <code>_inserter</code> <p>Inserts data into the database.</p> <code>_log_setup_info</code> <p>Logs setup information.</p> <code>_get_setup_status</code> <p>Get setup status.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>class Logger:\n    \"\"\"Logger class for managing logging and data handling in an experimental setup.\n\n    This class is designed to handle the logging of experimental data, manage database\n    connections, and control the flow of data from source to target locations. It\n    supports both manual and automatic running modes of a session, integrates with a\n    Python logging setup, and manages threads for data insertion and setup status\n    updates.\n\n    Attributes:\n        setup (str): The hostname of the machine running the experiment.\n        is_pi (bool): Flag indicating if the current machine is a Raspberry Pi.\n        task_idx (int): Task index\n        task_path (str): Path to the task file.\n        manual_run (bool): Flag indicating if the experiment is run manually.\n        setup_status (str): Current status of the setup (e.g. 'running', 'ready').\n        private_conn (Connection): Connection for internal database communication.\n        writer (Writer): Writer class instance for handling data writing.\n        rec_fliptimes (bool): Flag indicating if flip times should be recorded.\n        trial_key (dict): Dictionary containing identifiers for the current trial.\n        setup_info (dict): Dictionary containing setup information.\n        datasets (dict): Dictionary containing datasets.\n        lock (bool): Lock flag for thread synchronization.\n        queue (PriorityQueue): Queue for managing data insertion order.\n        ping_timer (Timer): Timer for managing pings.\n        logger_timer (Timer): Timer for managing logging intervals.\n        total_reward (int): Total reward accumulated.\n        curr_state (str): Current state of the logger.\n        thread_exception (Exception): Exception caught in threads, if any.\n        source_path (str): Path where data are saved.\n        target_path (str): Path where data will be moved after the session ends.\n        thread_end (Event): Event to signal thread termination.\n        thread_lock (Lock): Lock for thread synchronization.\n        inserter_thread (Thread): Thread for inserting data into the database.\n        getter_thread (Thread): Thread for periodically updating setup status.\n\n    Methods:\n        __init__(task=False): Initializes the Logger instance.\n        _check_if_raspberry_pi(): Checks if the current machine is a Raspberry Pi.\n        _inserter(): Inserts data into the database.\n        _log_setup_info(setup, status): Logs setup information.\n        _get_setup_status(): Get setup status.\n\n    \"\"\"\n\n    def __init__(self, task: bool = False) -&gt; None:\n        \"\"\"Initialize the Logger.\"\"\"\n        self.setup = socket.gethostname()\n        self.is_pi = self._check_if_raspberry_pi()\n\n        self.task = task or Task(path=None, id=None)\n        self.manual_run = bool(self.task.path or self.task.id)\n        self.setup_status = \"running\" if self.manual_run else \"ready\"\n\n        # separate connection for internal communication\n        self._schemata, self.private_conn = create_virtual_modules(\n            SCHEMATA, create_tables=False, create_schema=False\n        )\n\n        self.writer = Writer\n        self.rec_fliptimes = True\n        self.trial_key = {\"animal_id\": 0, \"session\": 1, \"trial_idx\": 0}\n        self.setup_info = {}\n        self.datasets = {}\n        self.lock = False\n        self.queue = PriorityQueue()\n        self.ping_timer = Timer()\n        self.logger_timer = Timer()\n        self.total_reward = 0\n        self.curr_state = \"\"\n        self.thread_exception = None\n        self.update_status = threading.Event()\n        self.update_status.clear()\n\n        # source path is the local path that data are saved\n        self.source_path = local_conf.get(\"source_path\")\n        # target path is the path that data will be moved after the session ends\n        self.target_path = local_conf.get(\"target_path\")\n\n        # inserter_thread read the queue and insert the data in the database\n        self.thread_end, self.thread_lock = threading.Event(), threading.Lock()\n        self.inserter_thread = threading.Thread(target=self._inserter)\n        self.inserter_thread.start()\n\n        # _log_setup_info needs to run after the inserter_thread is started\n        self._log_setup_info(self.setup, self.setup_status)\n\n        # before starting the getter thread we need to _log_setup_info\n        self.update_thread = threading.Thread(target=self._sync_control_table)\n        self.update_thread.start()\n        self.logger_timer.start()\n\n    @property\n    def task_path(self) -&gt; Optional[Path]:\n        \"\"\"Get the task path.\"\"\"\n        return self.task.path\n\n    def get_task(self) -&gt; bool:\n        \"\"\"Get the task configuration.\n\n        Returns:\n            bool: True if task is available and valid\n\n        \"\"\"\n        if not self.manual_run:\n            self.task = resolve_task(task_id=self.get_setup_info(\"task_idx\"))\n\n        return self.task_path is not None\n\n    def _check_if_raspberry_pi(self) -&gt; bool:\n        system = platform.uname()\n        return (\n            system.machine.startswith(\"arm\") or system.machine == \"aarch64\"\n            if system.system == \"Linux\"\n            else False\n        )\n\n    def setup_schema(self, extra_schema: Dict[str, Any]) -&gt; None:\n        \"\"\"Set up additional schema.\n\n        Args:\n            extra_schema (Dict[str, Any]): The additional schema to set up.\n\n        \"\"\"\n        for schema, value in extra_schema.items():\n            globals()[schema] = dj.create_virtual_module(\n                schema, value, create_tables=True, create_schema=True\n            )\n            self._schemata.update(\n                {\n                    schema: dj.create_virtual_module(\n                        schema, value, connection=self.private_conn\n                    )\n                }\n            )\n\n    def put(self, **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"Put an item in the queue.\n\n        This method creates a `PrioritizedItem` from the given keyword arguments and\n        puts it into the queue. After putting an item in the queue, it checks the\n        'block' attribute of the item. If 'block' is False, it marks the item as\n        processed by calling `task_done()`. This is useful in scenarios where items are\n        processed asynchronously, and the queue needs to be notified that a task is\n        complete. If 'block' is True, it waits for all items in the queue to be\n        processed by calling `join()`.\n\n        Args:\n            **kwargs (Any): The keyword arguments used to create a `PrioritizedItem` and\n                put it in the queue.\n\n        \"\"\"\n        item = PrioritizedItem(**kwargs)\n        self.queue.put(item)\n        if not item.block:\n            self.queue.task_done()\n        else:\n            self.queue.join()\n\n    def _insert_item(self, item, table) -&gt; None:\n        \"\"\"Insert an item into the specified table.\n\n        Args:\n            item: The item to be inserted.\n            table: The table to insert the item into.\n\n        Returns:\n            None\n\n        \"\"\"\n        table.insert1(\n            item.tuple,\n            ignore_extra_fields=item.ignore_extra_fields,\n            skip_duplicates=False if item.replace else True,\n            replace=item.replace,\n        )\n\n    def _validate_item(self, item, table) -&gt; None:\n        \"\"\"Validate an item against a table.\"\"\"\n        if item.validate:  # validate tuple exists in database\n            key = {k: v for (k, v) in item.tuple.items() if k in table.primary_key}\n            if \"status\" in item.tuple.keys():\n                key[\"status\"] = item.tuple[\"status\"]\n            while not len(table &amp; key) &gt; 0:\n                time.sleep(0.5)\n\n    def _handle_insert_error(self, item, table, exception, queue) -&gt; None:\n        \"\"\"Handle databse insert errors.\n\n        Handles an error by logging the error message, set the item.error=True, increase\n        priority and add the item again in the queue for re-trying to insert later.\n\n        Args:\n            item : Description of parameter `item`.\n            table : Description of parameter `table`.\n            exception (Exception): The exception that was raised.\n            thread_end : Description of parameter `thread_end`.\n            queue : Description of parameter `queue`.\n\n        \"\"\"\n        log.warning(\n            \"Failed to insert:\\n%s in %s\\n With error:%s\\nWill retry later\",\n            item.tuple,\n            table,\n            exception,\n            exc_info=True,\n        )\n        item.error = True\n        item.priority = item.priority + 2\n        queue.put(item)\n\n    @contextmanager\n    def acquire_lock(self, lock):  # noqa: ANN201\n        \"\"\"Acquire a lock, yield control, and release the lock.\n\n        This context manager ensures that the given lock is acquired before\n        entering the block of code and released after exiting the block, even\n        if an exception is raised within the block.\n\n        Args:\n            lock (threading.Lock): The lock object to acquire and release.\n\n        \"\"\"\n        lock.acquire()\n        try:\n            yield\n        finally:\n            lock.release()\n\n    def _inserter(self) -&gt; None:\n        \"\"\"Insert continuously items from the queue into their respective tables.\n\n        It runs in a loop until the thread_end event is set. In each iteration, it\n        checks if the queue is empty. If it is, it sleeps for 0.5 seconds and then\n        continues to the next iteration.\n        If the queue is not empty, it gets an item from the queue, acquires the thread\n        lock, and tries to insert the item into it's table.\n        If an error occurs during the insertion, it handles the error. After the\n        insertion, it releases the thread lock. If the item was marked to block, it\n        marks the task as done.\n\n        Returns:\n            None\n\n        \"\"\"\n        while not self.thread_end.is_set():\n            if self.queue.empty():\n                time.sleep(0.5)\n                continue\n            item = self.queue.get()\n            table = rgetattr(self._schemata[item.schema], item.table)\n            with self.acquire_lock(self.thread_lock):\n                try:\n                    self._insert_item(item, table)\n                    self._validate_item(item, table)\n                except Exception as insert_error:\n                    if item.error:\n                        self.thread_end.set()\n                        log.error(\n                            \"Second time failed to insert:\\n %s in %s With error:\\n %s\",\n                            item.tuple,\n                            table,\n                            insert_error,\n                            exc_info=True,\n                        )\n                        self.thread_exception = insert_error\n                        break\n                    self._handle_insert_error(item, table, insert_error, self.queue)\n            if item.block:\n                self.queue.task_done()\n\n    def _sync_control_table(self, update_period: float = 5000) -&gt; None:\n        \"\"\"Synchronize the Control table.\n\n        Synchronize the Control table by continuously fetching the setup status\n        from the experiment schema and periodically updating the setup info.\n\n        Runs in a loop until the thread_end event is set.\n\n        Args:\n            update_period (float): Time in milliseconds between Control table updates.\n\n        \"\"\"\n        while not self.thread_end.is_set():\n            with self.thread_lock:\n                if self.update_status.is_set():\n                    continue\n                try:\n                    self._fetch_setup_info()\n                    self._update_setup_info(update_period)\n                except Exception as error:\n                    log.exception(\"Error during Control table sync: %s\", error)\n                    self.thread_exception = error\n\n            time.sleep(1)  # Cycle once a second\n\n    def _fetch_setup_info(self) -&gt; None:\n        self.setup_info = (\n            self._schemata[\"experiment\"].Control() &amp; {\"setup\": self.setup}\n        ).fetch1()\n        self.setup_status = self.setup_info[\"status\"]\n\n    def _update_setup_info(self, update_period: float) -&gt; None:\n        \"\"\"Update the setup information if the elapsed time exceeds the update period.\n\n        This method checks if the elapsed time since the last ping exceeds the given\n        update period. If it does, it resets the ping timer and updates the setup\n        information with the current state, queue size, trial index, total liquid\n        reward, and the current timestamp. The updated information is then stored\n        in the \"Control\" table with a priority of 1.\n        \"\"\"\n        if self.ping_timer.elapsed_time() &gt;= update_period:\n            self.ping_timer.start()\n            info = {\n                \"last_ping\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"queue_size\": self.queue.qsize(),\n                \"trials\": self.trial_key[\"trial_idx\"],\n                \"total_liquid\": self.total_reward,\n                \"state\": self.curr_state,\n            }\n            self.setup_info.update(info)\n            self.put(table=\"Control\", tuple=self.setup_info, replace=True, priority=1)\n\n    def log(\n        self,\n        table: str,\n        data: Optional[Dict[str, Any]] = None,\n        **kwargs: Dict[str, Any],\n    ) -&gt; float:\n        \"\"\"Log the given data into the specified table in the experiment database.\n\n        It first gets the elapsed time from the logger timer and adds it to the data\n        dictionary. It then puts the data into the specified table.\n\n        Args:\n            table (str): The name of the table in the experiment database.\n            data (dict, optional): The data to be logged. Defaults to an empty\n                dictionary.\n            **kwargs: Additional keyword arguments to be passed to the put method.\n\n        Returns:\n            float: The elapsed time from the logger timer.\n\n        \"\"\"\n        tmst = self.logger_timer.elapsed_time()\n        data = data or {}  # if data is None or False use an empty dictionary\n        self.put(table=table, tuple={**self.trial_key, \"time\": tmst, **data}, **kwargs)\n        if table == \"Trial.StateOnset\":\n            log.info(\"State: %s\", data[\"state\"])\n        return tmst\n\n    def _log_setup_info(self, setup: str, setup_status: str = \"running\") -&gt; None:\n        \"\"\"Log setup information into the Control table in the experiment database.\n\n        It first fetches the control information for the current setup. If no control\n        information is found, it creates a new dictionary with the setup information.\n        It then adds the IP and status information to the key.\n\n        The method finally puts the key into the Control table, replacing any existing\n        entry. Because it blocks the queue until the operation is complete it needs the\n        inserter_thread to be running.\n\n        Args:\n            setup (str): The setup name.\n            setup_status (str): The current status fo the setup. Defaults to running.\n\n        Returns:\n            None\n\n        \"\"\"\n        rel = experiment.Control() &amp; dict(setup=setup)\n        key = rel.fetch1() if np.size(rel.fetch()) else dict(setup=setup)\n        key = {**key, \"ip\": self.get_ip(), \"status\": setup_status}\n        self.put(\n            table=\"Control\",\n            tuple=key,\n            replace=True,\n            priority=1,\n            block=True,\n            validate=True,\n        )\n\n    def _get_last_session(self) -&gt; int:\n        \"\"\"Fetch last session for a given animal_id from the experiment.\n\n        It first fetches all sessions for the given animal_id. If no sessions are found,\n        it returns 0.\n        If sessions are found, it returns the maximum session number, which corresponds\n        to the last session.\n\n        Returns:\n            int: The last session number or 0 if no sessions are found.\n\n        \"\"\"\n        last_sessions = (\n            experiment.Session() &amp; dict(animal_id=self.get_setup_info(\"animal_id\"))\n        ).fetch(\"session\")\n        return 0 if np.size(last_sessions) == 0 else np.max(last_sessions)\n\n    def log_session(\n        self,\n        session_params: Dict[str, Any],\n        experiment_type: str,\n        log_task: bool = False,\n    ) -&gt; None:\n        \"\"\"Log session with the given parameters and optionally log the task.\n\n        Args:\n            session_params (Dict[str, Any]): Parameters for the session.\n            experiment_type (str): current experiment running in session.\n            log_task (bool): Whether to log the task information.\n\n        \"\"\"\n        # Initializes session parameters and logs the session start.\n        self._init_session_params(\n            session_params.get(\"user_name\", \"bot\"), experiment_type\n        )\n\n        # Save the task file, name and the git_hash in the database.\n        if log_task:\n            self._log_task_details()\n\n        # update the configuration tables\n        self.log_session_configs(session_params[\"setup_conf_idx\"])\n\n        #  Init the informations(e.g. trial_id=0, session) in control table\n        self._init_control_table(session_params)\n\n        self.logger_timer.start()  # Start session time\n\n    def _init_session_params(self, user_name: str, experiment_type: str) -&gt; None:\n        \"\"\"Initialize session parameters and log the session start.\n\n        This method initializes the session parameters by setting the total reward to\n        zero and creating a trial key with the animal ID, trial index set to zero, and\n        the session number incremented by one from the last session. It logs the trial\n        key and creates a session key by merging the trial key with the provided session\n        parameters, setup information, and a default or provided user name. The session\n        key is then logged and stored in the database.\n\n        Args:\n            user_name (Dict[str, Any]): A string defininng user.\n            experiment_type: str: name of the expertiment.\n\n        \"\"\"\n        self.total_reward = 0\n        self.trial_key = {\n            \"animal_id\": self.get_setup_info(\"animal_id\"),\n            \"trial_idx\": 0,\n            \"session\": self._get_last_session() + 1,\n        }\n\n        session_key = {\n            \"animal_id\": self.get_setup_info(\"animal_id\"),\n            \"session\": self._get_last_session() + 1,\n            \"user_name\": user_name,\n            \"setup\": self.setup,\n            \"experiment_type\": experiment_type,\n        }\n\n        # Convert np.int64 values to native Python int\n        session_key_cleaned = {\n            k: int(v) if isinstance(v, np.integer) else v\n            for k, v in session_key.items()\n        }\n\n        log.info(\"\\n%s\", figlet_format(\"EthoPy\"))\n        log.info(\n            \"\\n%s%s%s\\n%s\\n%s\",\n            \"-\" * 22,\n            \" Basic Session informations \",\n            \"-\" * 22,\n            \"\\n\".join(f\"{k}: {v}\" for k, v in session_key_cleaned.items()),\n            \"-\" * 72,\n        )\n\n        # Logs the new session id to the database\n        self.put(\n            table=\"Session\", tuple=session_key, priority=1, validate=True, block=True\n        )\n\n    @staticmethod\n    def get_inner_classes_list(outer_class: Any) -&gt; List[str]:\n        \"\"\"Retrieve a list of names of all inner classes defined within an outer class.\n\n        Args:\n            outer_class: The class object of the outer class containing the inner\n                classes.\n\n        Returns:\n            A list of strings, each representing the fully qualified name of an inner\n                class defined within the outer class.\n\n        \"\"\"\n        outer_class_dict_values = outer_class.__dict__.values()\n        inner_classes = [\n            value for value in outer_class_dict_values if isinstance(value, type)\n        ]\n        return [outer_class.__name__ + \".\" + cls.__name__ for cls in inner_classes]\n\n    def log_session_configs(self, setup_conf_idx: int) -&gt; None:\n        \"\"\"Log parameter of a session into the appropriate schema tables.\n\n        This method performs several key operations to ensure that the configuration of\n        a session, including behavior and stimulus settings, is accurately logged into\n        the database. It involves the following steps:\n        1. Identifies the relevant modules (e.g., ethopy.core.interface) that contain\n        Configuration classes.\n        2. Derives schema names from these modules, assuming the schema name matches the\n        class name in lowercase.\n        3. Logs the session and animal_id into the Configuration tables of the\n        identified schemas.\n        4. Creates a dictionary mapping each schema to its respective Configuration\n        class's inner classes.\n        5. Calls a helper method to log the configuration of sub-tables for each schema.\n        \"\"\"\n        # modules that have a Configuration classes\n        _modules = [\"ethopy.core.interface\"]\n        # consider that the module have the same name as the schema but in lower case\n        # (e.g for class Behaviour the schema is the behavior)\n        _schemas = [_module.split(\".\")[2].lower() for _module in _modules]\n\n        # Logs the session and animal_id in configuration tables of behavior/stimulus.\n        for schema in _schemas:\n            self.put(\n                table=\"Configuration\",\n                tuple=self.trial_key,\n                schema=schema,\n                priority=2,\n                validate=True,\n                block=True,\n            )\n\n        # create a dict with the configuration as key and the subclasses as values\n        conf_table_schema = {}\n        for _schema, _module in zip(_schemas, _modules):\n            conf = importlib.import_module(_module).Configuration\n            # Find the inner classes of the class Configuration\n            conf_table_schema[_schema] = self.get_inner_classes_list(conf)\n\n        # update the sub tables of Configuration table\n        for schema, config_tables in conf_table_schema.items():\n            self._log_sub_tables_config(setup_conf_idx, config_tables, schema)\n\n    def _log_sub_tables_config(\n        self, setup_conf_idx: int, config_tables: List[str], schema: str\n    ) -&gt; None:\n        \"\"\"Log conifguration data in the respective tables.\n\n        This method iterates over a list of configuration tables, retrieves the\n        configuration data for each table based on the provided parameters, and then\n        logs this data into the respective table within the given schema.\n\n        Args:\n            setup_conf_idx (int): index indication the setup configuration\n            config_tables (list): The part table to be recorded (e.g., Port, Screen).\n            schema (str): The schema for the configuration.\n\n        \"\"\"\n        for config_table in config_tables:\n            configuration_data = (\n                getattr(interface.SetupConfiguration, config_table.split(\".\")[1])\n                &amp; {\"setup_conf_idx\": setup_conf_idx}\n            ).fetch(as_dict=True)\n            # put the configuration data in the configuration table\n            # it can be a list of configurations (e.g have two ports with different ids)\n            for conf in configuration_data:\n                self.put(\n                    table=config_table,\n                    tuple={**conf, **self.trial_key},\n                    schema=schema,\n                )\n\n    def _init_control_table(self, params: Dict[str, Any]) -&gt; None:\n        \"\"\"Set the control table informations for the setup.\n\n        This method sets various parameters related to the session setup, including\n        session ID, number of trials, total liquid, difficulty level, and state. It also\n        optionally sets start and stop times if they are provided in the `params`\n        argument.\n\n        The start and stop times are expected to be in \"%H:%M:%S\" format. If they are\n        provided, this method calculates the time delta from \"00:00:00\" for each and\n        updates the setup information accordingly.\n\n        Args:\n            params (Dict[str, Any]): A dictionary containing parameters for the session\n            setup. This may include 'start_time' and 'stop_time' among other setup\n            parameters.\n\n        \"\"\"\n        key = {\n            \"session\": self.trial_key[\"session\"],\n            \"trials\": 0,\n            \"total_liquid\": 0,\n            \"difficulty\": 1,\n            \"state\": \"\",\n        }\n        #  TODO if task is the path of the config there is no update in Control table\n        if self.task.id and isinstance(self.task.id, int):\n            key[\"task_idx\"] = self.task.id\n\n        # if in the start_time is defined in the configuration use this\n        # otherwise use the Control table\n        if \"start_time\" in params:\n\n            def _tdelta(t: str) -&gt; datetime:\n                return datetime.strptime(t, \"%H:%M:%S\") - datetime.strptime(\n                    \"00:00:00\", \"%H:%M:%S\"\n                )\n\n            key.update(\n                {\n                    \"start_time\": str(_tdelta(params[\"start_time\"])),\n                    \"stop_time\": str(_tdelta(params[\"stop_time\"])),\n                }\n            )\n\n        self.update_setup_info({**key, \"status\": self.setup_info[\"status\"]})\n\n    def update_setup_info(\n        self, info: Dict[str, Any], key: Optional[Dict[str, Any]] = None\n    ) -&gt; None:\n        \"\"\"Update the setup information in Control table with the provided info and key.\n\n        It first fetches the existing setup information from the experiment's Control\n        table, then updates it with the provided info. If 'status' is in the provided\n        info, it blocks and validates the update operation.\n\n        Args:\n            info (dict): The information to update the setup with.\n            key (dict, optional): Additional keys to fetch the setup information with.\n                Defaults to None.\n\n        Side Effects:\n            Updates the setup_info attribute with the new setup information.\n            Updates the setup_status attribute with the new status.\n\n        \"\"\"\n        if self.thread_exception:\n            self.thread_exception = None\n            raise Exception(\"Thread exception occurred: %s\", self.thread_exception)\n        if key is None:\n            key = dict()\n\n        if not public_conn.is_connected:\n            _set_connection()\n\n        block = True if \"status\" in info else False\n        if block:\n            self.update_status.set()\n            caller = inspect.stack()[1]\n            caller_info = (\n                f\"Function called by {caller.function} \"\n                f\"in {caller.filename} at line {caller.lineno}\"\n            )\n            log.debug(\"Update status is set %s\\n%s\", info[\"status\"], caller_info)\n\n        self.setup_info = {\n            **(experiment.Control() &amp; {\"setup\": self.setup, **key}).fetch1(),\n            **info,\n        }\n\n        char_len = 255\n        if \"notes\" in info and len(info[\"notes\"]) &gt; char_len:\n            info[\"notes\"] = info[\"notes\"][:char_len]\n\n        self.put(\n            table=\"Control\",\n            tuple=self.setup_info,\n            replace=True,\n            priority=1,\n            block=block,\n            validate=block,\n        )\n        self.setup_status = self.setup_info[\"status\"]\n        self.update_status.clear()\n\n    def _log_task_details(self) -&gt; None:\n        \"\"\"Save the task file, name and git_hash in the database.\"\"\"\n        version_info = get_code_version_info()\n        self.put(table=\"Session.Version\", tuple={**self.trial_key, **version_info})\n        log.debug(f\"Code version: {version_info}\")\n\n        env_info = get_environment_info()\n        self.put(table=\"Session.Enviroment\", tuple={**self.trial_key, **env_info})\n        log.debug(f\"Enviroment info: {env_info}\")\n\n        for path in plugin_manager.plugin_paths:\n            plugin_version_info = get_code_version_info(path)\n            if plugin_version_info[\"source_type\"] is None:\n                log.warning(f\"Plugin {path} is not a git repository\")\n            else:\n                log.debug(f\"Plugin code version: {plugin_version_info}\")\n            self.put(\n                table=\"Session.Version\", tuple={**self.trial_key, **plugin_version_info}\n            )\n\n        self.put(\n            table=\"Session.Task\",\n            tuple={\n                **self.trial_key,\n                \"task_name\": self.task_path,\n                \"task_file\": np.fromfile(self.task_path, dtype=np.int8),\n                \"git_hash\": version_info[\"version\"],\n            },\n        )\n\n    def get_setup_info(self, field: str) -&gt; np.int64:\n        \"\"\"Retrieve specific setup information from an experiment control table.\n\n        Args:\n            field (str): The name of the field to fetch from the experiment control\n                setup.\n\n        Returns:\n            The value of the specified field from the experiment control setup.\n\n        \"\"\"\n        return (experiment.Control() &amp; dict(setup=self.setup)).fetch1(field)\n\n    def get(\n        self,\n        schema: str = \"experiment\",\n        table: str = \"Control\",\n        fields: Optional[List] = None,\n        key: Optional[Dict] = None,\n        **kwargs: Dict[str, Any],\n    ) -&gt; np.ndarray:\n        \"\"\"Fetch data from a specified table in a schema.\n\n        Args:\n            schema (str): The schema to fetch data from. Defaults to \"experiment\".\n            table (str): The table to fetch data from. Defaults to \"Control\".\n            fields (dict): The fields to fetch. Defaults to \"\".\n            key (dict): The key used to fetch data. Defaults to an empty dict.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            (numpy.ndarray): The fetched data.\n\n        \"\"\"\n        if key is None:\n            key = dict()\n        if fields is None:\n            fields = []\n        table = rgetattr(eval(schema), table)  # noqa: S307\n        return (table() &amp; key).fetch(*fields, **kwargs)\n\n    def get_table_keys(\n        self,\n        schema: str = \"experiment\",\n        table: str = \"Control\",\n        key: Optional[Dict] = None,\n        key_type: Optional[str] = None,\n    ) -&gt; List[str]:\n        \"\"\"Retrieve the primary key of a specified table within a given schema.\n\n        Args:\n            schema (str): The schema name where the table is located. Default is\n                'experiment'.\n            table (str): The table name from which to retrieve the keys. Default is\n                'Control'.\n            key (dict): A dict with the key to filter the table. Default is an empty\n                dictionary.\n            key_type (str): type of keys to return from the table\n\n        Returns:\n            list: The primary key of the specified table.\n\n        \"\"\"\n        if key is None:\n            key = []\n        table = rgetattr(globals()[schema], table)  # noqa: S307\n        if key_type == \"primary\":\n            return (table() &amp; key).primary_key\n        return (table() &amp; key).heading.names\n\n    def update_trial_idx(self, trial_idx: int) -&gt; None:\n        \"\"\"Update trial index.\n\n        Updates the trial index in the trial_key dictionary and check if there is any\n        exception in the threads.\n\n        Args:\n            trial_idx (int): The new trial index to be updated.\n\n        \"\"\"\n        self.trial_key[\"trial_idx\"] = trial_idx\n        log.info(\"\\nTrial idx: %s\", self.trial_key[\"trial_idx\"])\n        if self.thread_exception:\n            self.thread_exception = None\n            raise Exception(\"Thread exception occurred: %s\", self.thread_exception)\n\n    def cleanup(self) -&gt; None:\n        \"\"\"Wait for the logging queue to be empty and signals the logging thread to end.\n\n        This method checks if the logging queue is empty, and if not, it waits until it\n        becomes empty. Once the queue is empty, it sets the thread_end event to signal\n        the logging thread to terminate.\n        \"\"\"\n        while not self.queue.empty() and not self.thread_end.is_set():\n            log.info(\"Waiting for empty queue... qsize: %d\", self.queue.qsize())\n            time.sleep(1)\n        self.thread_end.set()\n\n        if not self.queue.empty():\n            log.warning(\"Clean up finished but queue size is: %d\", self.queue.qsize())\n\n    def createDataset(\n        self,\n        dataset_name: str,\n        dataset_type: type,\n        filename: Optional[str] = None,\n        db_log: Optional[bool] = True,\n    ) -&gt; Dict:\n        \"\"\"Create a dataset and return the dataset object.\n\n        Args:\n            dataset_name (str): The name of the dataset.\n            dataset_type (type): The datatype of the dataset.\n            filename (str, optional): The filename for the h5 file. If not provided,\n                a default filename will be generated based on the dataset name,\n                animal ID, session, and current timestamp.\n            db_log (bool, optional): If True call the log_recording\n\n        Returns:\n            Tuple[str, Any]: A tuple containing the filename and the dataset object.\n\n        \"\"\"\n        folder = (\n            f\"Recordings/{self.trial_key['animal_id']}_{self.trial_key['session']}/\"\n        )\n        path = self.source_path + folder\n        if not os.path.isdir(path):\n            os.makedirs(path)  # create path if necessary\n\n        if not os.path.isdir(self.target_path):\n            log.info(\"No target directory set! Autocopying will not work.\")\n            target_path = False\n        else:\n            target_path = self.target_path + folder\n            if not os.path.isdir(target_path):\n                os.makedirs(target_path)\n\n        # Generate filename if not provided\n        if filename is None:\n            filename = (\n                f\"{dataset_name}_{self.trial_key['animal_id']}_\"\n                f\"{self.trial_key['session']}_\"\n                f\"{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.h5\"\n            )\n        if filename not in self.datasets:\n            # create h5 file if not exists\n            self.datasets[filename] = self.writer(path + filename, target_path)\n\n        # create new dataset in the h5 files\n        self.datasets[filename].createDataset(\n            dataset_name, shape=(1,), dtype=dataset_type\n        )\n\n        if db_log:\n            rec_key = dict(\n                rec_aim=dataset_name,\n                software=\"EthoPy\",\n                version=__version__,\n                filename=filename,\n                source_path=path,\n                target_path=target_path,\n            )\n            self.log_recording(rec_key)\n\n        return self.datasets[filename]\n\n    def log_recording(self, rec_key: Dict) -&gt; None:\n        \"\"\"Log a new recording entry with an incremented recording index.\n\n        This method retrieves the current recordings associated with the trial,\n        calculates the next recording index (rec_idx) by finding the maximum\n        recording index and adding one, and logs the new recording entry with\n        the provided recording key (rec_key) and the calculated recording index.\n\n        Args:\n            rec_key (dict): A dictionary containing the key information for the\n                recording entry.\n\n        The method assumes the existence of a `get` method to retrieve existing\n        recordings and a `log` method to log the new recording entry.\n\n        \"\"\"\n        recs = self.get(\n            schema=\"recording\",\n            table=\"Recording\",\n            key=self.trial_key,\n            fields=[\"rec_idx\"],\n        )\n        rec_idx = 1 if not recs else max(recs) + 1\n        self.log(\"Recording\", data={**rec_key, \"rec_idx\": rec_idx}, schema=\"recording\")\n\n    def closeDatasets(self) -&gt; None:\n        \"\"\"Close all datasets managed by this instance.\n\n        Iterates through the datasets dictionary, calling the `exit` method on each\n        dataset object to properly close them.\n        \"\"\"\n        for _, dataset in self.datasets.items():\n            dataset.exit()\n\n    @staticmethod\n    def get_ip() -&gt; str:\n        \"\"\"Retrieve the local IP address of the machine.\n\n        Attempts to establish a dummy connection to a public DNS server (8.8.8.8) to\n        determine the local network IP address of the machine. If the connection fails,\n        defaults to localhost (127.0.0.1).\n\n        Returns:\n            str: The local IP address.\n\n        \"\"\"\n        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        try:\n            s.connect((\"8.8.8.8\", 80))\n            ip = s.getsockname()[0]\n        except Exception:\n            ip = \"127.0.0.1\"\n        finally:\n            s.close()\n        return ip\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.task_path","title":"<code>task_path</code>  <code>property</code>","text":"<p>Get the task path.</p>"},{"location":"logger/#ethopy.core.logger.Logger.__init__","title":"<code>__init__(task=False)</code>","text":"<p>Initialize the Logger.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def __init__(self, task: bool = False) -&gt; None:\n    \"\"\"Initialize the Logger.\"\"\"\n    self.setup = socket.gethostname()\n    self.is_pi = self._check_if_raspberry_pi()\n\n    self.task = task or Task(path=None, id=None)\n    self.manual_run = bool(self.task.path or self.task.id)\n    self.setup_status = \"running\" if self.manual_run else \"ready\"\n\n    # separate connection for internal communication\n    self._schemata, self.private_conn = create_virtual_modules(\n        SCHEMATA, create_tables=False, create_schema=False\n    )\n\n    self.writer = Writer\n    self.rec_fliptimes = True\n    self.trial_key = {\"animal_id\": 0, \"session\": 1, \"trial_idx\": 0}\n    self.setup_info = {}\n    self.datasets = {}\n    self.lock = False\n    self.queue = PriorityQueue()\n    self.ping_timer = Timer()\n    self.logger_timer = Timer()\n    self.total_reward = 0\n    self.curr_state = \"\"\n    self.thread_exception = None\n    self.update_status = threading.Event()\n    self.update_status.clear()\n\n    # source path is the local path that data are saved\n    self.source_path = local_conf.get(\"source_path\")\n    # target path is the path that data will be moved after the session ends\n    self.target_path = local_conf.get(\"target_path\")\n\n    # inserter_thread read the queue and insert the data in the database\n    self.thread_end, self.thread_lock = threading.Event(), threading.Lock()\n    self.inserter_thread = threading.Thread(target=self._inserter)\n    self.inserter_thread.start()\n\n    # _log_setup_info needs to run after the inserter_thread is started\n    self._log_setup_info(self.setup, self.setup_status)\n\n    # before starting the getter thread we need to _log_setup_info\n    self.update_thread = threading.Thread(target=self._sync_control_table)\n    self.update_thread.start()\n    self.logger_timer.start()\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._get_last_session","title":"<code>_get_last_session()</code>","text":"<p>Fetch last session for a given animal_id from the experiment.</p> <p>It first fetches all sessions for the given animal_id. If no sessions are found, it returns 0. If sessions are found, it returns the maximum session number, which corresponds to the last session.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The last session number or 0 if no sessions are found.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _get_last_session(self) -&gt; int:\n    \"\"\"Fetch last session for a given animal_id from the experiment.\n\n    It first fetches all sessions for the given animal_id. If no sessions are found,\n    it returns 0.\n    If sessions are found, it returns the maximum session number, which corresponds\n    to the last session.\n\n    Returns:\n        int: The last session number or 0 if no sessions are found.\n\n    \"\"\"\n    last_sessions = (\n        experiment.Session() &amp; dict(animal_id=self.get_setup_info(\"animal_id\"))\n    ).fetch(\"session\")\n    return 0 if np.size(last_sessions) == 0 else np.max(last_sessions)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._handle_insert_error","title":"<code>_handle_insert_error(item, table, exception, queue)</code>","text":"<p>Handle databse insert errors.</p> <p>Handles an error by logging the error message, set the item.error=True, increase priority and add the item again in the queue for re-trying to insert later.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>Description of parameter <code>item</code>.</p> required <code>table</code> <p>Description of parameter <code>table</code>.</p> required <code>exception</code> <code>Exception</code> <p>The exception that was raised.</p> required <code>thread_end</code> <p>Description of parameter <code>thread_end</code>.</p> required <code>queue</code> <p>Description of parameter <code>queue</code>.</p> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _handle_insert_error(self, item, table, exception, queue) -&gt; None:\n    \"\"\"Handle databse insert errors.\n\n    Handles an error by logging the error message, set the item.error=True, increase\n    priority and add the item again in the queue for re-trying to insert later.\n\n    Args:\n        item : Description of parameter `item`.\n        table : Description of parameter `table`.\n        exception (Exception): The exception that was raised.\n        thread_end : Description of parameter `thread_end`.\n        queue : Description of parameter `queue`.\n\n    \"\"\"\n    log.warning(\n        \"Failed to insert:\\n%s in %s\\n With error:%s\\nWill retry later\",\n        item.tuple,\n        table,\n        exception,\n        exc_info=True,\n    )\n    item.error = True\n    item.priority = item.priority + 2\n    queue.put(item)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._init_control_table","title":"<code>_init_control_table(params)</code>","text":"<p>Set the control table informations for the setup.</p> <p>This method sets various parameters related to the session setup, including session ID, number of trials, total liquid, difficulty level, and state. It also optionally sets start and stop times if they are provided in the <code>params</code> argument.</p> <p>The start and stop times are expected to be in \"%H:%M:%S\" format. If they are provided, this method calculates the time delta from \"00:00:00\" for each and updates the setup information accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Dict[str, Any]</code> <p>A dictionary containing parameters for the session</p> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _init_control_table(self, params: Dict[str, Any]) -&gt; None:\n    \"\"\"Set the control table informations for the setup.\n\n    This method sets various parameters related to the session setup, including\n    session ID, number of trials, total liquid, difficulty level, and state. It also\n    optionally sets start and stop times if they are provided in the `params`\n    argument.\n\n    The start and stop times are expected to be in \"%H:%M:%S\" format. If they are\n    provided, this method calculates the time delta from \"00:00:00\" for each and\n    updates the setup information accordingly.\n\n    Args:\n        params (Dict[str, Any]): A dictionary containing parameters for the session\n        setup. This may include 'start_time' and 'stop_time' among other setup\n        parameters.\n\n    \"\"\"\n    key = {\n        \"session\": self.trial_key[\"session\"],\n        \"trials\": 0,\n        \"total_liquid\": 0,\n        \"difficulty\": 1,\n        \"state\": \"\",\n    }\n    #  TODO if task is the path of the config there is no update in Control table\n    if self.task.id and isinstance(self.task.id, int):\n        key[\"task_idx\"] = self.task.id\n\n    # if in the start_time is defined in the configuration use this\n    # otherwise use the Control table\n    if \"start_time\" in params:\n\n        def _tdelta(t: str) -&gt; datetime:\n            return datetime.strptime(t, \"%H:%M:%S\") - datetime.strptime(\n                \"00:00:00\", \"%H:%M:%S\"\n            )\n\n        key.update(\n            {\n                \"start_time\": str(_tdelta(params[\"start_time\"])),\n                \"stop_time\": str(_tdelta(params[\"stop_time\"])),\n            }\n        )\n\n    self.update_setup_info({**key, \"status\": self.setup_info[\"status\"]})\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._init_session_params","title":"<code>_init_session_params(user_name, experiment_type)</code>","text":"<p>Initialize session parameters and log the session start.</p> <p>This method initializes the session parameters by setting the total reward to zero and creating a trial key with the animal ID, trial index set to zero, and the session number incremented by one from the last session. It logs the trial key and creates a session key by merging the trial key with the provided session parameters, setup information, and a default or provided user name. The session key is then logged and stored in the database.</p> <p>Parameters:</p> Name Type Description Default <code>user_name</code> <code>Dict[str, Any]</code> <p>A string defininng user.</p> required <code>experiment_type</code> <code>str</code> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _init_session_params(self, user_name: str, experiment_type: str) -&gt; None:\n    \"\"\"Initialize session parameters and log the session start.\n\n    This method initializes the session parameters by setting the total reward to\n    zero and creating a trial key with the animal ID, trial index set to zero, and\n    the session number incremented by one from the last session. It logs the trial\n    key and creates a session key by merging the trial key with the provided session\n    parameters, setup information, and a default or provided user name. The session\n    key is then logged and stored in the database.\n\n    Args:\n        user_name (Dict[str, Any]): A string defininng user.\n        experiment_type: str: name of the expertiment.\n\n    \"\"\"\n    self.total_reward = 0\n    self.trial_key = {\n        \"animal_id\": self.get_setup_info(\"animal_id\"),\n        \"trial_idx\": 0,\n        \"session\": self._get_last_session() + 1,\n    }\n\n    session_key = {\n        \"animal_id\": self.get_setup_info(\"animal_id\"),\n        \"session\": self._get_last_session() + 1,\n        \"user_name\": user_name,\n        \"setup\": self.setup,\n        \"experiment_type\": experiment_type,\n    }\n\n    # Convert np.int64 values to native Python int\n    session_key_cleaned = {\n        k: int(v) if isinstance(v, np.integer) else v\n        for k, v in session_key.items()\n    }\n\n    log.info(\"\\n%s\", figlet_format(\"EthoPy\"))\n    log.info(\n        \"\\n%s%s%s\\n%s\\n%s\",\n        \"-\" * 22,\n        \" Basic Session informations \",\n        \"-\" * 22,\n        \"\\n\".join(f\"{k}: {v}\" for k, v in session_key_cleaned.items()),\n        \"-\" * 72,\n    )\n\n    # Logs the new session id to the database\n    self.put(\n        table=\"Session\", tuple=session_key, priority=1, validate=True, block=True\n    )\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._insert_item","title":"<code>_insert_item(item, table)</code>","text":"<p>Insert an item into the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <p>The item to be inserted.</p> required <code>table</code> <p>The table to insert the item into.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _insert_item(self, item, table) -&gt; None:\n    \"\"\"Insert an item into the specified table.\n\n    Args:\n        item: The item to be inserted.\n        table: The table to insert the item into.\n\n    Returns:\n        None\n\n    \"\"\"\n    table.insert1(\n        item.tuple,\n        ignore_extra_fields=item.ignore_extra_fields,\n        skip_duplicates=False if item.replace else True,\n        replace=item.replace,\n    )\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._inserter","title":"<code>_inserter()</code>","text":"<p>Insert continuously items from the queue into their respective tables.</p> <p>It runs in a loop until the thread_end event is set. In each iteration, it checks if the queue is empty. If it is, it sleeps for 0.5 seconds and then continues to the next iteration. If the queue is not empty, it gets an item from the queue, acquires the thread lock, and tries to insert the item into it's table. If an error occurs during the insertion, it handles the error. After the insertion, it releases the thread lock. If the item was marked to block, it marks the task as done.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _inserter(self) -&gt; None:\n    \"\"\"Insert continuously items from the queue into their respective tables.\n\n    It runs in a loop until the thread_end event is set. In each iteration, it\n    checks if the queue is empty. If it is, it sleeps for 0.5 seconds and then\n    continues to the next iteration.\n    If the queue is not empty, it gets an item from the queue, acquires the thread\n    lock, and tries to insert the item into it's table.\n    If an error occurs during the insertion, it handles the error. After the\n    insertion, it releases the thread lock. If the item was marked to block, it\n    marks the task as done.\n\n    Returns:\n        None\n\n    \"\"\"\n    while not self.thread_end.is_set():\n        if self.queue.empty():\n            time.sleep(0.5)\n            continue\n        item = self.queue.get()\n        table = rgetattr(self._schemata[item.schema], item.table)\n        with self.acquire_lock(self.thread_lock):\n            try:\n                self._insert_item(item, table)\n                self._validate_item(item, table)\n            except Exception as insert_error:\n                if item.error:\n                    self.thread_end.set()\n                    log.error(\n                        \"Second time failed to insert:\\n %s in %s With error:\\n %s\",\n                        item.tuple,\n                        table,\n                        insert_error,\n                        exc_info=True,\n                    )\n                    self.thread_exception = insert_error\n                    break\n                self._handle_insert_error(item, table, insert_error, self.queue)\n        if item.block:\n            self.queue.task_done()\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._log_setup_info","title":"<code>_log_setup_info(setup, setup_status='running')</code>","text":"<p>Log setup information into the Control table in the experiment database.</p> <p>It first fetches the control information for the current setup. If no control information is found, it creates a new dictionary with the setup information. It then adds the IP and status information to the key.</p> <p>The method finally puts the key into the Control table, replacing any existing entry. Because it blocks the queue until the operation is complete it needs the inserter_thread to be running.</p> <p>Parameters:</p> Name Type Description Default <code>setup</code> <code>str</code> <p>The setup name.</p> required <code>setup_status</code> <code>str</code> <p>The current status fo the setup. Defaults to running.</p> <code>'running'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _log_setup_info(self, setup: str, setup_status: str = \"running\") -&gt; None:\n    \"\"\"Log setup information into the Control table in the experiment database.\n\n    It first fetches the control information for the current setup. If no control\n    information is found, it creates a new dictionary with the setup information.\n    It then adds the IP and status information to the key.\n\n    The method finally puts the key into the Control table, replacing any existing\n    entry. Because it blocks the queue until the operation is complete it needs the\n    inserter_thread to be running.\n\n    Args:\n        setup (str): The setup name.\n        setup_status (str): The current status fo the setup. Defaults to running.\n\n    Returns:\n        None\n\n    \"\"\"\n    rel = experiment.Control() &amp; dict(setup=setup)\n    key = rel.fetch1() if np.size(rel.fetch()) else dict(setup=setup)\n    key = {**key, \"ip\": self.get_ip(), \"status\": setup_status}\n    self.put(\n        table=\"Control\",\n        tuple=key,\n        replace=True,\n        priority=1,\n        block=True,\n        validate=True,\n    )\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._log_sub_tables_config","title":"<code>_log_sub_tables_config(setup_conf_idx, config_tables, schema)</code>","text":"<p>Log conifguration data in the respective tables.</p> <p>This method iterates over a list of configuration tables, retrieves the configuration data for each table based on the provided parameters, and then logs this data into the respective table within the given schema.</p> <p>Parameters:</p> Name Type Description Default <code>setup_conf_idx</code> <code>int</code> <p>index indication the setup configuration</p> required <code>config_tables</code> <code>list</code> <p>The part table to be recorded (e.g., Port, Screen).</p> required <code>schema</code> <code>str</code> <p>The schema for the configuration.</p> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _log_sub_tables_config(\n    self, setup_conf_idx: int, config_tables: List[str], schema: str\n) -&gt; None:\n    \"\"\"Log conifguration data in the respective tables.\n\n    This method iterates over a list of configuration tables, retrieves the\n    configuration data for each table based on the provided parameters, and then\n    logs this data into the respective table within the given schema.\n\n    Args:\n        setup_conf_idx (int): index indication the setup configuration\n        config_tables (list): The part table to be recorded (e.g., Port, Screen).\n        schema (str): The schema for the configuration.\n\n    \"\"\"\n    for config_table in config_tables:\n        configuration_data = (\n            getattr(interface.SetupConfiguration, config_table.split(\".\")[1])\n            &amp; {\"setup_conf_idx\": setup_conf_idx}\n        ).fetch(as_dict=True)\n        # put the configuration data in the configuration table\n        # it can be a list of configurations (e.g have two ports with different ids)\n        for conf in configuration_data:\n            self.put(\n                table=config_table,\n                tuple={**conf, **self.trial_key},\n                schema=schema,\n            )\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._log_task_details","title":"<code>_log_task_details()</code>","text":"<p>Save the task file, name and git_hash in the database.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _log_task_details(self) -&gt; None:\n    \"\"\"Save the task file, name and git_hash in the database.\"\"\"\n    version_info = get_code_version_info()\n    self.put(table=\"Session.Version\", tuple={**self.trial_key, **version_info})\n    log.debug(f\"Code version: {version_info}\")\n\n    env_info = get_environment_info()\n    self.put(table=\"Session.Enviroment\", tuple={**self.trial_key, **env_info})\n    log.debug(f\"Enviroment info: {env_info}\")\n\n    for path in plugin_manager.plugin_paths:\n        plugin_version_info = get_code_version_info(path)\n        if plugin_version_info[\"source_type\"] is None:\n            log.warning(f\"Plugin {path} is not a git repository\")\n        else:\n            log.debug(f\"Plugin code version: {plugin_version_info}\")\n        self.put(\n            table=\"Session.Version\", tuple={**self.trial_key, **plugin_version_info}\n        )\n\n    self.put(\n        table=\"Session.Task\",\n        tuple={\n            **self.trial_key,\n            \"task_name\": self.task_path,\n            \"task_file\": np.fromfile(self.task_path, dtype=np.int8),\n            \"git_hash\": version_info[\"version\"],\n        },\n    )\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._sync_control_table","title":"<code>_sync_control_table(update_period=5000)</code>","text":"<p>Synchronize the Control table.</p> <p>Synchronize the Control table by continuously fetching the setup status from the experiment schema and periodically updating the setup info.</p> <p>Runs in a loop until the thread_end event is set.</p> <p>Parameters:</p> Name Type Description Default <code>update_period</code> <code>float</code> <p>Time in milliseconds between Control table updates.</p> <code>5000</code> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _sync_control_table(self, update_period: float = 5000) -&gt; None:\n    \"\"\"Synchronize the Control table.\n\n    Synchronize the Control table by continuously fetching the setup status\n    from the experiment schema and periodically updating the setup info.\n\n    Runs in a loop until the thread_end event is set.\n\n    Args:\n        update_period (float): Time in milliseconds between Control table updates.\n\n    \"\"\"\n    while not self.thread_end.is_set():\n        with self.thread_lock:\n            if self.update_status.is_set():\n                continue\n            try:\n                self._fetch_setup_info()\n                self._update_setup_info(update_period)\n            except Exception as error:\n                log.exception(\"Error during Control table sync: %s\", error)\n                self.thread_exception = error\n\n        time.sleep(1)  # Cycle once a second\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._update_setup_info","title":"<code>_update_setup_info(update_period)</code>","text":"<p>Update the setup information if the elapsed time exceeds the update period.</p> <p>This method checks if the elapsed time since the last ping exceeds the given update period. If it does, it resets the ping timer and updates the setup information with the current state, queue size, trial index, total liquid reward, and the current timestamp. The updated information is then stored in the \"Control\" table with a priority of 1.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _update_setup_info(self, update_period: float) -&gt; None:\n    \"\"\"Update the setup information if the elapsed time exceeds the update period.\n\n    This method checks if the elapsed time since the last ping exceeds the given\n    update period. If it does, it resets the ping timer and updates the setup\n    information with the current state, queue size, trial index, total liquid\n    reward, and the current timestamp. The updated information is then stored\n    in the \"Control\" table with a priority of 1.\n    \"\"\"\n    if self.ping_timer.elapsed_time() &gt;= update_period:\n        self.ping_timer.start()\n        info = {\n            \"last_ping\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"queue_size\": self.queue.qsize(),\n            \"trials\": self.trial_key[\"trial_idx\"],\n            \"total_liquid\": self.total_reward,\n            \"state\": self.curr_state,\n        }\n        self.setup_info.update(info)\n        self.put(table=\"Control\", tuple=self.setup_info, replace=True, priority=1)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger._validate_item","title":"<code>_validate_item(item, table)</code>","text":"<p>Validate an item against a table.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _validate_item(self, item, table) -&gt; None:\n    \"\"\"Validate an item against a table.\"\"\"\n    if item.validate:  # validate tuple exists in database\n        key = {k: v for (k, v) in item.tuple.items() if k in table.primary_key}\n        if \"status\" in item.tuple.keys():\n            key[\"status\"] = item.tuple[\"status\"]\n        while not len(table &amp; key) &gt; 0:\n            time.sleep(0.5)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.acquire_lock","title":"<code>acquire_lock(lock)</code>","text":"<p>Acquire a lock, yield control, and release the lock.</p> <p>This context manager ensures that the given lock is acquired before entering the block of code and released after exiting the block, even if an exception is raised within the block.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Lock</code> <p>The lock object to acquire and release.</p> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>@contextmanager\ndef acquire_lock(self, lock):  # noqa: ANN201\n    \"\"\"Acquire a lock, yield control, and release the lock.\n\n    This context manager ensures that the given lock is acquired before\n    entering the block of code and released after exiting the block, even\n    if an exception is raised within the block.\n\n    Args:\n        lock (threading.Lock): The lock object to acquire and release.\n\n    \"\"\"\n    lock.acquire()\n    try:\n        yield\n    finally:\n        lock.release()\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.cleanup","title":"<code>cleanup()</code>","text":"<p>Wait for the logging queue to be empty and signals the logging thread to end.</p> <p>This method checks if the logging queue is empty, and if not, it waits until it becomes empty. Once the queue is empty, it sets the thread_end event to signal the logging thread to terminate.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def cleanup(self) -&gt; None:\n    \"\"\"Wait for the logging queue to be empty and signals the logging thread to end.\n\n    This method checks if the logging queue is empty, and if not, it waits until it\n    becomes empty. Once the queue is empty, it sets the thread_end event to signal\n    the logging thread to terminate.\n    \"\"\"\n    while not self.queue.empty() and not self.thread_end.is_set():\n        log.info(\"Waiting for empty queue... qsize: %d\", self.queue.qsize())\n        time.sleep(1)\n    self.thread_end.set()\n\n    if not self.queue.empty():\n        log.warning(\"Clean up finished but queue size is: %d\", self.queue.qsize())\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.closeDatasets","title":"<code>closeDatasets()</code>","text":"<p>Close all datasets managed by this instance.</p> <p>Iterates through the datasets dictionary, calling the <code>exit</code> method on each dataset object to properly close them.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def closeDatasets(self) -&gt; None:\n    \"\"\"Close all datasets managed by this instance.\n\n    Iterates through the datasets dictionary, calling the `exit` method on each\n    dataset object to properly close them.\n    \"\"\"\n    for _, dataset in self.datasets.items():\n        dataset.exit()\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.createDataset","title":"<code>createDataset(dataset_name, dataset_type, filename=None, db_log=True)</code>","text":"<p>Create a dataset and return the dataset object.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_name</code> <code>str</code> <p>The name of the dataset.</p> required <code>dataset_type</code> <code>type</code> <p>The datatype of the dataset.</p> required <code>filename</code> <code>str</code> <p>The filename for the h5 file. If not provided, a default filename will be generated based on the dataset name, animal ID, session, and current timestamp.</p> <code>None</code> <code>db_log</code> <code>bool</code> <p>If True call the log_recording</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Tuple[str, Any]: A tuple containing the filename and the dataset object.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def createDataset(\n    self,\n    dataset_name: str,\n    dataset_type: type,\n    filename: Optional[str] = None,\n    db_log: Optional[bool] = True,\n) -&gt; Dict:\n    \"\"\"Create a dataset and return the dataset object.\n\n    Args:\n        dataset_name (str): The name of the dataset.\n        dataset_type (type): The datatype of the dataset.\n        filename (str, optional): The filename for the h5 file. If not provided,\n            a default filename will be generated based on the dataset name,\n            animal ID, session, and current timestamp.\n        db_log (bool, optional): If True call the log_recording\n\n    Returns:\n        Tuple[str, Any]: A tuple containing the filename and the dataset object.\n\n    \"\"\"\n    folder = (\n        f\"Recordings/{self.trial_key['animal_id']}_{self.trial_key['session']}/\"\n    )\n    path = self.source_path + folder\n    if not os.path.isdir(path):\n        os.makedirs(path)  # create path if necessary\n\n    if not os.path.isdir(self.target_path):\n        log.info(\"No target directory set! Autocopying will not work.\")\n        target_path = False\n    else:\n        target_path = self.target_path + folder\n        if not os.path.isdir(target_path):\n            os.makedirs(target_path)\n\n    # Generate filename if not provided\n    if filename is None:\n        filename = (\n            f\"{dataset_name}_{self.trial_key['animal_id']}_\"\n            f\"{self.trial_key['session']}_\"\n            f\"{datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}.h5\"\n        )\n    if filename not in self.datasets:\n        # create h5 file if not exists\n        self.datasets[filename] = self.writer(path + filename, target_path)\n\n    # create new dataset in the h5 files\n    self.datasets[filename].createDataset(\n        dataset_name, shape=(1,), dtype=dataset_type\n    )\n\n    if db_log:\n        rec_key = dict(\n            rec_aim=dataset_name,\n            software=\"EthoPy\",\n            version=__version__,\n            filename=filename,\n            source_path=path,\n            target_path=target_path,\n        )\n        self.log_recording(rec_key)\n\n    return self.datasets[filename]\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.get","title":"<code>get(schema='experiment', table='Control', fields=None, key=None, **kwargs)</code>","text":"<p>Fetch data from a specified table in a schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>The schema to fetch data from. Defaults to \"experiment\".</p> <code>'experiment'</code> <code>table</code> <code>str</code> <p>The table to fetch data from. Defaults to \"Control\".</p> <code>'Control'</code> <code>fields</code> <code>dict</code> <p>The fields to fetch. Defaults to \"\".</p> <code>None</code> <code>key</code> <code>dict</code> <p>The key used to fetch data. Defaults to an empty dict.</p> <code>None</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The fetched data.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def get(\n    self,\n    schema: str = \"experiment\",\n    table: str = \"Control\",\n    fields: Optional[List] = None,\n    key: Optional[Dict] = None,\n    **kwargs: Dict[str, Any],\n) -&gt; np.ndarray:\n    \"\"\"Fetch data from a specified table in a schema.\n\n    Args:\n        schema (str): The schema to fetch data from. Defaults to \"experiment\".\n        table (str): The table to fetch data from. Defaults to \"Control\".\n        fields (dict): The fields to fetch. Defaults to \"\".\n        key (dict): The key used to fetch data. Defaults to an empty dict.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        (numpy.ndarray): The fetched data.\n\n    \"\"\"\n    if key is None:\n        key = dict()\n    if fields is None:\n        fields = []\n    table = rgetattr(eval(schema), table)  # noqa: S307\n    return (table() &amp; key).fetch(*fields, **kwargs)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.get_inner_classes_list","title":"<code>get_inner_classes_list(outer_class)</code>  <code>staticmethod</code>","text":"<p>Retrieve a list of names of all inner classes defined within an outer class.</p> <p>Parameters:</p> Name Type Description Default <code>outer_class</code> <code>Any</code> <p>The class object of the outer class containing the inner classes.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings, each representing the fully qualified name of an inner class defined within the outer class.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>@staticmethod\ndef get_inner_classes_list(outer_class: Any) -&gt; List[str]:\n    \"\"\"Retrieve a list of names of all inner classes defined within an outer class.\n\n    Args:\n        outer_class: The class object of the outer class containing the inner\n            classes.\n\n    Returns:\n        A list of strings, each representing the fully qualified name of an inner\n            class defined within the outer class.\n\n    \"\"\"\n    outer_class_dict_values = outer_class.__dict__.values()\n    inner_classes = [\n        value for value in outer_class_dict_values if isinstance(value, type)\n    ]\n    return [outer_class.__name__ + \".\" + cls.__name__ for cls in inner_classes]\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.get_ip","title":"<code>get_ip()</code>  <code>staticmethod</code>","text":"<p>Retrieve the local IP address of the machine.</p> <p>Attempts to establish a dummy connection to a public DNS server (8.8.8.8) to determine the local network IP address of the machine. If the connection fails, defaults to localhost (127.0.0.1).</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The local IP address.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>@staticmethod\ndef get_ip() -&gt; str:\n    \"\"\"Retrieve the local IP address of the machine.\n\n    Attempts to establish a dummy connection to a public DNS server (8.8.8.8) to\n    determine the local network IP address of the machine. If the connection fails,\n    defaults to localhost (127.0.0.1).\n\n    Returns:\n        str: The local IP address.\n\n    \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        s.connect((\"8.8.8.8\", 80))\n        ip = s.getsockname()[0]\n    except Exception:\n        ip = \"127.0.0.1\"\n    finally:\n        s.close()\n    return ip\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.get_setup_info","title":"<code>get_setup_info(field)</code>","text":"<p>Retrieve specific setup information from an experiment control table.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The name of the field to fetch from the experiment control setup.</p> required <p>Returns:</p> Type Description <code>int64</code> <p>The value of the specified field from the experiment control setup.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def get_setup_info(self, field: str) -&gt; np.int64:\n    \"\"\"Retrieve specific setup information from an experiment control table.\n\n    Args:\n        field (str): The name of the field to fetch from the experiment control\n            setup.\n\n    Returns:\n        The value of the specified field from the experiment control setup.\n\n    \"\"\"\n    return (experiment.Control() &amp; dict(setup=self.setup)).fetch1(field)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.get_table_keys","title":"<code>get_table_keys(schema='experiment', table='Control', key=None, key_type=None)</code>","text":"<p>Retrieve the primary key of a specified table within a given schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str</code> <p>The schema name where the table is located. Default is 'experiment'.</p> <code>'experiment'</code> <code>table</code> <code>str</code> <p>The table name from which to retrieve the keys. Default is 'Control'.</p> <code>'Control'</code> <code>key</code> <code>dict</code> <p>A dict with the key to filter the table. Default is an empty dictionary.</p> <code>None</code> <code>key_type</code> <code>str</code> <p>type of keys to return from the table</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[str]</code> <p>The primary key of the specified table.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def get_table_keys(\n    self,\n    schema: str = \"experiment\",\n    table: str = \"Control\",\n    key: Optional[Dict] = None,\n    key_type: Optional[str] = None,\n) -&gt; List[str]:\n    \"\"\"Retrieve the primary key of a specified table within a given schema.\n\n    Args:\n        schema (str): The schema name where the table is located. Default is\n            'experiment'.\n        table (str): The table name from which to retrieve the keys. Default is\n            'Control'.\n        key (dict): A dict with the key to filter the table. Default is an empty\n            dictionary.\n        key_type (str): type of keys to return from the table\n\n    Returns:\n        list: The primary key of the specified table.\n\n    \"\"\"\n    if key is None:\n        key = []\n    table = rgetattr(globals()[schema], table)  # noqa: S307\n    if key_type == \"primary\":\n        return (table() &amp; key).primary_key\n    return (table() &amp; key).heading.names\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.get_task","title":"<code>get_task()</code>","text":"<p>Get the task configuration.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if task is available and valid</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def get_task(self) -&gt; bool:\n    \"\"\"Get the task configuration.\n\n    Returns:\n        bool: True if task is available and valid\n\n    \"\"\"\n    if not self.manual_run:\n        self.task = resolve_task(task_id=self.get_setup_info(\"task_idx\"))\n\n    return self.task_path is not None\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.log","title":"<code>log(table, data=None, **kwargs)</code>","text":"<p>Log the given data into the specified table in the experiment database.</p> <p>It first gets the elapsed time from the logger timer and adds it to the data dictionary. It then puts the data into the specified table.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The name of the table in the experiment database.</p> required <code>data</code> <code>dict</code> <p>The data to be logged. Defaults to an empty dictionary.</p> <code>None</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments to be passed to the put method.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The elapsed time from the logger timer.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def log(\n    self,\n    table: str,\n    data: Optional[Dict[str, Any]] = None,\n    **kwargs: Dict[str, Any],\n) -&gt; float:\n    \"\"\"Log the given data into the specified table in the experiment database.\n\n    It first gets the elapsed time from the logger timer and adds it to the data\n    dictionary. It then puts the data into the specified table.\n\n    Args:\n        table (str): The name of the table in the experiment database.\n        data (dict, optional): The data to be logged. Defaults to an empty\n            dictionary.\n        **kwargs: Additional keyword arguments to be passed to the put method.\n\n    Returns:\n        float: The elapsed time from the logger timer.\n\n    \"\"\"\n    tmst = self.logger_timer.elapsed_time()\n    data = data or {}  # if data is None or False use an empty dictionary\n    self.put(table=table, tuple={**self.trial_key, \"time\": tmst, **data}, **kwargs)\n    if table == \"Trial.StateOnset\":\n        log.info(\"State: %s\", data[\"state\"])\n    return tmst\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.log_recording","title":"<code>log_recording(rec_key)</code>","text":"<p>Log a new recording entry with an incremented recording index.</p> <p>This method retrieves the current recordings associated with the trial, calculates the next recording index (rec_idx) by finding the maximum recording index and adding one, and logs the new recording entry with the provided recording key (rec_key) and the calculated recording index.</p> <p>Parameters:</p> Name Type Description Default <code>rec_key</code> <code>dict</code> <p>A dictionary containing the key information for the recording entry.</p> required <p>The method assumes the existence of a <code>get</code> method to retrieve existing recordings and a <code>log</code> method to log the new recording entry.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def log_recording(self, rec_key: Dict) -&gt; None:\n    \"\"\"Log a new recording entry with an incremented recording index.\n\n    This method retrieves the current recordings associated with the trial,\n    calculates the next recording index (rec_idx) by finding the maximum\n    recording index and adding one, and logs the new recording entry with\n    the provided recording key (rec_key) and the calculated recording index.\n\n    Args:\n        rec_key (dict): A dictionary containing the key information for the\n            recording entry.\n\n    The method assumes the existence of a `get` method to retrieve existing\n    recordings and a `log` method to log the new recording entry.\n\n    \"\"\"\n    recs = self.get(\n        schema=\"recording\",\n        table=\"Recording\",\n        key=self.trial_key,\n        fields=[\"rec_idx\"],\n    )\n    rec_idx = 1 if not recs else max(recs) + 1\n    self.log(\"Recording\", data={**rec_key, \"rec_idx\": rec_idx}, schema=\"recording\")\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.log_session","title":"<code>log_session(session_params, experiment_type, log_task=False)</code>","text":"<p>Log session with the given parameters and optionally log the task.</p> <p>Parameters:</p> Name Type Description Default <code>session_params</code> <code>Dict[str, Any]</code> <p>Parameters for the session.</p> required <code>experiment_type</code> <code>str</code> <p>current experiment running in session.</p> required <code>log_task</code> <code>bool</code> <p>Whether to log the task information.</p> <code>False</code> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def log_session(\n    self,\n    session_params: Dict[str, Any],\n    experiment_type: str,\n    log_task: bool = False,\n) -&gt; None:\n    \"\"\"Log session with the given parameters and optionally log the task.\n\n    Args:\n        session_params (Dict[str, Any]): Parameters for the session.\n        experiment_type (str): current experiment running in session.\n        log_task (bool): Whether to log the task information.\n\n    \"\"\"\n    # Initializes session parameters and logs the session start.\n    self._init_session_params(\n        session_params.get(\"user_name\", \"bot\"), experiment_type\n    )\n\n    # Save the task file, name and the git_hash in the database.\n    if log_task:\n        self._log_task_details()\n\n    # update the configuration tables\n    self.log_session_configs(session_params[\"setup_conf_idx\"])\n\n    #  Init the informations(e.g. trial_id=0, session) in control table\n    self._init_control_table(session_params)\n\n    self.logger_timer.start()  # Start session time\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.log_session_configs","title":"<code>log_session_configs(setup_conf_idx)</code>","text":"<p>Log parameter of a session into the appropriate schema tables.</p> <p>This method performs several key operations to ensure that the configuration of a session, including behavior and stimulus settings, is accurately logged into the database. It involves the following steps: 1. Identifies the relevant modules (e.g., ethopy.core.interface) that contain Configuration classes. 2. Derives schema names from these modules, assuming the schema name matches the class name in lowercase. 3. Logs the session and animal_id into the Configuration tables of the identified schemas. 4. Creates a dictionary mapping each schema to its respective Configuration class's inner classes. 5. Calls a helper method to log the configuration of sub-tables for each schema.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def log_session_configs(self, setup_conf_idx: int) -&gt; None:\n    \"\"\"Log parameter of a session into the appropriate schema tables.\n\n    This method performs several key operations to ensure that the configuration of\n    a session, including behavior and stimulus settings, is accurately logged into\n    the database. It involves the following steps:\n    1. Identifies the relevant modules (e.g., ethopy.core.interface) that contain\n    Configuration classes.\n    2. Derives schema names from these modules, assuming the schema name matches the\n    class name in lowercase.\n    3. Logs the session and animal_id into the Configuration tables of the\n    identified schemas.\n    4. Creates a dictionary mapping each schema to its respective Configuration\n    class's inner classes.\n    5. Calls a helper method to log the configuration of sub-tables for each schema.\n    \"\"\"\n    # modules that have a Configuration classes\n    _modules = [\"ethopy.core.interface\"]\n    # consider that the module have the same name as the schema but in lower case\n    # (e.g for class Behaviour the schema is the behavior)\n    _schemas = [_module.split(\".\")[2].lower() for _module in _modules]\n\n    # Logs the session and animal_id in configuration tables of behavior/stimulus.\n    for schema in _schemas:\n        self.put(\n            table=\"Configuration\",\n            tuple=self.trial_key,\n            schema=schema,\n            priority=2,\n            validate=True,\n            block=True,\n        )\n\n    # create a dict with the configuration as key and the subclasses as values\n    conf_table_schema = {}\n    for _schema, _module in zip(_schemas, _modules):\n        conf = importlib.import_module(_module).Configuration\n        # Find the inner classes of the class Configuration\n        conf_table_schema[_schema] = self.get_inner_classes_list(conf)\n\n    # update the sub tables of Configuration table\n    for schema, config_tables in conf_table_schema.items():\n        self._log_sub_tables_config(setup_conf_idx, config_tables, schema)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.put","title":"<code>put(**kwargs)</code>","text":"<p>Put an item in the queue.</p> <p>This method creates a <code>PrioritizedItem</code> from the given keyword arguments and puts it into the queue. After putting an item in the queue, it checks the 'block' attribute of the item. If 'block' is False, it marks the item as processed by calling <code>task_done()</code>. This is useful in scenarios where items are processed asynchronously, and the queue needs to be notified that a task is complete. If 'block' is True, it waits for all items in the queue to be processed by calling <code>join()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>The keyword arguments used to create a <code>PrioritizedItem</code> and put it in the queue.</p> <code>{}</code> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def put(self, **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Put an item in the queue.\n\n    This method creates a `PrioritizedItem` from the given keyword arguments and\n    puts it into the queue. After putting an item in the queue, it checks the\n    'block' attribute of the item. If 'block' is False, it marks the item as\n    processed by calling `task_done()`. This is useful in scenarios where items are\n    processed asynchronously, and the queue needs to be notified that a task is\n    complete. If 'block' is True, it waits for all items in the queue to be\n    processed by calling `join()`.\n\n    Args:\n        **kwargs (Any): The keyword arguments used to create a `PrioritizedItem` and\n            put it in the queue.\n\n    \"\"\"\n    item = PrioritizedItem(**kwargs)\n    self.queue.put(item)\n    if not item.block:\n        self.queue.task_done()\n    else:\n        self.queue.join()\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.setup_schema","title":"<code>setup_schema(extra_schema)</code>","text":"<p>Set up additional schema.</p> <p>Parameters:</p> Name Type Description Default <code>extra_schema</code> <code>Dict[str, Any]</code> <p>The additional schema to set up.</p> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def setup_schema(self, extra_schema: Dict[str, Any]) -&gt; None:\n    \"\"\"Set up additional schema.\n\n    Args:\n        extra_schema (Dict[str, Any]): The additional schema to set up.\n\n    \"\"\"\n    for schema, value in extra_schema.items():\n        globals()[schema] = dj.create_virtual_module(\n            schema, value, create_tables=True, create_schema=True\n        )\n        self._schemata.update(\n            {\n                schema: dj.create_virtual_module(\n                    schema, value, connection=self.private_conn\n                )\n            }\n        )\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.update_setup_info","title":"<code>update_setup_info(info, key=None)</code>","text":"<p>Update the setup information in Control table with the provided info and key.</p> <p>It first fetches the existing setup information from the experiment's Control table, then updates it with the provided info. If 'status' is in the provided info, it blocks and validates the update operation.</p> <p>Parameters:</p> Name Type Description Default <code>info</code> <code>dict</code> <p>The information to update the setup with.</p> required <code>key</code> <code>dict</code> <p>Additional keys to fetch the setup information with. Defaults to None.</p> <code>None</code> Side Effects <p>Updates the setup_info attribute with the new setup information. Updates the setup_status attribute with the new status.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def update_setup_info(\n    self, info: Dict[str, Any], key: Optional[Dict[str, Any]] = None\n) -&gt; None:\n    \"\"\"Update the setup information in Control table with the provided info and key.\n\n    It first fetches the existing setup information from the experiment's Control\n    table, then updates it with the provided info. If 'status' is in the provided\n    info, it blocks and validates the update operation.\n\n    Args:\n        info (dict): The information to update the setup with.\n        key (dict, optional): Additional keys to fetch the setup information with.\n            Defaults to None.\n\n    Side Effects:\n        Updates the setup_info attribute with the new setup information.\n        Updates the setup_status attribute with the new status.\n\n    \"\"\"\n    if self.thread_exception:\n        self.thread_exception = None\n        raise Exception(\"Thread exception occurred: %s\", self.thread_exception)\n    if key is None:\n        key = dict()\n\n    if not public_conn.is_connected:\n        _set_connection()\n\n    block = True if \"status\" in info else False\n    if block:\n        self.update_status.set()\n        caller = inspect.stack()[1]\n        caller_info = (\n            f\"Function called by {caller.function} \"\n            f\"in {caller.filename} at line {caller.lineno}\"\n        )\n        log.debug(\"Update status is set %s\\n%s\", info[\"status\"], caller_info)\n\n    self.setup_info = {\n        **(experiment.Control() &amp; {\"setup\": self.setup, **key}).fetch1(),\n        **info,\n    }\n\n    char_len = 255\n    if \"notes\" in info and len(info[\"notes\"]) &gt; char_len:\n        info[\"notes\"] = info[\"notes\"][:char_len]\n\n    self.put(\n        table=\"Control\",\n        tuple=self.setup_info,\n        replace=True,\n        priority=1,\n        block=block,\n        validate=block,\n    )\n    self.setup_status = self.setup_info[\"status\"]\n    self.update_status.clear()\n</code></pre>"},{"location":"logger/#ethopy.core.logger.Logger.update_trial_idx","title":"<code>update_trial_idx(trial_idx)</code>","text":"<p>Update trial index.</p> <p>Updates the trial index in the trial_key dictionary and check if there is any exception in the threads.</p> <p>Parameters:</p> Name Type Description Default <code>trial_idx</code> <code>int</code> <p>The new trial index to be updated.</p> required Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def update_trial_idx(self, trial_idx: int) -&gt; None:\n    \"\"\"Update trial index.\n\n    Updates the trial index in the trial_key dictionary and check if there is any\n    exception in the threads.\n\n    Args:\n        trial_idx (int): The new trial index to be updated.\n\n    \"\"\"\n    self.trial_key[\"trial_idx\"] = trial_idx\n    log.info(\"\\nTrial idx: %s\", self.trial_key[\"trial_idx\"])\n    if self.thread_exception:\n        self.thread_exception = None\n        raise Exception(\"Thread exception occurred: %s\", self.thread_exception)\n</code></pre>"},{"location":"logger/#ethopy.core.logger.PrioritizedItem","title":"<code>PrioritizedItem</code>  <code>dataclass</code>","text":"<p>A class used to represent an item with a priority for logging purposes.</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>@dataclass(order=True)\nclass PrioritizedItem:\n    \"\"\"A class used to represent an item with a priority for logging purposes.\"\"\"\n\n    table: str = datafield(compare=False)\n    tuple: Any = datafield(compare=False)\n    field: str = datafield(compare=False, default=\"\")\n    value: Any = datafield(compare=False, default=\"\")\n    schema: str = datafield(compare=False, default=\"experiment\")\n    replace: bool = datafield(compare=False, default=False)\n    block: bool = datafield(compare=False, default=False)\n    validate: bool = datafield(compare=False, default=False)\n    priority: int = datafield(default=50)\n    error: bool = datafield(compare=False, default=False)\n    ignore_extra_fields: bool = datafield(compare=False, default=True)\n</code></pre>"},{"location":"logger/#ethopy.core.logger._set_connection","title":"<code>_set_connection()</code>","text":"<p>Establish connection to database.</p> <p>Establishes connections to database, creates virtual modules based on the provided schemata and assigns them to global variables. It also initializes the <code>public_conn</code> global variable.</p> Globals <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ethopy/core/logger.py</code> <pre><code>def _set_connection() -&gt; None:\n    \"\"\"Establish connection to database.\n\n    Establishes connections to database, creates virtual modules based on the provided\n    schemata and assigns them to global variables. It also initializes the `public_conn`\n    global variable.\n\n    Globals:\n        experiment: The virtual module for experiment.\n        stimulus: The virtual module for stimulus.\n        behavior: The virtual module for behavior.\n        interface: The virtual module for interface.\n        recording: The virtual module for recording.\n        public_conn: The connection object for public access.\n\n    Returns:\n        None\n\n    \"\"\"\n    global experiment, stimulus, behavior, interface, recording, public_conn\n    virtual_modules, public_conn = create_virtual_modules(SCHEMATA)\n    experiment = virtual_modules[\"experiment\"]\n    stimulus = virtual_modules[\"stimulus\"]\n    behavior = virtual_modules[\"behavior\"]\n    recording = virtual_modules[\"recording\"]\n    interface = virtual_modules[\"interface\"]\n</code></pre>"},{"location":"logging/","title":"Logging in EthoPy","text":"<p>EthoPy provides a comprehensive logging system that handles both file and console output with configurable formats and levels. The logging system is centrally managed and provides consistent logging across all modules of the package.</p>"},{"location":"logging/#features","title":"Features","text":"<ul> <li>Rotating file logs with size limits</li> <li>Colored console output</li> <li>Different formats for different log levels</li> <li>Centralized configuration</li> <li>Automatic log directory creation</li> <li>Multiple backup log files</li> </ul>"},{"location":"logging/#configuration","title":"Configuration","text":""},{"location":"logging/#default-settings","title":"Default Settings","text":"<pre><code>DEFAULT_LOG_DIR = \"logs\"\nDEFAULT_LOG_FILE = \"ethopy.log\"\nMAX_LOG_SIZE = 30 * 1024 * 1024  # 30 MB\nLOG_BACKUP_COUNT = 5\n</code></pre>"},{"location":"logging/#local-conf-setting-based-on-the-local_confjson","title":"Local conf setting based on the local_conf.json","text":"<p>Logging is set up based on the parameters defined in the local_conf.json <pre><code>    \"logging\": {\n        \"level\": \"INFO\",\n        \"directory\": \"~/.ethopy/\",\n        \"filename\": \"ethopy.log\"\n    }\n</code></pre></p>"},{"location":"logging/#command-line-options","title":"Command Line Options","text":"<p>When running EthoPy from the command line, you can configure logging using these options:</p> <pre><code>ethopy [OPTIONS]\nOptions:\n  --log-console        Enable console logging\n  --log-level TEXT     Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n</code></pre>"},{"location":"logging/#log-formats","title":"Log Formats","text":""},{"location":"logging/#file-logs","title":"File Logs","text":"<p>All file logs use the detailed format: <pre><code>%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)\n</code></pre></p> <p>Example: <pre><code>2024-01-20 10:15:30 - ethopy - INFO - Experiment started (experiment.py:145)\n</code></pre></p>"},{"location":"logging/#console-logs","title":"Console Logs","text":"<p>Console logs use two different formats based on the log level:</p> <ol> <li> <p>Simple Format (for INFO and DEBUG): <pre><code>%(asctime)s - %(levelname)s - %(message)s\n</code></pre></p> </li> <li> <p>Detailed Format (for WARNING and above): <pre><code>%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)\n</code></pre></p> </li> </ol>"},{"location":"logging/#color-coding","title":"Color Coding","text":"<p>Console output is color-coded by log level:</p> <ul> <li>DEBUG: Grey</li> <li>INFO: Grey</li> <li>WARNING: Yellow</li> <li>ERROR: Red</li> <li>CRITICAL: Bold Red</li> </ul>"},{"location":"logging/#log-file-management","title":"Log File Management","text":""},{"location":"logging/#rotation","title":"Rotation","text":"<p>Log files are automatically rotated when they reach the maximum size:</p> <ul> <li>Maximum file size: 30 MB</li> <li>Number of backup files: 5</li> <li>Naming convention: ethopy.log, ethopy.log.1, ethopy.log.2, etc.</li> </ul>"},{"location":"logging/#directory-structure","title":"Directory Structure","text":"<pre><code>logs/\n\u251c\u2500\u2500 ethopy.log          # Current log file\n\u251c\u2500\u2500 ethopy.log.1        # Most recent backup\n\u251c\u2500\u2500 ethopy.log.2        # Second most recent backup\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"logging/#usage-examples","title":"Usage Examples","text":""},{"location":"logging/#basic-logging","title":"Basic Logging","text":"<pre><code>import logging\n\n# Log messages at different levels\nlogging.debug(\"Detailed debug information\")\nlogging.info(\"General information\")\nlogging.warning(\"Warning message\")\nlogging.error(\"Error message\")\nlogging.critical(\"Critical error\")\n</code></pre>"},{"location":"logging/#custom-logger","title":"Custom Logger","text":"<pre><code>import logging\n\n# Create a logger for your module\nlogger = logging.getLogger(__name__)\n\n# Use the logger\nlogger.info(\"Module specific information\")\nlogger.error(\"Module specific error\")\n</code></pre>"},{"location":"logging/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Log Level Selection             - Use DEBUG for detailed debugging information             - Use INFO for general operational messages             - Use WARNING for unexpected but handled situations             - Use ERROR for errors that affect functionality             - Use CRITICAL for errors that require immediate attention</p> </li> <li> <p>Message Content             - Include relevant context in log messages             - Be specific about what happened             - Include important variable values             - Avoid logging sensitive information</p> </li> <li> <p>Performance Considerations             - Avoid logging in tight loops             - Use appropriate log levels to control output volume             - Consider log rotation settings for long-running applications</p> </li> </ol>"},{"location":"logging/#implementation-details","title":"Implementation Details","text":""},{"location":"logging/#loggingmanager-class","title":"LoggingManager Class","text":"<p>The <code>LoggingManager</code> class handles all logging configuration:</p> <pre><code>from ethopy.utils.ethopy_logging import LoggingManager\n\n# Create a manager instance\nmanager = LoggingManager(\"your_module_name\")\n\n# Configure logging\nmanager.configure(\n    log_dir=\"logs\",\n    console=True,\n    log_level=\"INFO\",\n    log_file=\"app.log\"\n)\n</code></pre>"},{"location":"logging/#custom-formatter","title":"Custom Formatter","text":"<p>The logging system includes a custom formatter that provides:</p> <ul> <li>Color-coded output for different log levels</li> <li>Dynamic format selection based on log level</li> <li>Timestamp formatting</li> <li>File and line number information for warnings and errors</li> </ul>"},{"location":"logging/#troubleshooting","title":"Troubleshooting","text":"<ol> <li> <p>Missing Logs             - Check write permissions for log directory             - Verify log level configuration             - Ensure log directory exists</p> </li> <li> <p>Console Output Issues             - Verify console logging is enabled             - Check terminal color support             - Confirm log level settings</p> </li> <li> <p>Performance Issues             - Review log rotation settings             - Check logging frequency             - Consider adjusting log levels</p> </li> </ol>"},{"location":"plugin/","title":"Plugin System","text":"<p>The Ethopy plugin system provides a flexible way to extend the functionality by adding custom modules, behaviors, experiments, interfaces, and stimuli. The system supports both core modules and user plugins with intelligent conflict resolution.</p>"},{"location":"plugin/#plugin-categories","title":"Plugin Categories","text":"<p>Ethopy supports two types of plugins:</p> <ol> <li>Standalone Modules: Individual Python files in the plugin directory</li> <li>Categorized Plugins: Modules organized in specific categories:         - <code>behaviors</code>: Custom behavior implementations         - <code>experiments</code>: Experiment definitions         - <code>interfaces</code>: Hardware interface modules         - <code>stimuli</code>: Stimulus control modules</li> </ol>"},{"location":"plugin/#plugin-locations","title":"Plugin Locations","text":"<p>Plugins can be placed in the following locations (in order of precedence):</p> <ol> <li> <p>Default locations:</p> <ul> <li><code>~/.ethopy/ethopy_plugins/</code> (User's home directory)</li> </ul> </li> <li> <p>Custom locations specified by the <code>ETHOPY_PLUGIN_PATH</code> environment variable:    <pre><code>export ETHOPY_PLUGIN_PATH=/path/to/plugins,/another/plugin/path\n</code></pre></p> </li> </ol> <p>The plugin directory structure should follow this pattern:</p> <pre><code>ethopy_plugins/\n\u251c\u2500\u2500 mymodule.py                    # Standalone module\n\u251c\u2500\u2500 another_module.py              # Another standalone module\n\u251c\u2500\u2500 behaviors/                     # Behavior plugins\n\u2502   \u2514\u2500\u2500 custom_behavior.py\n\u251c\u2500\u2500 experiments/                   # Experiment plugins\n\u2502   \u2514\u2500\u2500 custom_experiment.py\n\u251c\u2500\u2500 interfaces/                    # Interface plugins\n\u2502   \u2514\u2500\u2500 custom_interface.py\n\u2514\u2500\u2500 stimuli/                      # Stimulus plugins\n    \u2514\u2500\u2500 custom_stimulus.py\n</code></pre>"},{"location":"plugin/#creating-plugins","title":"Creating Plugins","text":""},{"location":"plugin/#plugin-naming","title":"Plugin Naming","text":"<p>Plugins are imported using the <code>ethopy</code> namespace. For example:     - Standalone module: <code>ethopy.mymodule</code>     - Categorized plugin: <code>ethopy.behaviors.custom_behavior</code></p> <p>Make sure to avoid naming conflicts with core Ethopy modules, as core modules take precedence over plugins.</p>"},{"location":"plugin/#standalone-modules","title":"Standalone Modules","text":"<p>Create a Python file in the root of your plugin directory:</p> <pre><code># ~/.ethopy/ethopy_plugins/mymodule.py\nclass MyModule:\n    def __init__(self):\n        self.name = \"My Custom Module\"\n\n    def do_something(self):\n        return \"Hello from MyModule!\"\n</code></pre>"},{"location":"plugin/#behavior-plugins","title":"Behavior Plugins","text":"<p>Create a Python file in the <code>behaviors</code> directory:</p> <pre><code># ~/.ethopy/ethopy_plugins/behaviors/custom_behavior.py\nfrom ethopy.core.behavior import Behavior\n\nclass CustomBehavior(Behavior):\n    def __init__(self):\n        super().__init__()\n        # Your initialization code\n\n    def run(self):\n        # Your behavior implementation\n        pass\n</code></pre>"},{"location":"plugin/#experiment-plugins","title":"Experiment Plugins","text":"<p>Create a Python file in the <code>experiments</code> directory:</p> <pre><code># ~/.ethopy/ethopy_plugins/experiments/custom_experiment.py\nfrom ethopy.core.experiment import ExperimentClass, State\n\nclass CustomExperiment(State, ExperimentClass):\n    def __init__(self):\n        super().__init__()\n        # Your initialization code\n\n    def run(self):\n        # Your experiment implementation\n        pass\n</code></pre>"},{"location":"plugin/#plugin-registration","title":"Plugin Registration","text":"<p>Plugins are automatically discovered and registered when: 1. They are placed in a recognized plugin directory 2. The file name doesn't start with an underscore 3. The file has a <code>.py</code> extension</p>"},{"location":"plugin/#using-plugins","title":"Using Plugins","text":""},{"location":"plugin/#importing-plugins","title":"Importing Plugins","text":"<p>Import and use plugins just like regular Ethopy modules:</p> <pre><code># Import standalone module\nfrom ethopy.mymodule import MyModule\n\n# Import behavior plugin\nfrom ethopy.behaviors.custom_behavior import CustomBehavior\n\n# Import experiment plugin\nfrom ethopy.experiments.custom_experiment import CustomExperiment\n\n# Use plugins\nmy_module = MyModule()\nbehavior = CustomBehavior()\nexperiment = CustomExperiment()\n</code></pre>"},{"location":"plugin/#plugin-management","title":"Plugin Management","text":"<p>The plugin system is managed by the <code>PluginManager</code> class, which handles:     - Plugin discovery and registration     - Import path management     - Conflict resolution     - Plugin information tracking</p> <pre><code>from ethopy.plugin_manager import PluginManager\n\n# Create plugin manager instance\nplugin_manager = PluginManager()\n\n# Add custom plugin path\nplugin_manager.add_plugin_path('/path/to/plugins')\n\n# List available plugins\nplugins = plugin_manager.list_plugins(\n    show_duplicates=True,  # Show duplicate plugin information\n    include_core=True      # Include core Ethopy modules\n)\n\n# Print plugin information\nfor category, items in plugins.items():\n    print(f\"\\n{category} plugins:\")\n    for plugin in items:\n        print(f\"  - {plugin['name']} ({plugin['path']})\")\n        if 'duplicates' in plugin:\n            print(\"    Duplicate versions found in:\")\n            for dup in plugin['duplicates']:\n                print(f\"      - {dup}\")\n\n# Get information about a specific plugin\ninfo = plugin_manager.get_plugin_info('ethopy.mymodule')\nif info:\n    print(f\"Plugin: {info.name}\")\n    print(f\"Path: {info.path}\")\n    print(f\"Type: {info.type}\")\n    print(f\"Is Core: {info.is_core}\")\n</code></pre>"},{"location":"plugin/#plugin-resolution","title":"Plugin Resolution","text":""},{"location":"plugin/#load-order","title":"Load Order","text":"<p>Plugins are loaded in the following order: 1. Core Ethopy modules (from main package) 2. Default plugin directories 3. Custom plugin paths from environment variable</p>"},{"location":"plugin/#conflict-resolution","title":"Conflict Resolution","text":"<p>The plugin system uses the following precedence rules:</p> <ol> <li> <p>Core vs Plugin Conflicts:         - Core Ethopy modules always take precedence over plugins         - Warning is issued when a plugin conflicts with a core module</p> </li> <li> <p>Plugin vs Plugin Conflicts:         - Later added paths take precedence over earlier ones         - Warning is displayed showing which version is used/ignored</p> </li> </ol> <p>Example conflict warning: <pre><code>WARNING: Plugin 'ethopy.mymodule' from /path/to/plugin conflicts with core ethopy module. Core module will be used.\n\nWARNING: Duplicate plugin found for 'ethopy.behaviors.custom':\n  Using:     /home/user/.ethopy/ethopy_plugins/behaviors/custom.py\n  Ignoring:  /another/path/behaviors/custom.py\n</code></pre></p>"},{"location":"plugin/#best-practices","title":"Best Practices","text":""},{"location":"plugin/#plugin-development","title":"Plugin Development","text":"<ol> <li> <p>Namespace Awareness:         - Avoid using names that conflict with core Ethopy modules         - Use descriptive, unique names for your plugins         - Follow Python naming conventions</p> </li> <li> <p>Structure and Organization:         - Place plugins in the correct category directory         - Use appropriate base classes for each plugin type         - Keep plugin files focused and single-purpose</p> </li> <li> <p>Documentation:         - Add docstrings to your plugin classes and methods         - Include usage examples in the documentation         - Document any special requirements or dependencies</p> </li> <li> <p>Error Handling:         - Implement proper error handling in your plugins         - Provide meaningful error messages         - Handle resource cleanup properly</p> </li> </ol>"},{"location":"plugin/#plugin-distribution","title":"Plugin Distribution","text":"<ol> <li> <p>Dependencies:         - Clearly specify any additional dependencies         - Use standard Python package management         - Test with different Python versions</p> </li> <li> <p>Version Control:         - Use version control for your plugins         - Tag releases with version numbers         - Maintain a changelog</p> </li> <li> <p>Testing:         - Write tests for your plugins         - Test integration with Ethopy         - Verify behavior with different configurations</p> </li> </ol>"},{"location":"plugin/#troubleshooting","title":"Troubleshooting","text":""},{"location":"plugin/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Plugin Not Found:         - Verify plugin directory location         - Check file permissions         - Ensure correct Python path         - Validate plugin file naming</p> </li> <li> <p>Import Errors:         - Check for missing dependencies         - Verify Python version compatibility         - Look for syntax errors in plugin code         - Check for circular imports</p> </li> <li> <p>Plugin Conflicts:         - Review plugin naming for conflicts         - Check plugin path order         - Examine duplicate warnings         - Verify core module conflicts</p> </li> </ol>"},{"location":"plugin/#debugging-tips","title":"Debugging Tips","text":"<ol> <li> <p>Enable Debug Logging:    <pre><code>import logging\nlogging.getLogger('ethopy').setLevel(logging.DEBUG)\n</code></pre></p> </li> <li> <p>Check Plugin Registration:    <pre><code># List all registered plugins\nplugins = plugin_manager.list_plugins(show_duplicates=True)\n\n# Check specific plugin\ninfo = plugin_manager.get_plugin_info('ethopy.mymodule')\nif info:\n    print(f\"Plugin registered at: {info.path}\")\n    print(f\"Plugin type: {info.type}\")\nelse:\n    print(\"Plugin not registered\")\n</code></pre></p> </li> <li> <p>Verify Plugin Paths:    <pre><code># Print current plugin search paths\nprint(\"Plugin paths:\")\nfor path in plugin_manager._plugin_paths:\n    print(f\"- {path}\")\n</code></pre></p> </li> </ol>"},{"location":"plugin/#additional-resources","title":"Additional Resources","text":"<ol> <li> <p>Documentation:         - Ethopy Core Documentation         - DataJoint Documentation         - Python Packaging Guide</p> </li> <li> <p>Community:         - GitHub Issues         - Contributing Guidelines</p> </li> </ol>"},{"location":"raspberry_pi/","title":"Raspberry pi","text":""},{"location":"raspberry_pi/#raspberry-pi-setup-guide","title":"Raspberry Pi Setup Guide","text":"<p>This guide provides detailed instructions for setting up Ethopy on a Raspberry Pi device.</p>"},{"location":"raspberry_pi/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Get the latest Raspberry Pi OS (Raspbian)</p> </li> <li> <p>Configure Raspberry Pi settings using <code>raspi-config</code>:    <pre><code>sudo raspi-config\n</code></pre></p> </li> <li>Enable SSH</li> <li>Disable screen blanking</li> <li> <p>Enable Desktop auto-login</p> </li> <li> <p>(Optional) Change hostname for easier identification:    <pre><code>sudo sed -r -i s/raspberrypi/&lt;&lt;HOSTNAME&gt;&gt;/g /etc/hostname /etc/hosts\n</code></pre></p> </li> <li> <p>(Optional) Change default username:    <pre><code>sudo useradd -s /bin/bash -d /home/&lt;&lt;USERNAME&gt;&gt;/ -m -G sudo &lt;&lt;USERNAME&gt;&gt;\nsudo passwd &lt;&lt;USERNAME&gt;&gt;\nmkhomedir_helper &lt;&lt;USERNAME&gt;&gt;\nsudo userdel -r -f pi\n</code></pre></p> </li> </ol>"},{"location":"raspberry_pi/#system-dependencies","title":"System Dependencies","text":"<ol> <li> <p>Install required system libraries:    <pre><code>sudo apt update\nsudo apt install -y \\\n    python-dev \\\n    libatlas-base-dev \\\n    build-essential \\\n    libavformat-dev \\\n    libavcodec-dev \\\n    libswscale-dev \\\n    libsquish-dev \\\n    libeigen3-dev \\\n    libopenal-dev \\\n    libfreetype6-dev \\\n    zlib1g-dev \\\n    libx11-dev \\\n    libjpeg-dev \\\n    libvorbis-dev \\\n    libogg-dev \\\n    libassimp-dev \\\n    libode-dev \\\n    libssl-dev \\\n    libgles2 \\\n    libgles1 \\\n    libegl1\n</code></pre></p> </li> <li> <p>Install Python packages:    <pre><code>sudo pip3 install 'numpy&gt;=1.19.1' pygame==1.9.6 cython pybind11 scipy datajoint omxplayer-wrapper imageio imageio-ffmpeg\n</code></pre></p> </li> </ol>"},{"location":"raspberry_pi/#hardware-specific-setup","title":"Hardware-Specific Setup","text":""},{"location":"raspberry_pi/#7-raspberry-pi-touchscreen","title":"7\" Raspberry Pi Touchscreen","text":"<p>Install multitouch driver: <pre><code>git clone http://github.com/ef-lab/python-multitouch ~/github/python-multitouch\ncd ~/github/python-multitouch/library\nsudo python3 setup.py install\n</code></pre></p>"},{"location":"raspberry_pi/#3d-graphics-support","title":"3D Graphics Support","text":"<p>Install Panda3D for Raspberry Pi: <pre><code>wget ftp://eflab.org/shared/panda3d1.11_1.11.0_armhf.deb\nsudo dpkg -i panda3d1.11_1.11.0_armhf.deb\n</code></pre></p>"},{"location":"raspberry_pi/#gpio-support","title":"GPIO Support","text":"<p>Enable pigpio service: <pre><code>wget https://raw.githubusercontent.com/joan2937/pigpio/master/util/pigpiod.service\nsudo cp pigpiod.service /etc/systemd/system\nsudo systemctl enable pigpiod.service\nsudo systemctl start pigpiod.service\n</code></pre></p>"},{"location":"raspberry_pi/#x-display-configuration","title":"X Display Configuration","text":"<p>For running graphical applications via SSH: <pre><code>echo 'export DISPLAY=:0' &gt;&gt; ~/.profile\necho 'xhost + &gt; /dev/null' &gt;&gt; ~/.profile\n</code></pre></p>"},{"location":"raspberry_pi/#remote-control-setup-optional","title":"Remote Control Setup (Optional)","text":"<p>If you want to use Salt for remote control: <pre><code>sudo apt install salt-minion -y\necho 'master: &lt;&lt;YOUR_SALT-MASTER_IP&gt;&gt;' | sudo tee -a /etc/salt/minion\necho 'id: &lt;&lt;HOSTNAME&gt;&gt;' | sudo tee -a /etc/salt/minion\necho 'master_finger: &lt;&lt;MASTER-FINGER&gt;&gt;' | sudo tee -a /etc/salt/minion\nsudo service salt-minion restart\n</code></pre></p>"},{"location":"raspberry_pi/#ethopy-installation","title":"Ethopy Installation","text":"<ol> <li> <p>Install Ethopy:    <pre><code>pip install \"ethopy[obj]\"  # Includes 3D object support\n</code></pre></p> </li> <li> <p>Create configuration file at <code>~/.ethopy/local_conf.json</code>:    <pre><code>{\n    \"dj_local_conf\": {\n        \"database.host\": \"YOUR DATABASE\",\n        \"database.user\": \"USERNAME\",\n        \"database.password\": \"PASSWORD\",\n        \"database.port\": \"PORT\",\n        \"database.reconnect\": true,\n        \"database.enable_python_native_blobs\": true\n    },\n    \"source_path\": \"LOCAL_RECORDINGS_DIRECTORY\",\n    \"target_path\": \"TARGET_RECORDINGS_DIRECTORY\"\n}\n</code></pre></p> </li> <li> <p>Initialize database schemas:    <pre><code>ethopy-setup-schema\n</code></pre></p> </li> </ol>"},{"location":"raspberry_pi/#running-experiments","title":"Running Experiments","text":"<p>You can run experiments in two modes:</p> <ol> <li> <p>Service Mode (controlled by database):    <pre><code>ethopy\n</code></pre></p> </li> <li> <p>Direct Mode (specific task):    <pre><code>ethopy --task-idx 1\n</code></pre></p> </li> </ol>"},{"location":"raspberry_pi/#troubleshooting","title":"Troubleshooting","text":""},{"location":"raspberry_pi/#common-issues","title":"Common Issues","text":"<ol> <li>Display Issues</li> <li>Ensure DISPLAY is set correctly in ~/.profile</li> <li>Check X server is running</li> <li> <p>Verify permissions with <code>xhost +</code></p> </li> <li> <p>GPIO Access</p> </li> <li>Verify pigpiod service is running: <code>systemctl status pigpiod</code></li> <li> <p>Check user permissions for GPIO access</p> </li> <li> <p>Database Connection</p> </li> <li>Test connection: <code>ethopy-db-connection</code></li> <li>Check network connectivity to database server</li> <li>Verify credentials in local_conf.json</li> </ol>"},{"location":"setup_configuration_idx/","title":"Setup Configuration in EthoPy","text":"<p>The setup configuration system in EthoPy is managed through the <code>setup_conf_idx</code> (Setup Configuration Index) and associated tables. This system allows users to define and manage different hardware configurations for experimental setups.</p>"},{"location":"setup_configuration_idx/#setup-configuration-index-setup_conf_idx","title":"Setup Configuration Index (<code>setup_conf_idx</code>)","text":"<p>The <code>setup_conf_idx</code> is a unique identifier that links together all components of a particular setup configuration. It's defined in the main <code>SetupConfiguration</code> table and referenced by all related configuration tables.</p>"},{"location":"setup_configuration_idx/#main-configuration-table","title":"Main Configuration Table","text":"<pre><code># SetupConfiguration\nsetup_conf_idx      : tinyint      # configuration version\n---\ninterface           : enum('DummyPorts','RPPorts', 'PCPorts', 'RPVR')\ndiscription         : varchar(256)\n</code></pre>"},{"location":"setup_configuration_idx/#component-configuration-tables","title":"Component Configuration Tables","text":""},{"location":"setup_configuration_idx/#1-port-configuration-setupconfigurationport","title":"1. Port Configuration (<code>SetupConfiguration.Port</code>)","text":"<p>Defines the configuration for input/output ports.</p> <pre><code>port                   : tinyint                  # port id\ntype=\"Lick\"            : enum('Lick','Proximity') # port type\n-&gt; SetupConfiguration\n---\nready=0                : tinyint       # ready flag\nresponse=0             : tinyint       # response flag\nreward=0               : tinyint       # reward flag\ninvert=0               : tinyint       # invert flag\ndiscription            : varchar(256)\n</code></pre>"},{"location":"setup_configuration_idx/#port-types-and-flags","title":"Port Types and Flags","text":"<ul> <li>Types: <ul> <li><code>Lick</code>: For lick detection</li> <li><code>Proximity</code>: For proximity detection</li> </ul> </li> <li>Flags:<ul> <li><code>ready</code>: Port can be used for is_ready function which indicate that the port is being activate for specific duration</li> <li><code>response</code>: Port can register responses</li> <li><code>reward</code>: Port can deliver rewards</li> <li><code>invert</code>: Invert port signal</li> </ul> </li> </ul>"},{"location":"setup_configuration_idx/#2-screen-configuration-setupconfigurationscreen","title":"2. Screen Configuration (<code>SetupConfiguration.Screen</code>)","text":"<p>Defines display settings for visual stimuli.</p> <pre><code>screen_idx             : tinyint\n-&gt; SetupConfiguration\n---\nintensity             : tinyint UNSIGNED\ndistance              : float\ncenter_x              : float\ncenter_y              : float\naspect                : float\nsize                  : float\nfps                   : tinyint UNSIGNED\nresolution_x          : smallint\nresolution_y          : smallint\ndescription           : varchar(256)\nfullscreen            : tinyint\n</code></pre>"},{"location":"setup_configuration_idx/#3-ball-configuration-setupconfigurationball","title":"3. Ball Configuration (<code>SetupConfiguration.Ball</code>)","text":"<p>Defines settings for ball-based interfaces (e.g., virtual reality).</p> <pre><code>-&gt; SetupConfiguration\n---\nball_radius=0.125     : float                   # in meters\nmaterial=\"styrofoam\"  : varchar(64)             # ball material\ncoupling=\"bearings\"   : enum('bearings','air')  # mechanical coupling\ndiscription           : varchar(256)\n</code></pre>"},{"location":"setup_configuration_idx/#4-speaker-configuration-setupconfigurationspeaker","title":"4. Speaker Configuration (<code>SetupConfiguration.Speaker</code>)","text":"<p>Defines audio output settings.</p> <pre><code>speaker_idx           : tinyint\n-&gt; SetupConfiguration\n---\nsound_freq=10000     : int           # in Hz\nduration=500         : int           # in ms\nvolume=50            : tinyint       # 0-100 percentage\ndiscription         : varchar(256)\n</code></pre>"},{"location":"setup_configuration_idx/#5-camera-configuration-setupconfigurationcamera","title":"5. Camera Configuration (<code>SetupConfiguration.Camera</code>)","text":"<p>Defines camera settings for behavioral recording.</p> <pre><code>camera_idx            : tinyint\n-&gt; SetupConfiguration\n---\nfps                   : tinyint UNSIGNED\nresolution_x          : smallint\nresolution_y          : smallint\nshutter_speed         : smallint\niso                   : smallint\nfile_format           : varchar(256)\nvideo_aim             : enum('eye','body','openfield')\ndiscription           : varchar(256)\n</code></pre>"},{"location":"setup_configuration_idx/#creating-a-new-setup-configuration","title":"Creating a New Setup Configuration","text":"<p>To create a new setup configuration:</p> <ol> <li> <p>Add Main Configuration Entry <pre><code># Add to SetupConfiguration.contents\n[\n    setup_conf_idx,    # Unique identifier\n    interface_type,    # e.g., \"RPPorts\"\n    description        # Setup description\n]\n</code></pre></p> </li> <li> <p>Add Component Configurations <pre><code># Example: Adding port configuration\nSetupConfiguration.Port.insert1({\n    'setup_conf_idx': your_idx,\n    'port': port_number,\n    'type': 'Lick',\n    'ready': 0,\n    'response': 1,\n    'reward': 1,\n    'invert': 0,\n    'discription': 'Reward port'\n})\n</code></pre></p> </li> <li> <p>Add Required Components</p> </li> <li>Add entries to relevant component tables (Screen, Camera, etc.)</li> <li>Each component must reference the same <code>setup_conf_idx</code></li> </ol>"},{"location":"setup_configuration_idx/#usage-example","title":"Usage Example","text":"<pre><code># Example of a complete setup configuration\nsetup_config = {\n    'setup_conf_idx': 1,\n    'interface': 'RPPorts',\n    'discription': 'Raspberry Pi Setup'\n}\n\nport_config = {\n    'setup_conf_idx': 1,\n    'port': 1,\n    'type': 'Lick',\n    'ready': 1,\n    'response': 1,\n    'reward': 1,\n    'discription': 'Main reward port'\n}\n\nscreen_config = {\n    'setup_conf_idx': 1,\n    'screen_idx': 1,\n    'intensity': 100,\n    'distance': 10.0,\n    'resolution_x': 1920,\n    'resolution_y': 1080,\n    'fullscreen': 1\n}\n</code></pre>"},{"location":"setup_configuration_idx/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Component Initialization Failures<ul> <li>Check <code>setup_conf_idx</code> references</li> <li>Verify hardware connections</li> </ul> </li> </ul>"},{"location":"setup_configuration_idx/#default-configuration","title":"Default Configuration","text":"<p>EthoPy includes a default simulation configuration: <pre><code># Default setup (setup_conf_idx = 0)\ncontents = [\n    [0, \"DummyPorts\", \"Simulation\"]\n]\n\n# Default ports\nPort.contents = [\n    [1, \"Lick\", 0, 0, 1, 1, 0, \"probe\"],\n    [2, \"Lick\", 0, 0, 1, 1, 0, \"probe\"],\n    [3, \"Proximity\", 0, 1, 0, 0, 0, \"probe\"]\n]\n\n# Default screen\nScreen.contents = [\n    [1, 0, 64, 5.0, 0, -0.1, 1.66, 7.0, 30, 800, 480, \"Simulation\", 0]\n]\n</code></pre></p>"},{"location":"stimulus/","title":"Core Stimulus module","text":"<p>Module for handling stimulus presentation in behavioral experiments.</p> <p>This module provides a base Stimulus class that handles the presentation of various types of stimuli during behavioral experiments. It includes functionality for stimulus preparation, presentation, logging, and cleanup.</p>"},{"location":"stimulus/#ethopy.core.stimulus.StimCondition","title":"<code>StimCondition</code>","text":"<p>               Bases: <code>Manual</code></p> <p>Datajoint table for the stimulus presentation hash.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>@stimulus.schema\nclass StimCondition(dj.Manual):\n    \"\"\"Datajoint table for the stimulus presentation hash.\"\"\"\n\n    definition = \"\"\"\n    # This class handles the stimulus presentation use function overrides for each\n    # stimulus class\n    stim_hash            : char(24)   # unique stimulus condition hash\n    \"\"\"\n\n    class Trial(dj.Part):\n        \"\"\"Datajoint table for the Stimulus onset timestamps.\"\"\"\n\n        definition = \"\"\"\n        # Stimulus onset timestamps\n        -&gt; experiment.Trial\n        period='Trial'       : varchar(16)\n        ---\n        -&gt; StimCondition\n        start_time           : int   # start time from session start (ms)\n        end_time=NULL        : int   # end time from session start (ms)\n        \"\"\"\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.StimCondition.Trial","title":"<code>Trial</code>","text":"<p>               Bases: <code>Part</code></p> <p>Datajoint table for the Stimulus onset timestamps.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>class Trial(dj.Part):\n    \"\"\"Datajoint table for the Stimulus onset timestamps.\"\"\"\n\n    definition = \"\"\"\n    # Stimulus onset timestamps\n    -&gt; experiment.Trial\n    period='Trial'       : varchar(16)\n    ---\n    -&gt; StimCondition\n    start_time           : int   # start time from session start (ms)\n    end_time=NULL        : int   # end time from session start (ms)\n    \"\"\"\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus","title":"<code>Stimulus</code>","text":"<p>Base class for handling stimulus presentation in behavioral experiments.</p> <p>This class provides the core functionality for managing stimuli in behavioral experiments, including initialization, presentation, logging, and cleanup. It can be subclassed to implement specific types of stimuli.</p> <p>Attributes:</p> Name Type Description <code>cond_tables</code> <code>List[str]</code> <p>List of condition table names.</p> <code>required_fields</code> <code>List[str]</code> <p>List of required fields for stimulus conditions.</p> <code>default_key</code> <code>Dict[str, Any]</code> <p>Default key-value pairs for stimulus conditions.</p> <code>curr_cond</code> <code>Dict[str, Any]</code> <p>Current stimulus condition parameters.</p> <code>conditions</code> <code>List[Dict[str, Any]]</code> <p>List of all stimulus conditions.</p> <code>timer</code> <code>Timer</code> <p>Timer object for tracking stimulus timing.</p> <code>period</code> <code>str</code> <p>Current experimental period ('Trial' by default).</p> <code>in_operation</code> <code>bool</code> <p>Flag indicating if stimulus is currently active.</p> <code>flip_count</code> <code>int</code> <p>Counter for screen flips.</p> <code>photodiode</code> <code>bool</code> <p>Flag for photodiode triggering.</p> <code>rec_fliptimes</code> <code>bool</code> <p>Flag for recording flip times.</p> <code>fill_colors</code> <code>DictStruct</code> <p>Structure containing color values for different states</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>class Stimulus:\n    \"\"\"Base class for handling stimulus presentation in behavioral experiments.\n\n    This class provides the core functionality for managing stimuli in behavioral\n    experiments, including initialization, presentation, logging, and cleanup. It can be\n    subclassed to implement specific types of stimuli.\n\n    Attributes:\n        cond_tables (List[str]): List of condition table names.\n        required_fields (List[str]): List of required fields for stimulus conditions.\n        default_key (Dict[str, Any]): Default key-value pairs for stimulus conditions.\n        curr_cond (Dict[str, Any]): Current stimulus condition parameters.\n        conditions (List[Dict[str, Any]]): List of all stimulus conditions.\n        timer (Timer): Timer object for tracking stimulus timing.\n        period (str): Current experimental period ('Trial' by default).\n        in_operation (bool): Flag indicating if stimulus is currently active.\n        flip_count (int): Counter for screen flips.\n        photodiode (bool): Flag for photodiode triggering.\n        rec_fliptimes (bool): Flag for recording flip times.\n        fill_colors (DictStruct): Structure containing color values for different states\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize stimulus attributes.\"\"\"\n        self.cond_tables: List[str] = []\n        self.required_fields: List[str] = []\n        self.default_key: Dict[str, Any] = {}\n        self.curr_cond: Dict[str, Any] = {}\n        self.timer: Timer = Timer()\n        self.period: str = \"Trial\"\n        self.in_operation: bool = False\n        self.flip_count: int = 0\n        self.photodiode: bool = False\n        self.rec_fliptimes: bool = False\n        self.fill_colors: FillColors = FillColors()\n        self.logger = None\n        self.exp = None\n        self.monitor = None\n        self.Presenter = None\n        self.start_time: Optional[float] = None\n\n    def init(self, exp) -&gt; None:\n        \"\"\"Initialize stimulus with experiment object and setup screen properties.\n\n        Args:\n            exp (Experiment): Experiment object containing logger and interface\n                components.\n\n        \"\"\"\n        self.logger = exp.logger\n        self.exp = exp\n        screen_properties = self.logger.get(\n            schema=\"interface\",\n            table=\"SetupConfiguration.Screen\",\n            key=self.exp.params,\n            as_dict=True,\n        )\n        self.monitor = DictStruct(screen_properties[0])\n        if self.logger.is_pi:\n            cmd = (\n                \"echo %d &gt; /sys/class/backlight/rpi_backlight/brightness\"\n                % self.monitor.intensity\n            )\n            os.system(cmd)\n            exp.interface.setup_touch_exit()\n\n    def setup(self) -&gt; None:\n        \"\"\"Set up stimulus presentation environment.\n\n        Initializes the Presenter object with monitor settings and background color.\n        Should be called before starting the experiment.\n        \"\"\"\n        self.Presenter = Presenter(\n            self.logger,\n            self.monitor,\n            background_color=self.fill_colors.background,\n            photodiode=self.photodiode,\n            rec_fliptimes=self.rec_fliptimes,\n        )\n\n    def prepare(self, curr_cond=False, stim_period=\"\") -&gt; None:\n        \"\"\"Prepare stuff for presentation before trial starts.\"\"\"\n        self.curr_cond = curr_cond if stim_period == \"\" else curr_cond[stim_period]\n        self.period = stim_period\n\n    def start(self) -&gt; None:\n        \"\"\"Start stimulus.\"\"\"\n        self.in_operation = True\n        self.log_start()\n        self.timer.start()\n\n    def present(self) -&gt; None:\n        \"\"\"Present stimulus.\n\n        This is a placeholder method that should be overridden by subclasses\n        to implement specific stimulus presentation logic.\n        \"\"\"\n\n    def fill(self, color=False) -&gt; None:\n        \"\"\"Stimulus hidding method.\"\"\"\n        if not color:\n            color = self.fill_colors.background\n        if self.fill_colors.background:\n            self.Presenter.fill(color)\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop stimulus.\"\"\"\n        self.fill()\n        self.log_stop()\n        self.in_operation = False\n\n    def exit(self) -&gt; None:\n        \"\"\"Exit stimulus stuff.\"\"\"\n        self.Presenter.quit()\n\n    def ready_stim(self) -&gt; None:\n        \"\"\"Stim Cue for ready.\"\"\"\n        if self.fill_colors.ready:\n            self.fill(self.fill_colors.ready)\n\n    def reward_stim(self) -&gt; None:\n        \"\"\"Stim Cue for reward.\"\"\"\n        if self.fill_colors.reward:\n            self.fill(self.fill_colors.reward)\n\n    def punish_stim(self) -&gt; None:\n        \"\"\"Stim Cue for punishment.\"\"\"\n        if self.fill_colors.punish:\n            self.fill(self.fill_colors.punish)\n\n    def start_stim(self) -&gt; None:\n        \"\"\"Stim Cue for start.\"\"\"\n        if self.fill_colors.start:\n            self.fill(self.fill_colors.start)\n\n    def log_start(self) -&gt; None:\n        \"\"\"Start timer for the log of stimlus condition.\"\"\"\n        self.start_time = self.logger.logger_timer.elapsed_time()\n        self.exp.interface.sync_out(True)\n\n    def log_stop(self) -&gt; None:\n        \"\"\"Log stimulus condition start &amp; stop time.\"\"\"\n        stop_time = self.logger.logger_timer.elapsed_time()\n        self.exp.interface.sync_out(False)\n        self.logger.log(\n            \"StimCondition.Trial\",\n            dict(\n                period=self.period,\n                stim_hash=self.curr_cond[\"stim_hash\"],\n                start_time=self.start_time,\n                end_time=stop_time,\n            ),\n            schema=\"stimulus\",\n        )\n\n    def make_conditions(\n        self, conditions: List[Dict[str, Any]] = None\n    ) -&gt; List[Dict[str, Any]]:\n        \"\"\"Generate and store stimulus conditions.\n\n        Args:\n            conditions: List of condition dictionaries to process.\n\n        Returns:\n            List of processed condition dictionaries with hashes.\n\n        Raises:\n            AssertionError: If required fields are missing from any condition.\n\n        \"\"\"\n        # check for any missing field from the required fields and add the default keys\n        for cond in conditions:\n            missing_fields = [\n                field for field in self.required_fields if field not in cond\n            ]\n            assert not missing_fields, (\n                f\"Missing Stimulus required fields: {missing_fields}\"\n            )\n            cond.update({**self.default_key, **cond})\n        # log stim conditions\n        conditions = self.exp.log_conditions(\n            conditions,\n            schema=\"stimulus\",\n            hash_field=\"stim_hash\",\n            condition_tables=[\"StimCondition\"] + self.cond_tables,\n        )\n        return conditions\n\n    def name(self) -&gt; str:\n        \"\"\"Get the name of the stimulus class.\n\n        Returns:\n            (str):Name of the current stimulus class.\n\n        \"\"\"\n        return type(self).__name__\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.__init__","title":"<code>__init__()</code>","text":"<p>Initialize stimulus attributes.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize stimulus attributes.\"\"\"\n    self.cond_tables: List[str] = []\n    self.required_fields: List[str] = []\n    self.default_key: Dict[str, Any] = {}\n    self.curr_cond: Dict[str, Any] = {}\n    self.timer: Timer = Timer()\n    self.period: str = \"Trial\"\n    self.in_operation: bool = False\n    self.flip_count: int = 0\n    self.photodiode: bool = False\n    self.rec_fliptimes: bool = False\n    self.fill_colors: FillColors = FillColors()\n    self.logger = None\n    self.exp = None\n    self.monitor = None\n    self.Presenter = None\n    self.start_time: Optional[float] = None\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.exit","title":"<code>exit()</code>","text":"<p>Exit stimulus stuff.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Exit stimulus stuff.\"\"\"\n    self.Presenter.quit()\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.fill","title":"<code>fill(color=False)</code>","text":"<p>Stimulus hidding method.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def fill(self, color=False) -&gt; None:\n    \"\"\"Stimulus hidding method.\"\"\"\n    if not color:\n        color = self.fill_colors.background\n    if self.fill_colors.background:\n        self.Presenter.fill(color)\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.init","title":"<code>init(exp)</code>","text":"<p>Initialize stimulus with experiment object and setup screen properties.</p> <p>Parameters:</p> Name Type Description Default <code>exp</code> <code>Experiment</code> <p>Experiment object containing logger and interface components.</p> required Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def init(self, exp) -&gt; None:\n    \"\"\"Initialize stimulus with experiment object and setup screen properties.\n\n    Args:\n        exp (Experiment): Experiment object containing logger and interface\n            components.\n\n    \"\"\"\n    self.logger = exp.logger\n    self.exp = exp\n    screen_properties = self.logger.get(\n        schema=\"interface\",\n        table=\"SetupConfiguration.Screen\",\n        key=self.exp.params,\n        as_dict=True,\n    )\n    self.monitor = DictStruct(screen_properties[0])\n    if self.logger.is_pi:\n        cmd = (\n            \"echo %d &gt; /sys/class/backlight/rpi_backlight/brightness\"\n            % self.monitor.intensity\n        )\n        os.system(cmd)\n        exp.interface.setup_touch_exit()\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.log_start","title":"<code>log_start()</code>","text":"<p>Start timer for the log of stimlus condition.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def log_start(self) -&gt; None:\n    \"\"\"Start timer for the log of stimlus condition.\"\"\"\n    self.start_time = self.logger.logger_timer.elapsed_time()\n    self.exp.interface.sync_out(True)\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.log_stop","title":"<code>log_stop()</code>","text":"<p>Log stimulus condition start &amp; stop time.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def log_stop(self) -&gt; None:\n    \"\"\"Log stimulus condition start &amp; stop time.\"\"\"\n    stop_time = self.logger.logger_timer.elapsed_time()\n    self.exp.interface.sync_out(False)\n    self.logger.log(\n        \"StimCondition.Trial\",\n        dict(\n            period=self.period,\n            stim_hash=self.curr_cond[\"stim_hash\"],\n            start_time=self.start_time,\n            end_time=stop_time,\n        ),\n        schema=\"stimulus\",\n    )\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.make_conditions","title":"<code>make_conditions(conditions=None)</code>","text":"<p>Generate and store stimulus conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>List[Dict[str, Any]]</code> <p>List of condition dictionaries to process.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of processed condition dictionaries with hashes.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If required fields are missing from any condition.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def make_conditions(\n    self, conditions: List[Dict[str, Any]] = None\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Generate and store stimulus conditions.\n\n    Args:\n        conditions: List of condition dictionaries to process.\n\n    Returns:\n        List of processed condition dictionaries with hashes.\n\n    Raises:\n        AssertionError: If required fields are missing from any condition.\n\n    \"\"\"\n    # check for any missing field from the required fields and add the default keys\n    for cond in conditions:\n        missing_fields = [\n            field for field in self.required_fields if field not in cond\n        ]\n        assert not missing_fields, (\n            f\"Missing Stimulus required fields: {missing_fields}\"\n        )\n        cond.update({**self.default_key, **cond})\n    # log stim conditions\n    conditions = self.exp.log_conditions(\n        conditions,\n        schema=\"stimulus\",\n        hash_field=\"stim_hash\",\n        condition_tables=[\"StimCondition\"] + self.cond_tables,\n    )\n    return conditions\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.name","title":"<code>name()</code>","text":"<p>Get the name of the stimulus class.</p> <p>Returns:</p> Type Description <code>str</code> <p>Name of the current stimulus class.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"Get the name of the stimulus class.\n\n    Returns:\n        (str):Name of the current stimulus class.\n\n    \"\"\"\n    return type(self).__name__\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.prepare","title":"<code>prepare(curr_cond=False, stim_period='')</code>","text":"<p>Prepare stuff for presentation before trial starts.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def prepare(self, curr_cond=False, stim_period=\"\") -&gt; None:\n    \"\"\"Prepare stuff for presentation before trial starts.\"\"\"\n    self.curr_cond = curr_cond if stim_period == \"\" else curr_cond[stim_period]\n    self.period = stim_period\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.present","title":"<code>present()</code>","text":"<p>Present stimulus.</p> <p>This is a placeholder method that should be overridden by subclasses to implement specific stimulus presentation logic.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def present(self) -&gt; None:\n    \"\"\"Present stimulus.\n\n    This is a placeholder method that should be overridden by subclasses\n    to implement specific stimulus presentation logic.\n    \"\"\"\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.punish_stim","title":"<code>punish_stim()</code>","text":"<p>Stim Cue for punishment.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def punish_stim(self) -&gt; None:\n    \"\"\"Stim Cue for punishment.\"\"\"\n    if self.fill_colors.punish:\n        self.fill(self.fill_colors.punish)\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.ready_stim","title":"<code>ready_stim()</code>","text":"<p>Stim Cue for ready.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def ready_stim(self) -&gt; None:\n    \"\"\"Stim Cue for ready.\"\"\"\n    if self.fill_colors.ready:\n        self.fill(self.fill_colors.ready)\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.reward_stim","title":"<code>reward_stim()</code>","text":"<p>Stim Cue for reward.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def reward_stim(self) -&gt; None:\n    \"\"\"Stim Cue for reward.\"\"\"\n    if self.fill_colors.reward:\n        self.fill(self.fill_colors.reward)\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.setup","title":"<code>setup()</code>","text":"<p>Set up stimulus presentation environment.</p> <p>Initializes the Presenter object with monitor settings and background color. Should be called before starting the experiment.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"Set up stimulus presentation environment.\n\n    Initializes the Presenter object with monitor settings and background color.\n    Should be called before starting the experiment.\n    \"\"\"\n    self.Presenter = Presenter(\n        self.logger,\n        self.monitor,\n        background_color=self.fill_colors.background,\n        photodiode=self.photodiode,\n        rec_fliptimes=self.rec_fliptimes,\n    )\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.start","title":"<code>start()</code>","text":"<p>Start stimulus.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start stimulus.\"\"\"\n    self.in_operation = True\n    self.log_start()\n    self.timer.start()\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.start_stim","title":"<code>start_stim()</code>","text":"<p>Stim Cue for start.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def start_stim(self) -&gt; None:\n    \"\"\"Stim Cue for start.\"\"\"\n    if self.fill_colors.start:\n        self.fill(self.fill_colors.start)\n</code></pre>"},{"location":"stimulus/#ethopy.core.stimulus.Stimulus.stop","title":"<code>stop()</code>","text":"<p>Stop stimulus.</p> Source code in <code>src/ethopy/core/stimulus.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop stimulus.\"\"\"\n    self.fill()\n    self.log_stop()\n    self.in_operation = False\n</code></pre>"},{"location":"task_setup/","title":"Tasks","text":"<p>Tasks in Ethopy define the experimental protocol by combining experiments, behaviors, and stimuli with specific parameters. They serve as configuration files that specify how an experiment should run.</p>"},{"location":"task_setup/#task-structure","title":"Task Structure","text":"<p>A typical task file consists of three main parts:</p> <ol> <li>Session Parameters: Global settings for the experiment</li> <li>Stimulus/Behavior/Experiment Conditions: Parameters</li> <li>Experiment Configuration: Setup and execution of the experiment</li> </ol>"},{"location":"task_setup/#basic-structure","title":"Basic Structure","text":"<pre><code># Import required components\nfrom ethopy.behaviors import SomeBehavior\nfrom ethopy.experiments import SomeExperiment\nfrom ethopy.stimuli import SomeStimulus\n\n# 1. Session Parameters\nsession_params = {\n    'setup_conf_idx': 0,\n    # ... other session parameters\n}\n\n# 2. Initialize Experiment\nexp = SomeExperiment()\nexp.setup(logger, SomeBehavior, session_params)\n\n# 3. Define Experiment/Stimulus/Behavior Conditions\nconditions = []\n# ... condition setup\n\n# 4. Run Experiment\nexp.push_conditions(conditions)\nexp.start()\n</code></pre>"},{"location":"task_setup/#creating-tasks","title":"Creating Tasks","text":""},{"location":"task_setup/#1-session-parameters","title":"1. Session Parameters","text":"<p>Session parameters control the overall experiment behavior:</p> <pre><code>session_params = {\n    # Required Parameters\n    'setup_conf_idx': 0,  # Setup configuration index\n\n    # Optional Parameters\n    'max_reward': 3000,    # Maximum reward amount\n    'min_reward': 30,      # Minimum reward amount\n}\n</code></pre>"},{"location":"task_setup/#2-stimulus-conditions","title":"2. Stimulus Conditions","text":"<p>Define the parameters for your stimuli:</p> <pre><code># Example from grating_test.py\nkey = {\n    'contrast': 100,\n    'spatial_freq': 0.05,        # cycles/deg\n    'temporal_freq': 0,          # cycles/sec\n    'duration': 5000,            # ms\n    'trial_duration': 5000,      # ms\n    'intertrial_duration': 0,    # ms\n    'reward_amount': 8,\n    # ... other stimulus parameters\n}\n</code></pre>"},{"location":"task_setup/#3-creating-conditions","title":"3. Creating Conditions","text":"<p>Use the experiment's Block class and make_conditions method:</p> <pre><code># Create a block with specific parameters\nblock = exp.Block(\n    difficulty=1,\n    next_up=1,\n    next_down=1,\n    trial_selection='staircase',\n    metric='dprime',\n    stair_up=1,\n    stair_down=0.5\n)\n\n# Create conditions\nconditions = exp.make_conditions(\n    stim_class=SomeStimulus(),\n    conditions={**block.dict(), **key, 'other_param': value}\n)\n</code></pre>"},{"location":"task_setup/#helper-functions","title":"Helper Functions","text":"<p>Ethopy provides helper functions for task creation:</p>"},{"location":"task_setup/#get-parameters","title":"Get Parameters","text":"<pre><code>from ethopy.utils.task_helper_funcs import get_parameters\n\n# Get required and default parameters for a class\nparameters = get_parameters(SomeClass())\n</code></pre>"},{"location":"task_setup/#format-parameters","title":"Format Parameters","text":"<pre><code>from ethopy.utils.task_helper_funcs import format_params_print\n\n# Pretty print parameters including numpy arrays\nformatted_params = format_params_print(parameters)\n</code></pre>"},{"location":"task_setup/#example-tasks","title":"Example Tasks","text":""},{"location":"task_setup/#1-grating-test","title":"1. Grating Test","text":"<p>Visual orientation discrimination experiment:</p> <pre><code>from ethopy.behaviors.multi_port import MultiPort\nfrom ethopy.experiments.match_port import Experiment\nfrom ethopy.stimuli.grating import Grating\n\n# Session setup\nsession_params = {\n    'max_reward': 3000,\n    'setup_conf_idx': 0,\n}\n\nexp = Experiment()\nexp.setup(logger, MultiPort, session_params)\n\n# Stimulus conditions\nkey = {\n    'contrast': 100,\n    'spatial_freq': 0.05,\n    'duration': 5000,\n}\n\n# Port mapping\nports = {1: 0, 2: 90}  # Port number: orientation\n\n# Create conditions\nblock = exp.Block(difficulty=1, trial_selection='staircase')\nconditions = []\nfor port in ports:\n    conditions += exp.make_conditions(\n        stim_class=Grating(),\n        conditions={\n            **block.dict(),\n            **key,\n            'theta': ports[port],\n            'reward_port': port,\n            'response_port': port\n        }\n    )\n\n# Run\nexp.push_conditions(conditions)\nexp.start()\n</code></pre>"},{"location":"task_setup/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Parameter Organization:         - Group related parameters together         - Use descriptive variable names         - Document units in comments</p> </li> <li> <p>Error Handling:         - Validate parameters before running         - Use helper functions to get required parameters         - Check for missing or invalid values</p> </li> <li> <p>Documentation:         - Comment complex parameter combinations         - Document dependencies         - Include example usage</p> </li> <li> <p>Testing:         - Test with different parameter combinations         - Verify stimulus timing         - Check reward delivery</p> </li> </ol>"},{"location":"task_setup/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Parameter Errors:         - Missing required parameters         - Incorrect parameter types         - Invalid parameter combinations</p> </li> <li> <p>Timing Issues:         - Incorrect duration values         - Mismatched trial/stimulus timing         - Intertrial interval problems</p> </li> <li> <p>Hardware Configuration:         - Wrong setup_conf_idx         - Uncalibrated rewad ports         - Missing hardware components</p> </li> </ol>"},{"location":"task_setup/#additional-resources","title":"Additional Resources","text":"<ul> <li>Example Tasks</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide addresses common issues you might encounter when using EthoPy and provides solutions to help you resolve them quickly.</p>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#package-installation-failures","title":"Package Installation Failures","text":"<p>Problem: Installation fails with dependency conflicts.</p> <p>Solution:  1. Try creating a fresh virtual environment:    <pre><code>python -m venv ethopy_env\nsource ethopy_env/bin/activate  # On Windows: ethopy_env\\Scripts\\activate\npip install ethopy\n</code></pre></p> <ol> <li>If specific dependencies are failing, try installing them manually first:    <pre><code>pip install panda3d numpy pygame\npip install ethopy\n</code></pre></li> </ol>"},{"location":"troubleshooting/#importerror-after-installation","title":"ImportError After Installation","text":"<p>Problem: You get <code>ImportError: No module named 'ethopy'</code> after installation.</p> <p>Solution: 1. Verify the package is installed:    <pre><code>pip list | grep ethopy\n</code></pre></p> <ol> <li>Make sure you're using the same Python environment where you installed the package.</li> <li>If installed in development mode, check that your working directory is properly set.</li> </ol>"},{"location":"troubleshooting/#database-connection-issues","title":"Database Connection Issues","text":""},{"location":"troubleshooting/#cannot-connect-to-database","title":"Cannot Connect to Database","text":"<p>Problem: Error when connecting to MySQL database.</p> <p>Solution: 1. Verify your connection information in <code>local_conf.json</code>:    <pre><code>{\n \"dj_local_conf\": {\n     \"database.host\": \"127.0.0.1\",\n     \"database.user\": \"your_username\",\n     \"database.password\": \"your_password\",\n     \"database.port\": 3306,\n     \"database.reconnect\": true,\n     \"database.use_tls\": false,\n     \"datajoint.loglevel\": \"WARNING\"\n },\n}\n</code></pre></p> <ol> <li> <p>Make sure MySQL is running:    <pre><code># For Linux/Mac\nsudo service mysql status\n# or\nsudo systemctl status mysql\n\n# For Windows (check in services)\n</code></pre></p> </li> <li> <p>Test connection with MySQL client:    <pre><code>mysql -u your_username -p\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#schema-creation-errors","title":"Schema Creation Errors","text":"<p>Problem: Errors when creating the database schema.</p> <p>Solution: 1. Make sure the user has privileges to create databases and tables:    <pre><code>GRANT ALL PRIVILEGES ON *.* TO 'your_username'@'localhost';\nFLUSH PRIVILEGES;\n</code></pre></p> <ol> <li> <p>Try manually running the schema setup:    <pre><code>   python3 -c 'from ethopy.core.experiment import *'\n   python3 -c 'from ethopy.core.stimulus import *'\n   python3 -c 'from ethopy.core.sehavior import *'\n   python3 -c 'from ethopy.stimuli import *'\n   python3 -c 'from ethopy.behaviors import *'\n   python3 -c 'from ethopy.experiments import *'\n</code></pre></p> </li> <li> <p>Check for database encoding issues. EthoPy requires UTF-8 encoding.</p> </li> </ol>"},{"location":"troubleshooting/#hardware-interface-issues","title":"Hardware Interface Issues","text":""},{"location":"troubleshooting/#port-communication-problems","title":"Port Communication Problems","text":"<p>Problem: Cannot communicate with hardware ports.</p> <p>Solutions: ToDo</p>"},{"location":"troubleshooting/#raspberry-pi-specific-issues","title":"Raspberry Pi Specific Issues","text":"<p>Problem: Issues when running on Raspberry Pi.</p>"},{"location":"troubleshooting/#experiment-execution-issues","title":"Experiment Execution Issues","text":""},{"location":"troubleshooting/#experiment-fails-to-start","title":"Experiment Fails to Start","text":"<p>Problem: <code>ethopy -p your_task.py</code> fails to start the experiment.</p> <p>Solution: 1. Check for syntax errors in your task file. 2. Verify that experiment, behavior, and stimulus classes are correctly imported and assigned. 3. Run with debug logging:    <pre><code>ethopy -p your_task.py --log-console --log-level DEBUG\n</code></pre></p>"},{"location":"troubleshooting/#reward-delivery-failures","title":"Reward Delivery Failures","text":"<p>Problem: Water rewards are not being delivered correctly.</p> <p>Solution: 1. Run a calibration task to test the ports:    <pre><code>ethopy -p calibrate_ports.py\n</code></pre> 2. Check solenoid connections and power supply. 3. Verify port configuration in your setup.</p>"},{"location":"troubleshooting/#data-logging-issues","title":"Data Logging Issues","text":""},{"location":"troubleshooting/#missing-trial-data","title":"Missing Trial Data","text":"<p>Problem: Some trial data is not being logged to the database.</p> <p>Solution: 1. Check database connection during experiment execution. 2. Verify that your experiment states are correctly called.</p>"},{"location":"troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"troubleshooting/#no-task-found-with-idx-x","title":"\"No task found with idx X\"","text":"<p>Problem: <code>ethopy --task-idx X</code> returns \"No task found with idx X\".</p> <p>TODO: Solution: 1. Verify the task exists in the database:    <pre><code>ethopy --list-tasks\n</code></pre> 2. If missing, add your task to the database:    <pre><code>ethopy --add-task your_task.py\n</code></pre></p>"},{"location":"troubleshooting/#multiple-instances-detected","title":"\"Multiple instances detected\"","text":"<p>Problem: Attempt to run EthoPy when an instance is already running.</p> <p>Solution: 1. Find and close the existing EthoPy process:    <pre><code># Linux/Mac\nps aux | grep ethopy\nkill &lt;pid&gt;\n\n# Windows\ntasklist | findstr ethopy\ntaskkill /F /PID &lt;pid&gt;\n</code></pre></p>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li> <p>Check the documentation: Review related sections in the documentation for guidance.</p> </li> <li> <p>Search GitHub Issues: Check if your issue has been reported and addressed:    EthoPy GitHub Issues</p> </li> <li> <p>Submit an Issue: If your problem persists, submit a detailed issue on GitHub with:</p> </li> <li>EthoPy version (<code>ethopy --version</code>)</li> <li>Python version (<code>python --version</code>)</li> <li>Operating system details</li> <li>Complete error message and traceback</li> <li> <p>Steps to reproduce the problem</p> </li> <li> <p>Contact Maintainers: For urgent issues, contact the package maintainers directly.</p> </li> </ol>"},{"location":"troubleshooting/#appendix-log-files","title":"Appendix: Log Files","text":"<p>EthoPy creates log files that can be valuable for troubleshooting.</p> <p>Reviewing these logs can provide insights into issues not apparent from console output.</p>"},{"location":"usage/","title":"Usage","text":"<p>To use EthoPy in a project:</p> <pre><code>import ethopy\n</code></pre>"},{"location":"visualizations/","title":"Visualizations","text":""},{"location":"visualizations/#basic-visualizations","title":"Basic Visualizations","text":""},{"location":"visualizations/#session-performace","title":"Session Performace","text":""},{"location":"visualizations/#licks","title":"Licks","text":""},{"location":"visualizations/#across-many-sessions","title":"Across many sessions","text":""},{"location":"visualizations/#performance-per-day","title":"Performance per day","text":""},{"location":"visualizations/#real-time-plots","title":"Real time plots","text":""}]}